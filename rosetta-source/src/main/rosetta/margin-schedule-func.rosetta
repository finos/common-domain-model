namespace cdm.margin.schedule
version "${project.version}"

import cdm.event.workflow.*
import cdm.event.common.*
import cdm.event.position.*

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*

import cdm.product.qualification.*
import cdm.product.template.*
import cdm.product.asset.*
import cdm.product.common.settlement.*

import cdm.observable.asset.*

func BuildStandardizedSchedule: <"Takes a trade and uses qualification to extract the relevant information to populate the grid that will be used to calculate the gross initial margin.">
    inputs:
        trade Trade (1..1)
    output:
        standardizedSchedule StandardizedSchedule (1..1)
    alias assetClass: StandardizedScheduleAssetClass(trade)
    alias productClass: StandardizedScheduleProductClass(trade)
    set standardizedSchedule -> assetClass: assetClass
    set standardizedSchedule -> productClass: productClass
    set standardizedSchedule -> notional:
        StandardizedScheduleNotional(trade, assetClass, productClass)
    set standardizedSchedule -> notionalCurrency:
        StandardizedScheduleNotionalCurrency(trade, assetClass, productClass)
    set standardizedSchedule -> durationInYears:
        StandardizedScheduleDuration(trade, assetClass, productClass)

func GetGrossInitialMarginFromStandardizedSchedule: <"Takes the grid information from an specific trade and calculates the gross initial margin.">
    inputs:
        standardizedSchedule StandardizedSchedule (1..1)
    output:
        grossInitialMargin Money (0..1)
    alias initialMarginRequirement:
        GetStandardizedScheduleMarginRate(
                standardizedSchedule -> assetClass,
                standardizedSchedule -> durationInYears
            )
    set grossInitialMargin -> value:
        standardizedSchedule -> notional * initialMarginRequirement * 0.01
    set grossInitialMargin -> unit -> currency: standardizedSchedule -> notionalCurrency

    post-condition PositiveGrossInitialMargin: <"Ensure gross initial margin is greater than 0">
        grossInitialMargin -> value > 0

func StandardizedScheduleAssetClass: <"Identifies the asset class of a trade from qualifying functions, according to the standardized schedule classification.">
    inputs:
        trade Trade (1..1)
    output:
        assetClass StandardizedScheduleAssetClassEnum (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set assetClass:
        if Qualify_AssetClass_InterestRate(economicTerms)
        then StandardizedScheduleAssetClassEnum -> InterestRates
        else if Qualify_AssetClass_Credit(economicTerms)
        then StandardizedScheduleAssetClassEnum -> Credit
        else if Qualify_AssetClass_ForeignExchange(economicTerms)
        then StandardizedScheduleAssetClassEnum -> ForeignExchange
        else if Qualify_AssetClass_Equity(economicTerms)
        then StandardizedScheduleAssetClassEnum -> Equity
        else if Qualify_AssetClass_Commodity(economicTerms)
        then StandardizedScheduleAssetClassEnum -> Commodity

func StandardizedScheduleProductClass: <"Identifies the product class of a trade from qualifying functions, according to the standardized schedule classification.">
    inputs:
        trade Trade (1..1)
    output:
        productClass StandardizedScheduleProductClassEnum (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set productClass:
        if IsIRSwapWithCallableBermudanRightToEnterExitSwaps(economicTerms)
        then StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
        else if Qualify_BaseProduct_IRSwap(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swap
        else if Qualify_BaseProduct_CrossCurrency(economicTerms)
        then StandardizedScheduleProductClassEnum -> CrossCurrencySwap
        else if IsIRSwaptionStraddle(economicTerms)
        then StandardizedScheduleProductClassEnum -> SwaptionStraddle
        else if Qualify_InterestRate_Option_Swaption(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swaption
        // IR Exotic swap with an exotic coupon against a floating leg not supported
        else if Qualify_InterestRate_CapFloor(economicTerms)
        then StandardizedScheduleProductClassEnum -> Option
        else if Qualify_InterestRate_Fra(economicTerms)
        then StandardizedScheduleProductClassEnum -> ForwardRateAgreement
        else if Qualify_CreditDefaultSwap_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
        else if Qualify_CreditDefaultSwap_Index(economicTerms)
        then StandardizedScheduleProductClassEnum -> IndexCDS
        else if Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
        then StandardizedScheduleProductClassEnum -> IndexTranche
        else if Qualify_CreditDefaultSwaption(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swaption
        else if IsCreditNthToDefault(economicTerms)
        then StandardizedScheduleProductClassEnum -> CreditNthToDefault
        // Credit Total return swap on a bond not supported
        else if Qualify_ForeignExchange_Swap(economicTerms)
        then StandardizedScheduleProductClassEnum -> DeliverableSwap
        else if Qualify_ForeignExchange_NDS(economicTerms)
        then StandardizedScheduleProductClassEnum -> NonDeliverableCrossCurrencySwap
        else if Qualify_ForeignExchange_Spot_Forward(economicTerms)
        then StandardizedScheduleProductClassEnum -> DeliverableForward
        else if Qualify_ForeignExchange_NDF(economicTerms)
        then StandardizedScheduleProductClassEnum -> NonDeliverableForward
        else if IsFXDeliverableOption(economicTerms)
        then StandardizedScheduleProductClassEnum -> DeliverableOption
        else if IsFXNonDeliverableOption(economicTerms)
        then StandardizedScheduleProductClassEnum -> NonDeliverableOption
        else if Qualify_ForeignExchange_ParameterReturnVariance(economicTerms)
        then StandardizedScheduleProductClassEnum -> VarianceSwap
        else if Qualify_ForeignExchange_ParameterReturnVolatility(economicTerms)
        then StandardizedScheduleProductClassEnum -> VolatilitySwap
        else if Qualify_ForeignExchange_ParameterReturnCorrelation(economicTerms)
        then StandardizedScheduleProductClassEnum -> CorrelationSwap
        else if Qualify_EquityOption_PriceReturnBasicPerformance_Basket(economicTerms)
                or Qualify_EquityOption_PriceReturnBasicPerformance_Index(economicTerms)
                or Qualify_EquityOption_PriceReturnBasicPerformance_SingleName(
                        economicTerms
                    )
                or Qualify_EquityOption_ParameterReturnVolatility_Basket(economicTerms)
                or Qualify_EquityOption_ParameterReturnVolatility_Index(economicTerms)
                or Qualify_EquityOption_ParameterReturnVolatility_SingleName(economicTerms)
                or Qualify_EquityOption_ParameterReturnVariance_Basket(economicTerms)
                or Qualify_EquityOption_ParameterReturnVariance_Index(economicTerms)
                or Qualify_EquityOption_ParameterReturnVariance_SingleName(economicTerms)
                or Qualify_EquityOption_ParameterReturnCorrelation_Basket(economicTerms)
                    // or Qualify_EquityOption_ParameterReturnCorrelation_Index(economicTerms)
                    // or Qualify_EquityOption_ParameterReturnCorrelation_SingleName(economicTerms)
                or Qualify_EquityOption_ParameterReturnDividend_Basket(economicTerms)
                or Qualify_EquityOption_ParameterReturnDividend_Index(economicTerms)
                or Qualify_EquityOption_ParameterReturnDividend_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> Option
        else if Qualify_BaseProduct_EquityForward(economicTerms)
        then StandardizedScheduleProductClassEnum -> Forward
        else if Qualify_EquitySwap_ParameterReturnDividend_Basket(economicTerms)
                or Qualify_EquitySwap_ParameterReturnDividend_Index(economicTerms)
                or Qualify_EquitySwap_ParameterReturnDividend_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> DividendSwap
        else if Qualify_EquitySwap_ParameterReturnVariance_Basket(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVariance_Index(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVariance_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> VarianceSwap
        else if Qualify_EquitySwap_ParameterReturnVolatility_Basket(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVolatility_Index(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVolatility_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> VolatilitySwap
        // EQ Contract fo Difference (CFD) not supported
        else if Qualify_BaseProduct_EquitySwap(economicTerms)
        then StandardizedScheduleProductClassEnum -> SwapsAndPortfolioSwaps
        else if Qualify_Commodity_Forward(economicTerms)
        then StandardizedScheduleProductClassEnum -> Forward
        else if Qualify_Commodity_Option(economicTerms)
        then StandardizedScheduleProductClassEnum -> Option
        else if Qualify_Commodity_Swap_FixedFloat(economicTerms)
        then StandardizedScheduleProductClassEnum -> FixedFloatSwap
        else if Qualify_Commodity_Swap_Basis(economicTerms)
        then StandardizedScheduleProductClassEnum -> BasisSwap
        else if Qualify_Commodity_Swaption(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swaption

// CO Contract for Difference (CFD) not supported
func StandardizedScheduleNotional: <"Extracts the notional amount of a trade, according to the product class-depending extraction method defined in the ISDA industry survey.">
    inputs:
        trade Trade (1..1)
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        productClass StandardizedScheduleProductClassEnum (1..1)
    output:
        notional number (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set notional:
        if assetClass = StandardizedScheduleAssetClassEnum -> InterestRates
        then (if productClass = StandardizedScheduleProductClassEnum -> Swap
                    or productClass = StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
            then (economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> CrossCurrencySwap
            then (economicTerms -> payout -> InterestRatePayout
                filter (True /*how do we identify the receiver party?*/ )
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
                    or productClass = StandardizedScheduleProductClassEnum -> SwaptionStraddle
            then (UnderlierForProduct(product) -> Product ->> economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            // IR Exotic swap with an exotic coupon against a floating leg not supported
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> InterestRatePayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> ForwardRateAgreement
            then (economicTerms -> payout -> InterestRatePayout
                filter rateSpecification -> FixedRateSpecification exists
                then only-element
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ))
        else if assetClass = StandardizedScheduleAssetClassEnum -> Credit
        then (if productClass = StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
                    or productClass = StandardizedScheduleProductClassEnum -> IndexCDS
                    or productClass = StandardizedScheduleProductClassEnum -> IndexTranche
                    or productClass = StandardizedScheduleProductClassEnum -> CreditNthToDefault
            then (economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (UnderlierForProduct(product) -> Product ->> economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ) // Credit Total return swap on a bond not supported
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> ForeignExchange
        then (if productClass = StandardizedScheduleProductClassEnum -> DeliverableSwap
            then (StandardizedScheduleFXSwapNotional(
                        FXFarLeg(product),
                        trade -> tradeLot only-element
                    ) -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableCrossCurrencySwap
            then 0.0 // Recieve side notional and currency. What does that mean?
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (
                        StandardizedScheduleFXVarianceNotionalAmount(economicTerms -> payout -> PerformancePayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then 0.0 // Vega notional amount not mapped in the product
            else if productClass = StandardizedScheduleProductClassEnum -> CorrelationSwap
            then 0.0 // No sample trades
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Equity
        then (if productClass = StandardizedScheduleProductClassEnum -> Option
            then (
                        StandardizedScheduleOptionNotionalAmount(economicTerms -> payout -> OptionPayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (
                        StandardizedScheduleEquityForwardNotionalAmount(economicTerms -> payout -> SettlementPayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> DividendSwap
            then 0.0 // All dividend swaps are defined with a monetary payment, no strike price or number of shares
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (
                        StandardizedScheduleVarianceSwapNotionalAmount(economicTerms -> payout -> PerformancePayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then 0.0 // Is volatility amount = vega notional amount?
                // EQ Contract fo Difference (CFD) not supported
            else if productClass = StandardizedScheduleProductClassEnum -> SwapsAndPortfolioSwaps
            then 0.0 // No initial value or current value available in the test samples
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Commodity
        then (if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (
                        StandardizedScheduleCommodityForwardNotionalAmount(economicTerms
                    ) // Floating price forwards not supported
                    )
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (
                        StandardizedScheduleOptionNotionalAmount(economicTerms -> payout -> OptionPayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> FixedFloatSwap
            then (StandardizedScheduleCommoditySwapFixedFloatNotionalAmount(economicTerms))
            else if productClass = StandardizedScheduleProductClassEnum -> BasisSwap
            then 0.0 // No spot price available
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (
                        StandardizedScheduleCommoditySwapFixedFloatNotionalAmount(UnderlierForProduct(
                                product
                            ) -> Product ->> economicTerms
                    )) // CO Contract for Difference (CFD) not supported
            )

    post-condition PositiveNotional: <"Ensure notional is greater than 0">
        notional > 0

func StandardizedScheduleNotionalCurrency: <"Extracts the notional currency of a trade, according to the product class-depending extraction method defined in the ISDA industry survey.">
    inputs:
        trade Trade (1..1)
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        productClass StandardizedScheduleProductClassEnum (1..1)
    output:
        notionalCurrency string (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set notionalCurrency:
        if assetClass = StandardizedScheduleAssetClassEnum -> InterestRates
        then (if productClass = StandardizedScheduleProductClassEnum -> Swap
                    or productClass = StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
            then (economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> CrossCurrencySwap
            then (economicTerms -> payout -> InterestRatePayout
                filter (True /*how do we identify the receiver party?*/ )
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
                    or productClass = StandardizedScheduleProductClassEnum -> SwaptionStraddle
            then (UnderlierForProduct(product) -> Product ->> economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            // IR Exotic swap with an exotic coupon against a floating leg not supported
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> InterestRatePayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> ForwardRateAgreement
            then (economicTerms -> payout -> InterestRatePayout
                filter rateSpecification -> FixedRateSpecification exists
                then only-element
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ))
        else if assetClass = StandardizedScheduleAssetClassEnum -> Credit
        then (if productClass = StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
                    or productClass = StandardizedScheduleProductClassEnum -> IndexCDS
                    or productClass = StandardizedScheduleProductClassEnum -> IndexTranche
                    or productClass = StandardizedScheduleProductClassEnum -> CreditNthToDefault
            then (economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (UnderlierForProduct(product) -> Product ->> economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ) // Credit Total return swap on a bond not supported
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> ForeignExchange
        then (if productClass = StandardizedScheduleProductClassEnum -> DeliverableSwap
            then (StandardizedScheduleFXSwapNotional(
                        FXFarLeg(product),
                        trade -> tradeLot only-element
                    ) -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableCrossCurrencySwap
            then "AAA" // Recieve side notional and currency. What does that mean?
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (economicTerms -> payout -> PerformancePayout only-element -> returnTerms -> varianceReturnTerms -> varianceStrikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then "AAA" // Vega notional amount not mapped in the product
            else if productClass = StandardizedScheduleProductClassEnum -> CorrelationSwap
            then "AAA" // No sample trades
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Equity
        then (if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> OptionPayout only-element -> strike -> strikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> DividendSwap
            then "AAA" // All dividend swaps are defined with a monetary payment, no strike price or number of shares
                // EQ Deliverable Option F not supported
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (economicTerms -> payout -> PerformancePayout only-element -> returnTerms -> varianceReturnTerms -> volatilityStrikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then "AAA" // Is volatility amount = vega notional amount?
                // EQ Contract fo Difference (CFD) not supported
            else if productClass = StandardizedScheduleProductClassEnum -> SwapsAndPortfolioSwaps
            then "AAA" // No initial value or current value available in the test samples
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Commodity
        then (if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> unit -> currency // Floating price forwards not supported
                )
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> OptionPayout only-element -> strike -> strikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> FixedFloatSwap
            then (economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> BasisSwap
            then "AAA" // No spot price available
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (UnderlierForProduct(product) -> Product ->> economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> unit -> currency) // CO Contract for Difference (CFD) not supported
            )

    post-condition ValidCurrency: <"Ensure Currency is an ISO 3-Letter Currency Code ">
        notionalCurrency to-enum ISOCurrencyCodeEnum exists

func AuxiliarEffectiveDate: <"Extracts the effective date of specific products such as interest rate swaps and swaptions.">
    inputs:
        trade Trade (1..1)
    output:
        effectiveDate date (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set effectiveDate:
        // interestRatePayout
        if economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate exists
        then (economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate
            extract AdjustableDateResolution
            then min)
        // interestRateSwaptions
        else if economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate exists
        then (economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate
            extract AdjustableDateResolution
            then min)

func AuxiliarTerminationDate: <"Extracts the termination date of specific products such as interest rate swaps and swaptions.">
    inputs:
        trade Trade (1..1)
    output:
        terminationDate date (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set terminationDate:
        // interestRatePayout
        if economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate exists
        then (economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate
            extract AdjustableDateResolution
            then max)
        // interestRateSwaptions
        else if economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate exists
        then (economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate
            extract AdjustableDateResolution
            then max)

func StandardizedScheduleDuration: <"Extracts the duration of a trade, according to the product class-depending extraction method defined in the ISDA industry survey.">
    inputs:
        trade Trade (1..1)
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        productClass StandardizedScheduleProductClassEnum (1..1)
    output:
        durationInYears number (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    alias underlier: UnderlierForProduct(product)
    alias transactionEffectiveDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(economicTerms -> effectiveDate)
            )
    alias transactionTerminationDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(
                        economicTerms -> terminationDate
                    )
            )
    alias transactionTenorInYears:
        if transactionEffectiveDate exists and transactionTerminationDate exists
        then DateDifferenceYears(transactionEffectiveDate, transactionTerminationDate)
    alias underlyingTransactionEffectiveDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(
                        underlier -> Product ->> economicTerms -> effectiveDate
                    )
            )
    alias underlyingTransactionTerminationDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(
                        underlier -> Product ->> economicTerms -> terminationDate
                    )
            )
    alias underlyingTransactionTenorInYears:
        if underlyingTransactionEffectiveDate exists
                and underlyingTransactionTerminationDate exists
        then DateDifferenceYears(
                    underlyingTransactionEffectiveDate,
                    underlyingTransactionTerminationDate
                )
    alias optionExpiry:
        economicTerms -> payout -> OptionPayout only-element -> exerciseTerms
            then extract
                if style = OptionExerciseStyleEnum -> American
                then AdjustableOrAdjustedOrRelativeDateResolution(
                            ConvertToAdjustableOrAdjustedOrRelativeDate(
                                    expirationDate only-element
                                )
                        )
                else if style = OptionExerciseStyleEnum -> European
                then (expirationDate
                    max [
                        AdjustableOrAdjustedOrRelativeDateResolution(
                                ConvertToAdjustableOrAdjustedOrRelativeDate(item)
                            )
                    ]
                    extract
                        AdjustableOrAdjustedOrRelativeDateResolution(
                                ConvertToAdjustableOrAdjustedOrRelativeDate(item)
                            ))
                else if style = OptionExerciseStyleEnum -> Bermuda
                then (if exerciseDates -> adjustableDates exists
                    then AdjustableDatesResolution(exerciseDates -> adjustableDates)
                        max [ item ]
                        extract item)
    alias timeToOptionExpiryInYears:
        if transactionEffectiveDate exists and optionExpiry exists
        then DateDifferenceYears(transactionEffectiveDate, optionExpiry)
    alias genericDurationInYears:
        if (assetClass = StandardizedScheduleAssetClassEnum -> InterestRates or assetClass = StandardizedScheduleAssetClassEnum -> Credit)
        then (if productClass = StandardizedScheduleProductClassEnum -> Swap
                    or productClass = StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
                    or productClass = StandardizedScheduleProductClassEnum -> CrossCurrencySwap
                    or productClass = StandardizedScheduleProductClassEnum -> ForwardRateAgreement
                    or productClass = StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
                    or productClass = StandardizedScheduleProductClassEnum -> IndexCDS
                    or productClass = StandardizedScheduleProductClassEnum -> IndexTranche
                    or productClass = StandardizedScheduleProductClassEnum -> CreditNthToDefault
            then transactionTenorInYears
            else if (productClass = StandardizedScheduleProductClassEnum -> Swaption or productClass = StandardizedScheduleProductClassEnum -> SwaptionStraddle)
            then (if timeToOptionExpiryInYears exists
                        and underlyingTransactionTenorInYears exists
                then timeToOptionExpiryInYears + underlyingTransactionTenorInYears
                else if timeToOptionExpiryInYears exists
                then timeToOptionExpiryInYears
                else if underlyingTransactionTenorInYears exists
                then underlyingTransactionTenorInYears)
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then timeToOptionExpiryInYears // IR Exotic swap with an exotic coupon against a floating leg not supported
                // Credit Total return swap on a bond not supported
            )
    alias auxiliarDurationInYears:
        DateDifferenceYears(AuxiliarEffectiveDate(trade), AuxiliarTerminationDate(trade))
    set durationInYears:
        if genericDurationInYears exists
        then genericDurationInYears
        else auxiliarDurationInYears

    post-condition PositiveDuration: <"Ensure duration is greater than 0.">
        durationInYears > 0

func GetStandardizedScheduleMarginRate: <"Computes the margin rate, which is required in the calculation of the gross initial margin. It depends exclusively on the asset class of the trade and, in some cases, on the duration as well.">
    inputs:
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        durationInYears number (1..1)
    output:
        percentage number (1..1)
    set percentage:
        if assetClass = StandardizedScheduleAssetClassEnum -> InterestRates
        then (if durationInYears <= 2
            then 1.0
            else if durationInYears > 2 and durationInYears <= 5
            then 2.0
            else if durationInYears > 5
            then 4.0)
        else if assetClass = StandardizedScheduleAssetClassEnum -> Credit
        then (if durationInYears <= 2
            then 2.0
            else if durationInYears > 2 and durationInYears <= 5
            then 5.0
            else if durationInYears > 5
            then 10.0)
        else if assetClass = StandardizedScheduleAssetClassEnum -> ForeignExchange
        then 6.0
        else if assetClass = StandardizedScheduleAssetClassEnum -> Equity
        then 15.0
        else if assetClass = StandardizedScheduleAssetClassEnum -> Commodity
        then 15.0

//Potential move to other namespaces
func UnderlierForProduct: <"Extracts the underlier product.">
    inputs:
        product NonTransferableProduct (1..1)
    output:
        underlierProduct Underlier (1..1)
    set underlierProduct:
        if product -> economicTerms -> payout -> OptionPayout exists
        then product -> economicTerms -> payout -> OptionPayout only-element -> underlier
        else if product -> economicTerms -> payout -> SettlementPayout exists
        then product -> economicTerms -> payout -> SettlementPayout only-element -> underlier

//Potential move to other namespaces
func AdjustableOrAdjustedOrRelativeDateResolution: <"A fall back for unadjustedDate when adjustedDate is only available.">
    inputs:
        adjustableDate AdjustableOrAdjustedOrRelativeDate (1..1)
    output:
        date date (0..1)
    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

//Potential move to other namespaces
func AdjustableDateResolution: <"A fall back for unadjustedDate when adjustedDate is only available.">
    inputs:
        adjustableDate AdjustableDate (1..1)
    output:
        date date (0..1)

    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

//Potential move to other namespaces
func AdjustableDatesResolution: <"A fall back for unadjustedDate when adjustedDate is only available.">
    inputs:
        adjustableDates AdjustableDates (1..1)
    output:
        date date (0..*)

    add date:
        if adjustableDates -> unadjustedDate exists
        then adjustableDates -> unadjustedDate
        else adjustableDates -> adjustedDate

func StandardizedScheduleMonetaryNotionalFromResolvablePQ: <"Extracts the notional amount for all products that have it populated in the resolvable priceQuantity.">
    inputs:
        priceQuantity ResolvablePriceQuantity (0..1)
    output:
        notional number (0..1)

    set notional:
        if priceQuantity -> quantitySchedule exists
                and priceQuantity -> quantitySchedule -> unit -> currency exists
        then (if priceQuantity -> quantitySchedule -> multiplier exists
            then priceQuantity -> quantitySchedule -> value * priceQuantity -> quantitySchedule -> multiplier -> value
            else priceQuantity -> quantitySchedule -> value)

func StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ: <"Extracts the notional currency for all products that have it populated in the resolvable priceQuantity.">
    inputs:
        priceQuantity ResolvablePriceQuantity (0..1)
    output:
        notionalCurrency string (0..1)

    set notionalCurrency:
        if priceQuantity -> quantitySchedule exists
                and priceQuantity -> quantitySchedule -> unit -> currency exists
        then (if priceQuantity -> quantitySchedule -> multiplier exists
            then priceQuantity -> quantitySchedule -> multiplier -> unit -> currency
            else priceQuantity -> quantitySchedule -> unit -> currency)

//Potential move to other namespaces
func FXFarLeg: <"Extracts the far leg of an FX swap (deliverable or not) based on two criteria: the forward payout with the latest value date or the forward payout with the latest settlement date.">
    inputs:
        product NonTransferableProduct (1..1)
    output:
        nearLegPayout SettlementPayout (0..1)
    alias settlementPayout: product -> economicTerms -> payout -> SettlementPayout
    set nearLegPayout:
        // value date
        if (Qualify_ForeignExchange_Swap(product -> economicTerms) or Qualify_ForeignExchange_NDS(product -> economicTerms))
                and settlementPayout -> settlementTerms -> settlementDate -> valueDate exists
        then settlementPayout max [ item -> settlementTerms -> settlementDate -> valueDate ]
        // adjustable or relative date
        else if (Qualify_ForeignExchange_Swap(product -> economicTerms) or Qualify_ForeignExchange_NDS(product -> economicTerms))
                and settlementPayout -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then settlementPayout
            max [
                AdjustableOrAdjustedOrRelativeDateResolution(
                        item -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
                    )
            ]

func StandardizedScheduleFXSwapNotional: <"Extracts the notional amount and currency of an FX swap.">
    inputs:
        farLeg SettlementPayout (0..1)
        tradeLot TradeLot (0..1)
    output:
        quantity NonNegativeQuantitySchedule (0..1)
    alias priceQuantity:
        tradeLot -> priceQuantity
            filter (item -> price = farLeg -> priceQuantity -> priceSchedule)
            then only-element
    alias exchangedCurrencies: priceQuantity -> quantity
    alias extractedExchangedCurrency:
        if exchangedCurrencies -> unit -> currency any = "USD"
        then (exchangedCurrencies
            filter unit -> currency = "USD"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "EUR"
        then (exchangedCurrencies
            filter unit -> currency = "EUR"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "JPY"
        then (exchangedCurrencies
            filter unit -> currency = "JPY"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "GBP"
        then (exchangedCurrencies
            filter unit -> currency = "GBP"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "CHF"
        then (exchangedCurrencies
            filter unit -> currency = "CHF"
            then only-element)
        else (exchangedCurrencies
            sort [ item -> unit -> currency ]
            first)
    set quantity: extractedExchangedCurrency

// func StandardizedScheduleFXNDFNotional: <"Extracts the notional amount and currency of an FX non-deliverable forward.">
//     inputs: settlementPayout SettlementPayout (0..1)
//     output: quantity NonNegativeQuantitySchedule (0..1)
//     alias settlementCurrency:
//     forwardPayout -> settlementTerms -> settlementCurrency
//     alias exchangedCurrencies:
//     [
//         forwardPayout -> underlier -> foreignExchange -> exchangedCurrency1,
//         forwardPayout -> underlier -> foreignExchange -> exchangedCurrency2
//     ]
//     set quantity:
//     exchangedCurrencies filter priceQuantity -> quantitySchedule -> unit -> currency = settlementCurrency then only-element then priceQuantity -> quantitySchedule
// func StandardizedScheduleFXNDONotional: <"Extracts the notional amount and currency of an FX non-deliverable option.">
//     inputs: optionPayout OptionPayout (0..1)
//     output: quantity NonNegativeQuantitySchedule (0..1)
//     alias settlementCurrency:
//     optionPayout -> settlementTerms -> settlementCurrency
//     alias exchangedCurrencies:
//     [
//         optionPayout -> underlier -> foreignExchange -> exchangedCurrency1,
//         optionPayout -> underlier -> foreignExchange -> exchangedCurrency2
//     ]
//     set quantity:
//     exchangedCurrencies filter priceQuantity -> quantitySchedule -> unit -> currency = settlementCurrency then only-element then priceQuantity -> quantitySchedule
func StandardizedScheduleFXVarianceNotionalAmount: <"Extracts the notional amount of an FX variance swap.">
    inputs:
        performancePayout PerformancePayout (0..1)
    output:
        amount number (0..1)
    alias varianceReturnTerms: performancePayout -> returnTerms -> varianceReturnTerms
    alias vegaNotionalAmount: varianceReturnTerms -> vegaNotionalAmount
    alias fixedRate: varianceReturnTerms -> varianceStrikePrice
    set amount: (vegaNotionalAmount -> value) / (0.02 * (fixedRate -> value))

func StandardizedScheduleOptionNotionalAmount: <"Extracts the notional amount of a CO or EQ option.">
    inputs:
        optionPayout OptionPayout (0..1)
    output:
        amount number (0..1)
    alias strikePrice: optionPayout -> strike -> strikePrice -> value
    alias notionalQuantity:
        optionPayout -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: strikePrice * notionalQuantity

func StandardizedScheduleEquityForwardNotionalAmount: <"Extracts the notional amount of an EQ forward.">
    inputs:
        settlementPayout SettlementPayout (0..1)
    output:
        amount number (0..1)
    alias forwardPrice:
        settlementPayout -> priceQuantity -> priceSchedule only-element -> value
    alias notionalQuantity:
        settlementPayout -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: forwardPrice * notionalQuantity

func StandardizedScheduleVarianceSwapNotionalAmount: <"Extracts the notional amount of an EQ variance swap.">
    inputs:
        performancePayout PerformancePayout (0..1)
    output:
        amount number (0..1)
    alias varianceAmount:
        performancePayout -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
            then if item >= 1 then 0.01 * item else item
    alias volatilityStrikePrice:
        performancePayout -> returnTerms -> varianceReturnTerms -> volatilityStrikePrice -> value
    set amount: 200 * varianceAmount * volatilityStrikePrice

func StandardizedScheduleCommodityForwardNotionalAmount: <"Extracts the notional amount of a CO forward. Floating price forwards not supported.">
    inputs:
        economicTerms EconomicTerms (0..1)
    output:
        amount number (0..1)
    alias forwardPrice:
        economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> value
    alias notionalQuantity:
        economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: forwardPrice * notionalQuantity

func StandardizedScheduleCommoditySwapFixedFloatNotionalAmount: <"Extracts the notional amount of a CO fixed float swap.">
    inputs:
        economicTerms EconomicTerms (0..1)
    output:
        amount number (0..1)
    alias fixedPrice:
        economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> value
    alias notionalQuantity:
        economicTerms -> payout -> CommodityPayout only-element -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: fixedPrice * notionalQuantity

//Potential move to other namespaces
func DateDifferenceYears: <"Computes the difference in years between two dates. All years are supposed to have 365 days.">
    inputs:
        firstDate date (1..1) <"The earlier date.">
        secondDate date (1..1) <"The later date.">
    output:
        difference number (1..1)

    set difference: DateDifference(firstDate, secondDate) / 365.0

//Potential move to other namespaces
func IsCreditNthToDefault: <"Identifies a product as a CR basket Nth to default.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> basketReferenceInformation -> nthToDefault exists

//Potential move to other namespaces
func IsFXDeliverableOption: <"Identifies a product as an FX deliverable option.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        Qualify_ForeignExchange_VanillaOption(economicTerms)
            and economicTerms -> payout -> OptionPayout only-element -> settlementTerms -> settlementType = SettlementTypeEnum -> Physical

//Potential move to other namespaces
func IsFXNonDeliverableOption: <"Identifies a product as an FX non-deliverable option.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        Qualify_ForeignExchange_VanillaOption(economicTerms)
            and economicTerms -> payout -> OptionPayout only-element -> settlementTerms -> settlementType = SettlementTypeEnum -> Cash

//Potential move to other namespaces
func IsIRSwaptionStraddle: <"Identifies a product as an IR swaption straddle.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        Qualify_InterestRate_Option_Swaption(economicTerms)
            and economicTerms -> payout -> OptionPayout only-element -> optionType = OptionTypeEnum -> Straddle

//Potential move to other namespaces
func IsIRSwapWithCallableBermudanRightToEnterExitSwaps: <"Identifies a product as an IR swap with bermudan/callable right to enter/exit swaps.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        Qualify_BaseProduct_IRSwap(economicTerms)
            and economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseTerms -> style = OptionExerciseStyleEnum -> Bermuda

func GetNetInitialMarginFromExposure: <"Computes the net initial margin, taking the gross initial margin result and the mark to market value for each trade in the portfolio.">
    inputs:
        exposure Exposure (0..1)
    output:
        initialMargin StandardizedScheduleInitialMargin (0..1)
    alias tradePortfolio: exposure -> tradePortfolio
    alias positions: tradePortfolio -> positions
    alias tradeInitialMargin:
        positions
            extract
                StandardizedScheduleTradeInfo {
                    assetClass: BuildStandardizedSchedule(item -> tradeReference -> trade) -> assetClass,
                    productClass: BuildStandardizedSchedule(item -> tradeReference -> trade) -> productClass,
                    grossInitialMargin: GetGrossInitialMarginFromStandardizedSchedule(
                            BuildStandardizedSchedule(item -> tradeReference -> trade)
                        ),
                    markToMarketValue: item -> tradeReference -> valuationHistory
                        filter method = ValuationTypeEnum -> MarkToMarket
                        then only-element
                        then amount
                }
    alias totalGIM: tradeInitialMargin -> grossInitialMargin -> value sum
    alias netCurrentReplacementCost: tradeInitialMargin -> markToMarketValue -> value sum
    alias grossCurrentReplacementCost:
        tradeInitialMargin -> markToMarketValue
            filter item -> value > 0
            then value sum
    alias netToGrossRatio: netCurrentReplacementCost / grossCurrentReplacementCost
    add initialMargin -> tradeInfo: tradeInitialMargin
    set initialMargin -> netInitialMargin -> value:
        0.4 * totalGIM + 0.6 * totalGIM * netToGrossRatio
    set initialMargin -> netInitialMargin -> unit -> currency:
        tradeInitialMargin -> markToMarketValue -> unit -> currency distinct only-element

    post-condition NonNegativeNetInitialMargin: <"Ensure net initial margin is non-negative">
        initialMargin -> netInitialMargin -> value >= 0

    post-condition TotalGIMAddition: <"Ensure that only a single currency exists">
        tradeInitialMargin -> grossInitialMargin -> unit -> currency distinct count = 1

    post-condition NGRAddition: <"Ensure that only a single currency exists">
        tradeInitialMargin -> markToMarketValue -> unit -> currency distinct count = 1

func Create_ExposureFromTrades: <"Builds an Exposure structure from a collection of trades.">
    inputs:
        trades TradeState (0..*)
    output:
        exposure Exposure (0..1)

    add exposure -> tradePortfolio -> positions:
        trades
            extract
                Position {
                    cashBalance: empty,
                    priceQuantity: item -> trade -> tradeLot -> priceQuantity,
                    tradeReference: empty,
                    product: Product {
                        NonTransferableProduct: item -> trade -> product,
                        ...
        }}

    set exposure -> tradePortfolio -> lineage -> tradeReference: trades -> trade first

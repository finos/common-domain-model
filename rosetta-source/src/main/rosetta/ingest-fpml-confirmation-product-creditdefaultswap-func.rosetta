namespace cdm.ingest.fpml.confirmation.product.creditdefaultswap: <"FpML CreditDefaultSwap product mapping functions.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.asset.credit.*
import cdm.base.staticdata.party.*
import cdm.ingest.fpml.confirmation.common.*
import cdm.ingest.fpml.confirmation.datetime.*
import cdm.ingest.fpml.confirmation.other.*
import cdm.ingest.fpml.confirmation.party.*
import cdm.ingest.fpml.confirmation.pricequantity.*
import cdm.ingest.fpml.confirmation.product.swap.*
import cdm.ingest.fpml.confirmation.settlement.*
import cdm.observable.asset.*
import cdm.observable.event.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.template.*

import fpml.confirmation.* as fpml
import fpml.confirmation.custom.*

func MapCreditDefaultSwapCounterpartyList:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
    output:
        counterpartyList Counterparty (0..2)

    alias buyerSellerModel: fpmlCreditDefaultSwap -> generalTerms -> buyerSellerModel

    add counterpartyList:
        MapCounterparty(
                CounterpartyRoleEnum -> Party1,
                buyerSellerModel -> sellerPartyReference
            )

    add counterpartyList:
        MapCounterparty(
                CounterpartyRoleEnum -> Party2,
                buyerSellerModel -> buyerPartyReference
            )

func MapCreditDefaultSwapAncillaryPartyList:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
    output:
        ancillaryPartyList AncillaryParty (0..*)

func MapCreditDefaultSwapNonTransferableProduct:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
        fpmlTradeHeader fpml.TradeHeader (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        nonTransferableProduct NonTransferableProduct (0..1)

    set nonTransferableProduct:
        NonTransferableProduct {
            identifier: MapProductIdentifierList(fpmlCreditDefaultSwap -> productModel),
            taxonomy: MapProductTaxonomyList(fpmlCreditDefaultSwap -> productModel),
            economicTerms: MapCreditDefaultSwapEconomicTerms(
                        fpmlCreditDefaultSwap,
                        fpmlTradeHeader,
                        cdmCounterpartyList
                    )
        }

func MapCreditDefaultSwapEconomicTerms:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
        fpmlTradeHeader fpml.TradeHeader (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        economicTerms EconomicTerms (0..1)

    alias nonStandardisedTerms:
        if fpmlTradeHeader -> partyTradeInformation -> nonStandardTerms exists
        then if fpmlTradeHeader -> partyTradeInformation -> nonStandardTerms any = True
            then True
            else False

    set economicTerms:
        EconomicTerms {
            effectiveDate: MapAdjustableDate2ToAdjustableOrRelativeDate(
                        fpmlCreditDefaultSwap -> generalTerms -> effectiveDate
                    ),
            terminationDate: MapAdjustableDate2ToAdjustableOrRelativeDate(
                        fpmlCreditDefaultSwap -> generalTerms -> scheduledTerminationDate
                    ),
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlCreditDefaultSwap -> generalTerms -> dateAdjustments
                    ),
            payout: MapCreditDefaultSwapPayoutList(
                        fpmlCreditDefaultSwap,
                        cdmCounterpartyList
                    ),
            nonStandardisedTerms: nonStandardisedTerms,
            ...
        }

func MapCreditDefaultSwapPayoutList:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payouts Payout (0..*)

    alias generalTermsPayerReceiver:
        MapSellerAsPayerAndBuyerAsReceiver(
                fpmlCreditDefaultSwap -> generalTerms -> buyerSellerModel,
                cdmCounterpartyList
            )
    add payouts:
        MapCreditDefaultSwapPayout(
                fpmlCreditDefaultSwap,
                generalTermsPayerReceiver,
                cdmCounterpartyList
            )

    add payouts:
        if fpmlCreditDefaultSwap -> feeLeg -> periodicPayment exists
        then MapFeeLegToInterestRateLegPayout(
                    fpmlCreditDefaultSwap -> feeLeg,
                    fpmlCreditDefaultSwap -> protectionTerms,
                    generalTermsPayerReceiver,
                    cdmCounterpartyList
                )

func MapCreditDefaultSwapPayout:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
        cdmGeneralTermsPayerReceiver PayerReceiver (1..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payout Payout (0..1)

    alias currency:
        fpmlCreditDefaultSwap -> protectionTerms -> calculationAmount -> currency first

    set payout:
        Payout {
            CreditDefaultPayout:
                CreditDefaultPayout {
                    payerReceiver: cdmGeneralTermsPayerReceiver,
                    generalTerms:
                        GeneralTerms {
                            referenceInformation: MapReferenceInformation(
                                        fpmlCreditDefaultSwap -> generalTerms -> referenceInformation,
                                        currency
                                    ),
                            indexReferenceInformation: MapCreditIndex(
                                        fpmlCreditDefaultSwap -> generalTerms -> indexReferenceInformation
                                    ),
                            basketReferenceInformation: MapBasketReferenceInformation(
                                        fpmlCreditDefaultSwap -> generalTerms -> basketReferenceInformation
                                    ),
                            ...
                        },
                    priceQuantity:
                        ResolvablePriceQuantity {
                            quantitySchedule: MapNotionalAmountToQuantityWithAddress(
                                        fpmlCreditDefaultSwap -> protectionTerms -> calculationAmount -> amount first,
                                        empty
                                    ),
                            ...
                        },
                    settlementTerms: MapCreditDefaultSwapChoiceToSettlementTerms(
                                fpmlCreditDefaultSwap -> creditDefaultSwapChoice
                            ),
                    protectionTerms: fpmlCreditDefaultSwap -> protectionTerms
                            extract MapProtectionTerms(item, cdmCounterpartyList),
                    transactedPrice:
                        TransactedPrice {
                            marketFixedRate: fpmlCreditDefaultSwap -> feeLeg -> marketFixedRate,
                            ...
                        },
                    ...
                },
            ...
        }

func MapReferenceInformation:
    inputs:
        fpmlReferenceInformation fpml.ReferenceInformation (0..1)
        fpmlCurrency fpml.Currency (0..1)
    output:
        referenceInformation ReferenceInformation (0..1)

    set referenceInformation:
        ReferenceInformation {
            referenceEntity: MapLegalEntity(fpmlReferenceInformation -> referenceEntity),
            referenceObligation: fpmlReferenceInformation -> referenceObligation
                    extract MapReferenceObligation,
            referencePrice: MapReferencePrice(
                        fpmlReferenceInformation -> referencePrice,
                        fpmlCurrency
                    ),
            ...
        }

func MapReferenceObligation:
    inputs:
        fpmlReferenceObligation fpml.ReferenceObligation (0..1)
    output:
        referenceObligation ReferenceObligation (0..1)

    alias debtAsset:
        if fpmlReferenceObligation -> bond exists
        then fpmlReferenceObligation -> bond
        else if fpmlReferenceObligation -> convertibleBond exists
        then fpmlReferenceObligation -> convertibleBond
        else if fpmlReferenceObligation -> loan exists
        then fpmlReferenceObligation -> loan
        else if fpmlReferenceObligation -> mortgage exists
        then fpmlReferenceObligation -> mortgage

    set referenceObligation:
        ReferenceObligation {
            security: if debtAsset exists
                    then MapIdentifiedAssetToSecurity(debtAsset, empty, empty, Debt),
            primaryObligorReference: MapLegalEntityReference(
                        fpmlReferenceObligation -> primaryObligorReference
                    ),
            ...
        }

func MapCreditIndex:
    inputs:
        fpmlIndexReferenceInformation fpml.IndexReferenceInformation (0..1)
    output:
        creditIndex CreditIndex (0..1)

    alias indexName:
        fpmlIndexReferenceInformation -> indexReferenceInformationSequence0 -> indexName

    alias indexId:
        fpmlIndexReferenceInformation -> indexReferenceInformationSequence0 -> indexId default fpmlIndexReferenceInformation -> indexReferenceInformationSequence1 -> indexId

    set creditIndex:
        if fpmlIndexReferenceInformation exists
        then CreditIndex {
                identifier: indexId extract MapIndexIdToAssetIdentifier,
                name: MapStringWithScheme(indexName -> value, indexName -> indexNameScheme),
                provider: empty,
                assetClass: Credit,
                indexSeries: fpmlIndexReferenceInformation -> indexSeries,
                indexAnnexVersion: fpmlIndexReferenceInformation -> indexAnnexVersion,
                indexAnnexDate: fpmlIndexReferenceInformation -> indexAnnexDate -> date,
                indexAnnexSource: fpmlIndexReferenceInformation -> indexAnnexSource -> value to-enum IndexAnnexSourceEnum,
                excludedReferenceEntity: fpmlIndexReferenceInformation -> excludedReferenceEntity
                        extract
                            ReferenceInformation {
                                referenceEntity: MapLegalEntity,
                                ...
                            },
                tranche: MapTranche(fpmlIndexReferenceInformation -> tranche),
                settledEntityMatrix: MapSettledEntityMatrix(
                            fpmlIndexReferenceInformation -> settledEntityMatrix
                        ),
                indexFactor: fpmlIndexReferenceInformation -> indexReferenceInformationSequence2 -> indexFactor,
                seniority: fpmlIndexReferenceInformation -> indexReferenceInformationSequence2 -> seniority -> value to-enum CreditSeniorityEnum,
                ...
            }

// set creditIndex -> indexAnnexSource -> scheme:
// fpmlIndexReferenceInformation -> indexAnnexSource -> indexAnnexSourceScheme
func MapSettledEntityMatrix:
    inputs:
        fpmlSettledEntityMatrix fpml.SettledEntityMatrix (0..1)
    output:
        settledEntityMatrix SettledEntityMatrix (0..1)

    set settledEntityMatrix:
        SettledEntityMatrix {
            matrixSource: fpmlSettledEntityMatrix -> matrixSource -> value to-enum SettledEntityMatrixSourceEnum,
            publicationDate: fpmlSettledEntityMatrix -> publicationDate -> date
        }
    set settledEntityMatrix -> matrixSource -> scheme:
        fpmlSettledEntityMatrix -> matrixSource -> settledEntityMatrixSourceScheme

func MapBasketReferenceInformation:
    inputs:
        fpmlBasketReferenceInformation fpml.BasketReferenceInformation (0..1)
    output:
        basketReferenceInformation BasketReferenceInformation (0..1)

    alias basketName:
        fpmlBasketReferenceInformation -> basketIdentifierModel -> basketIdentifierModelSequence -> basketName

    alias basketId:
        fpmlBasketReferenceInformation -> basketIdentifierModel -> basketIdentifierModelSequence -> basketId

    set basketReferenceInformation:
        if fpmlBasketReferenceInformation exists
        then BasketReferenceInformation {
                basketName: MapStringWithScheme(
                            basketName -> value,
                            basketName -> basketNameScheme
                        ),
                basketId: basketId extract MapStringWithScheme(value, basketIdScheme),
                referencePool:
                    ReferencePool {
                        referencePoolItem: fpmlBasketReferenceInformation -> referencePool -> referencePoolItem
                                extract MapReferencePoolItem
                    },
                nthToDefault: fpmlBasketReferenceInformation -> basketReferenceInformationSequence -> nthToDefault,
                mthToDefault: fpmlBasketReferenceInformation -> basketReferenceInformationSequence -> mthToDefault,
                tranche: MapTranche(fpmlBasketReferenceInformation -> tranche),
            }

func MapReferencePoolItem:
    inputs:
        fpmlReferencePoolItem fpml.ReferencePoolItem (0..1)
    output:
        referencePoolItem ReferencePoolItem (0..1)

    set referencePoolItem:
        ReferencePoolItem {
            constituentWeight: MapConstituentWeight(
                        fpmlReferencePoolItem -> constituentWeight
                    ),
            referencePair: MapReferencePair(fpmlReferencePoolItem -> referencePair),
            ...
        }
    set referencePoolItem -> protectionTermsReference -> reference:
        fpmlReferencePoolItem -> protectionTermsReference -> href
    set referencePoolItem -> cashSettlementTermsReference -> reference:
        fpmlReferencePoolItem -> settlementTermsReference -> href
    set referencePoolItem -> physicalSettlementTermsReference -> reference:
        fpmlReferencePoolItem -> settlementTermsReference -> href

func MapConstituentWeight:
    inputs:
        fpmlConstituentWeight fpml.ConstituentWeight (0..1)
    output:
        constituentWeight ConstituentWeight (0..1)

    set constituentWeight:
        ConstituentWeight {
            openUnits: fpmlConstituentWeight -> openUnits,
            basketPercentage: fpmlConstituentWeight -> basketPercentage
        }

func MapReferencePair:
    inputs:
        fpmlReferencePair fpml.ReferencePair (0..1)
    output:
        referencePair ReferencePair (0..1)

    set referencePair:
        ReferencePair {
            referenceEntity: MapLegalEntity(fpmlReferencePair -> referenceEntity),
            referenceObligation: MapReferenceObligation(
                        fpmlReferencePair -> referenceObligation
                    ),
            noReferenceObligation: fpmlReferencePair -> noReferenceObligation,
            entityType: fpmlReferencePair -> entityType -> value to-enum EntityTypeEnum
        }
    set referencePair -> entityType -> scheme:
        fpmlReferencePair -> entityType -> entityTypeScheme

func MapTranche:
    inputs:
        fpmlTranche fpml.Tranche (0..1)
    output:
        tranche Tranche (0..1)

    set tranche:
        Tranche {
            attachmentPoint: fpmlTranche -> attachmentPoint,
            exhaustionPoint: fpmlTranche -> exhaustionPoint,
            incurredRecoveryApplicable: fpmlTranche -> incurredRecoveryApplicable
        }

func MapProtectionTerms:
    inputs:
        fpmlProtectionTerms fpml.ProtectionTerms (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        protectionTerms ProtectionTerms (0..1)

    alias creditEvents: fpmlProtectionTerms -> creditEvents

    set protectionTerms:
        ProtectionTerms {
            creditEvents:
                CreditEvents {
                    bankruptcy: creditEvents -> bankruptcy,
                    failureToPay:
                        FailureToPay {
                            applicable: creditEvents -> failureToPay -> applicable,
                            gracePeriodExtension: empty,
                            paymentRequirement: MapMoney(
                                        creditEvents -> failureToPay -> paymentRequirement
                                    )
                        },
                    restructuring:
                        Restructuring {
                            applicable: creditEvents -> restructuring -> applicable,
                            restructuringType: MapRestructuringEnum(
                                        creditEvents -> restructuring -> restructuringType -> value
                                    ),
                            ...
                        },
                    defaultRequirement: MapMoney(creditEvents -> defaultRequirement),
                    creditEventNotice: MapCreditEventNotice(
                                creditEvents -> creditEventNotice,
                                cdmCounterpartyList
                            ),
                    ...
                },
            obligations:
                Obligations {
                    category: MapObligationCategoryEnum(
                                fpmlProtectionTerms -> obligations -> category to-string
                            ),
                    notSubordinated: fpmlProtectionTerms -> obligations -> notSubordinated,
                    ...
                },
            ...
        }

func MapCreditEventNotice:
    inputs:
        fpmlCreditEventNotice fpml.CreditEventNoticeType (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        creditEventNotice CreditEventNotice (0..1)

    set creditEventNotice:
        CreditEventNotice {
            notifyingParty: MapNotifyingPartyList(
                        fpmlCreditEventNotice -> notifyingParty,
                        cdmCounterpartyList
                    ),
            businessCenter: MapBusinessCenter(fpmlCreditEventNotice -> businessCenter),
            publiclyAvailableInformation:
                PubliclyAvailableInformation {
                    standardPublicSources: fpmlCreditEventNotice -> publiclyAvailableInformation -> standardPublicSources,
                    specifiedNumber: fpmlCreditEventNotice -> publiclyAvailableInformation -> specifiedNumber,
                    ...
        }}

func MapNotifyingPartyList:
    inputs:
        fpmlNotifyingParty fpml.NotifyingParty (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        notifyingPartyList CounterpartyRoleEnum (0..2)

    add notifyingPartyList:
        MapCounterpartyRoleEnum(
                fpmlNotifyingParty -> buyerPartyReference -> href,
                cdmCounterpartyList
            )

    add notifyingPartyList:
        MapCounterpartyRoleEnum(
                fpmlNotifyingParty -> sellerPartyReference -> href,
                cdmCounterpartyList
            )

func MapFeeLegToInterestRateLegPayout:
    inputs:
        fpmlFeeLeg fpml.FeeLeg (0..1)
        fpmlProtectionTerms fpml.ProtectionTerms (0..*)
        cdmGeneralTermsPayerReceiver PayerReceiver (1..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payout Payout (0..1)

    alias fixedAmountCalculation: fpmlFeeLeg -> periodicPayment -> fixedAmountCalculation
    alias floatingAmountCalculation:
        fpmlFeeLeg -> periodicPayment -> floatingAmountCalculation

    alias rateChoice:
        ToRateChoice(
                fpmlFeeLeg -> periodicPayment -> floatingAmountCalculation -> floatingRate
            )

    set payout:
        Payout {
            InterestRatePayout:
                InterestRatePayout {
                    payerReceiver: FlipPayerAndReceiver(cdmGeneralTermsPayerReceiver),
                    priceQuantity:
                        ResolvablePriceQuantity {
                            quantitySchedule: if fixedAmountCalculation -> calculationAmount exists
                                        or floatingAmountCalculation -> calculationAmount exists
                                    then MapFixedOrFloatingCalculationAmountToQuantityListWithAddress(
                                            fixedAmountCalculation -> calculationAmount,
                                            floatingAmountCalculation -> calculationAmount,
                                            fpmlFeeLeg
                                        )
                                else MapNotionalAmountToQuantityWithAddress(
                                        fpmlProtectionTerms -> calculationAmount -> amount first,
                                        empty
                                    ),
                            ...
                        },
                    rateSpecification:
                        RateSpecification {
                            FixedRateSpecification:
                                FixedRateSpecification {
                                    rateSchedule:
                                        RateSchedule {
                                            price: if fixedAmountCalculation -> fixedRate exists
                                                    then MapFixedRateToPriceScheduleWithAddress(
                                                            fixedAmountCalculation -> fixedRate -> value,
                                                            fpmlFeeLeg
                                                        )
                            }},
                            FloatingRateSpecification: if rateChoice -> FloatingRateCalculation exists
                                    then MapFloatingRateSpecification(
                                            rateChoice -> FloatingRateCalculation,
                                            fpmlFeeLeg
                                        ),
                            InflationRateSpecification: if rateChoice -> InflationRateCalculation exists
                                    then MapInflationRateSpecification(
                                            rateChoice -> InflationRateCalculation,
                                            fpmlFeeLeg
                                        )
                        },
                    dayCountFraction: MapDayCountFractionEnum(
                                fixedAmountCalculation -> dayCountFraction -> value
                            ),
                    calculationPeriodDates:
                        CalculationPeriodDates {
                            firstPeriodStartDate: MapUnadjustedDateToAdjustableOrRelativeDate(
                                        fpmlFeeLeg -> periodicPayment -> firstPeriodStartDate -> date,
                                        empty
                                    ),
                            calculationPeriodFrequency: MapPeriodicPaymentToCalculationPeriodFrequency(
                                        fpmlFeeLeg -> periodicPayment
                                    ),
                            ...
                        },
                    paymentDates: MapPeriodicPaymentToPaymentDates(
                                fpmlFeeLeg -> periodicPayment
                            ),
                    resetDates:
                        ResetDates {
                            initialFixingDate:
                                InitialFixingDate {
                                    initialFixingDate: floatingAmountCalculation -> initialFixingDate -> date,
                                    ...
                                },
                            finalFixingDate: MapAdjustableDate(
                                        floatingAmountCalculation -> finalFixingDate
                                    ),
                            ...
                        },
                    ...
                },
            ...
        }

func MapReferencePrice:
    inputs:
        fpmlReferencePrice number (0..1)
        fpmlCurrency fpml.Currency (0..1)
    output:
        price Price (0..1)

    alias priceUnits:
        UnitType {
            currency: MapCurrency(fpmlCurrency),
            ...
        }

    set price:
        if fpmlReferencePrice exists
        then Price {
                value: fpmlReferencePrice,
                unit: priceUnits,
                perUnitOf: priceUnits,
                priceType: AssetPrice,
                ...
            }

func MapCreditDefaultSwapPriceQuantityList:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
    output:
        priceQuantityList PriceQuantity (0..*)

    add priceQuantityList:
        MapFeeLegToPriceQuantity(
                fpmlCreditDefaultSwap -> feeLeg,
                fpmlCreditDefaultSwap -> protectionTerms
            )

    add priceQuantityList:
        MapProtectionTermsToPriceQuantity(fpmlCreditDefaultSwap -> protectionTerms)

func MapFeeLegToPriceQuantity:
    inputs:
        fpmlFeeLeg fpml.FeeLeg (0..1)
        fpmlProtectionTerms fpml.ProtectionTerms (0..*)
    output:
        priceQuantity PriceQuantity (0..1)

    set priceQuantity:
        PriceQuantity {
            price: MapFixedOrFloatingAmountCalculationToPriceListWithLocation(
                        fpmlFeeLeg -> periodicPayment -> fixedAmountCalculation,
                        fpmlFeeLeg -> periodicPayment -> floatingAmountCalculation,
                        fpmlProtectionTerms -> calculationAmount -> currency first,
                        fpmlFeeLeg
                    ),
            quantity: MapFixedOrFloatingCalculationAmountToQuantityListWithLocation(
                        fpmlFeeLeg -> periodicPayment -> fixedAmountCalculation -> calculationAmount,
                        fpmlFeeLeg -> periodicPayment -> floatingAmountCalculation -> calculationAmount,
                        fpmlFeeLeg
                    ),
            observable: MapRateOptionToObservableWithLocation(
                        fpmlFeeLeg -> periodicPayment -> floatingAmountCalculation -> floatingRate,
                        fpmlFeeLeg
                    ),
            ...
        }

func MapFixedOrFloatingAmountCalculationToPriceListWithLocation:
    inputs:
        fpmlFixedAmountCalculation fpml.FixedAmountCalculation (0..1)
        fpmlFloatingAmountCalculation fpml.FloatingAmountCalculation (0..1)
        fpmlCurrency fpml.Currency (0..1)
        fpmlLeg fpml.Leg (0..1)
    output:
        priceScheduleList PriceSchedule (0..*)
            [metadata location]

    add priceScheduleList:
        if fpmlFixedAmountCalculation -> fixedRate exists
        then MapFixedRateToPriceScheduleWithLocation(
                    fpmlFixedAmountCalculation -> fixedRate -> value,
                    empty,
                    fpmlCurrency,
                    fpmlLeg
                )
        else if fpmlFloatingAmountCalculation -> floatingRate exists
        then MapSpreadScheduleToPriceWithLocation(
                    fpmlFloatingAmountCalculation -> floatingRate,
                    fpmlCurrency,
                    fpmlLeg
                )

func MapProtectionTermsToPriceQuantity:
    inputs:
        fpmlProtectionTerms fpml.ProtectionTerms (0..*)
    output:
        priceQuantity PriceQuantity (0..1)

    set priceQuantity:
        PriceQuantity {
            quantity: fpmlProtectionTerms
                    extract
                        MapNotionalAmountToQuantityWithLocation(
                                calculationAmount -> amount,
                                empty,
                                calculationAmount -> currency,
                                empty
                            ),
            ...
        }

func MapCreditDefaultSwapAccountPartyReference:
    inputs:
        fpmlCreditDefaultSwap fpml.CreditDefaultSwap (0..1)
        fpmlAccount fpml.Account (0..1)
    output:
        partyReference Party (0..1)
            [metadata reference]

    set partyReference:
        MapBuyerSellerToAccountPartyReference(
                fpmlAccount,
                fpmlCreditDefaultSwap -> generalTerms -> buyerSellerModel
            )

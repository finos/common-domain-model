namespace cdm.ingest.fpml.confirmation.product.swaption: <"FpML Swaption product mapping functions.">
version "${project.version}"

import cdm.base.staticdata.party.*
import cdm.ingest.fpml.confirmation.common.*
import cdm.ingest.fpml.confirmation.party.*
import cdm.ingest.fpml.confirmation.product.swap.*
import cdm.ingest.fpml.confirmation.settlement.*
import cdm.observable.asset.*
import cdm.product.common.settlement.*
import cdm.product.template.*

import fpml.confirmation.* as fpml

func MapSwaptionCounterpartyList:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
    output:
        counterpartyList Counterparty (0..2)

    add counterpartyList:
        MapBuyerSellerModelToCounterpartyList(fpmlSwaption -> buyerSellerModel)

func MapSwaptionAncillaryPartyList:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
    output:
        ancillaryPartyList AncillaryParty (0..*)

func MapSwaptionNonTransferableProduct:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        nonTransferableProduct NonTransferableProduct (0..1)

    set nonTransferableProduct:
        NonTransferableProduct {
            identifier: MapProductIdentifierList(fpmlSwaption -> productModel),
            taxonomy: MapProductTaxonomyList(fpmlSwaption -> productModel),
            economicTerms: MapSwaptionEconomicTerms(fpmlSwaption, cdmCounterpartyList)
        }

func MapSwaptionEconomicTerms:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        economicTerms EconomicTerms (0..1)

    set economicTerms:
        EconomicTerms {
            payout: MapSwaptionPayout(fpmlSwaption, cdmCounterpartyList),
            terminationProvision: MapTerminationProvision(
                        fpmlSwaption -> earlyTerminationProvision,
                        empty,
                        empty,
                        cdmCounterpartyList
                    ),
            ...
        }

func MapSwaptionPayout:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payout Payout (0..1)

    set payout:
        Payout {
            OptionPayout:
                OptionPayout {
                    payerReceiver: MapSellerAsPayerAndBuyerAsReceiver(
                                fpmlSwaption -> buyerSellerModel,
                                cdmCounterpartyList
                            ),
                    settlementTerms: if fpmlSwaption -> cashSettlement exists
                            then MapCashSettlementToSettlementTerms(
                                    fpmlSwaption -> cashSettlement
                                )
                        else MapSwaptionPhysicalSettlementToSettlementTerms(
                                fpmlSwaption -> physicalSettlement
                            ),
                    buyerSeller: MapBuyerSeller(
                                fpmlSwaption -> buyerSellerModel,
                                cdmCounterpartyList
                            ),
                    underlier:
                        Underlier {
                            Product:
                                Product {
                                    NonTransferableProduct: MapSwapNonTransferableProduct(
                                                fpmlSwaption -> swap,
                                                cdmCounterpartyList
                                            ),
                                    ...
                                },
                            ...
                        },
                    optionType: if fpmlSwaption -> swaptionStraddle = True
                            then Straddle,
                    exerciseTerms: MapExerciseTerms(
                                fpmlSwaption -> exercise,
                                fpmlSwaption -> exerciseProcedure,
                                empty,
                                fpmlSwaption -> buyerSellerModel,
                                cdmCounterpartyList
                            ),
                    ...
                },
            ...
        }

func MapSwaptionPhysicalSettlementToSettlementTerms:
    inputs:
        fpmlSwaptionPhysicalSettlement fpml.SwaptionPhysicalSettlement (0..1)
    output:
        settlementTerms SettlementTerms (0..1)

    set settlementTerms:
        if fpmlSwaptionPhysicalSettlement exists
        then SettlementTerms {
                settlementType: Physical,
                physicalSettlementTerms:
                    PhysicalSettlementTerms {
                        clearedPhysicalSettlement: fpmlSwaptionPhysicalSettlement -> clearedPhysicalSettlement,
                        ...
                    },
                ...
            }

func MapSwaptionPriceQuantityList:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
    output:
        priceQuantityList PriceQuantity (0..*)

    add priceQuantityList: MapSwapPriceQuantityList(fpmlSwaption -> swap)

func MapSwaptionAccountPartyReference:
    inputs:
        fpmlSwaption fpml.Swaption (0..1)
        fpmlAccount fpml.Account (0..1)
    output:
        partyReference Party (0..1)
            [metadata reference]

    set partyReference:
        MapBuyerSellerToAccountPartyReference(fpmlAccount, fpmlSwaption -> buyerSellerModel)

namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.*
import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*

import cdm.observable.event.*
import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.event.common.*

import cdm.product.asset.*
import cdm.product.common.*
import cdm.product.common.settlement.*
import cdm.product.common.schedule.*
import cdm.product.qualification.*
import cdm.product.collateral.*

import cdm.mapping.config.*

type ContractualProduct extends ProductBase: <" A class to specify the contractual products' economic terms, alongside their product identification and product taxonomy. The contractual product class is meant to be used across the pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
	[metadata key]
	[metadata template]

	economicTerms EconomicTerms (1..1) <"The economic terms associated with a contractual product, i.e. the set of features that are price-forming.">

	condition PrimaryAssetClass: <"Specifies that when nonStandardisedTerms are True that a primary asset class must be specified.">
	 	if economicTerms -> nonStandardisedTerms = True then
	 		productTaxonomy -> primaryAssetClass exists

type EconomicTerms: <" This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, the effective and termination date and the date adjustment provisions when applying uniformily across the payout components. This class also includes the legal provisions which have valuation implications: cancelable provision, extendible provision, early termination provision and extraordinary events specification.">

	effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
		[docReference ICMA GMRA namingConvention "Purchase Date"
			provision "As defined in GMRA paragraph 2(mm) The date on which Purchased Securities are sold or are to be sold by Seller to Buyer."]
		[docReference ICMA ERCCBestPractice namingConvention "Purchase Date"
			provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the value date of a repo."]
	terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
		[docReference ICMA GMRA namingConvention "Repurchase Date"
			provision "As defined in GMRA paragraph 2(qq) The date on which Buyer is to sell Equivalent Securities to Seller."]
		[docReference ICMA ERCCBestPractice namingConvention "Repurchase Date"
			provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the maturity date of a repo."]
	dateAdjustments BusinessDayAdjustments (0..1) <"The business day adjustment convention when it applies across all the payout components. This specification of the business day convention and financial business centers is used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
	payout Payout (1..1) <"The payout specifies the future cashflow computation methodology which characterizes a financial product.">
	terminationProvision TerminationProvision (0..1) <"Contains optional provisions pertaining to the termination characteristics of a contract.">
	extraordinaryEvents ExtraordinaryEvents (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Extraordinary Events.">
	calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
	nonStandardisedTerms boolean (0..1) <"Specifies, when boolean value is True, that additional economic terms exist that have not been included in the product representation.">
	//ICMA-P2
	collateral Collateral (0..1) <"Represents the collateral obligations of a party.">

	condition ExtraordinaryEvents: <"Extraordinary events provisions must be associated with an equity payout.">
		if extraordinaryEvents exists then
		    payout -> performancePayout -> returnTerms -> priceReturnTerms exists // and performancePayout underlier must be security
            or payout -> optionPayout -> underlier -> security exists

	condition FpML_cd_26_28: <"FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate. This data rule tackles those two FpML validation rules at once, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute.">
		if payout -> creditDefaultPayout exists
			and payout -> cashflow exists
			and effectiveDate exists
			and payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate exists
			and payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate is absent
		then payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate all > effectiveDate -> adjustableDate -> unadjustedDate
			or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> adjustedDate all > effectiveDate -> adjustableDate -> adjustedDate
			or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate -> adjustedDate all > effectiveDate -> relativeDate -> adjustedDate

	condition FpML_cd_27: <"FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
		if payout -> creditDefaultPayout exists
			and payout -> cashflow exists
			and terminationDate exists
			and payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
		then payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate all < terminationDate -> adjustableDate -> unadjustedDate
			or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> adjustedDate all < terminationDate -> adjustableDate -> adjustedDate
			or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate -> adjustedDate all < terminationDate -> adjustableDate -> adjustedDate

	condition FpML_cd_30: <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
		if payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate exists and terminationDate exists
		then payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> unadjustedDate

	condition IndependentCalculationAgent:
		if calculationAgent -> calculationAgentParty exists
		then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentIndependent

    condition AssetPayoutDividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then it should be a Term trade.">
        if payout -> assetPayout -> dividendTerms exists
        then terminationDate exists

	condition ExtendibleProvisionExerciseDetails: <"Ensure that the correct details are specified for an extendible contract.">
		if payout -> assetPayout is absent then
			// Not Security Lending/Repo so must be Interest Rate Swap, which must set an exercise option type
			if terminationProvision -> extendibleProvision exists then
				(terminationProvision -> extendibleProvision -> americanExercise exists
				and	terminationProvision -> extendibleProvision -> bermudaExercise is absent
				and terminationProvision -> extendibleProvision -> europeanExercise is absent)
				or
				(terminationProvision -> extendibleProvision -> americanExercise is absent
				and	terminationProvision -> extendibleProvision -> bermudaExercise exists
				and terminationProvision -> extendibleProvision -> europeanExercise is absent)
				or
				(terminationProvision -> extendibleProvision -> americanExercise is absent
				and	terminationProvision -> extendibleProvision -> bermudaExercise is absent
				and terminationProvision -> extendibleProvision -> europeanExercise exists)
				and
				terminationProvision -> extendibleProvision -> followUpConfirmation exists

type OptionExercise: <" A class to represent the applicable terms to qualify an option exercise: the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">

	optionStyle OptionStyle (1..1) <"The option exercise can be of American style, Bermuda style or European style. The FpML implementation makes use of a substitution group.">
	strike OptionStrike (0..1) <"Specifies the strike of the option on credit default swap.">
	exerciseProcedure ExerciseProcedure (0..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">

type OptionPayout extends PayoutBase: <" The option payout specification terms. The associated globalKey denotes the ability to associate a hash value to the respective OptionPayout instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]

	buyerSeller BuyerSeller (1..1)
	optionType OptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
	feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">
	exerciseTerms OptionExercise (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
	underlier Product (1..1) <"The product underlying the option, which can be of any type including ContractualProduct or Security.">
	observationTerms ObservationTerms (0..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. To be used for option contracts that reference a benchmark price.">
	schedule CommoditySchedule (0..1) <"Allows the full representation of a commodity payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

	condition ClearedPhysicalSettlementExists:
		if settlementTerms -> physicalSettlementTerms exists
		    and underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout only exists
		    and underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2
		then settlementTerms -> physicalSettlementTerms -> clearedPhysicalSettlement exists

type SecurityLeg: <" Terms defining a security leg in a securities financing transaction, which can either be the near leg or the far leg and is closely modelled onto the nearLeg and farLeg types in FpML">
	[metadata key]

	buyerSeller BuyerSeller (1..1) <"Whether the leg is a buyer or seller of security">
	settlementDate AdjustableOrRelativeDate (1..1) <"Settlement or Payment Date for the security leg">
	settlementAmount Money (0..1) <"Settlement amount for the security leg">
	settlementCurrency string (0..1) <"Settlement Currency for use where the Settlement Amount cannot be known in advance.">
	fxRate ExchangeRate (0..1) <"FX rate in case when cash settlement amount is in a different currency to the security.">
	deliveryDate AdjustableOrRelativeDate (0..1) <"Delivery Date for the transaction. Delivery Date can be populated when it is not equal to the Settlement Date.">
	deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

	condition SecurityLegChoice:
		required choice settlementAmount, settlementCurrency

type SecurityPayout: <" Security payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction.">
	[metadata key]
    [deprecated]

	securityLeg SecurityLeg (1..*) <"Each SecurityLeg represent a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    initialMargin InitialMargin (0..1) <"RepoDurationEnum.">
	repoDuration RepoDurationEnum (0..1) <"A duration code for the repo transaction. This defines a type of a repo transaction with fixed duration.">
	securityValuation SecurityValuation (1..*) <"The underlying securities and their valuation for the security leg.">

type InitialMargin: <" Defines initial margin applied to a repo transaction. Initial margin is an agreed premium to the Purchase Price of a repo to determine the required Market Value of the collateral to be delivered on the Purchase Date. It reflects quality of the collateral. Its aim is to calculate the risk-adjusted or liquidation value of collateral.">
    [deprecated]

	marginType MarginTypeEnum (1..1) <"An element defining the type of assets (cash or securities) specified to apply as margin to the repo transaction. See GMRA 2011 paragraph 2(h) for 'Cash Margin' and GMRA 2011 paragraph 2(cc) for 'Margin Securities'.">
	margin InitialMarginCalculation (1..*) <"Initial margin calculation for a collateral asset. Initial margin requirements may be specified for multiple pieces of collateral.">
	marginThreshold Money (0..1) <"An element defining a margin threshold which is the Net Exposure of a trade below which parties agree they will not call a margin from each other.">
	minimumTransferAmount Money (0..1) <"An element defining a minimum transfer amount which is the minimum margin call parties will make once the margin threshold (or margin ratio threshold / haircut threshold) has been exceeded.">

	condition MarginThreshold:
		if marginThreshold exists
		then marginThreshold -> value > 0

	condition MinimumTransferAmount:
		if minimumTransferAmount exists
		then minimumTransferAmount -> value > 0

type InitialMarginCalculation: <" Defines the initial margin calculation applicable to a single piece of collateral.">
    [deprecated]

	marginRatio number (0..1) <"An element defining an initial margin expressed as a ratio of the Market Value of the collateral to the Purchase Price. A default value of initial margin ratio of 1.00 means there is no margin and thus no risk related with the collateral. See GMRA 2000 paragraph 2(z) and GMRA 2011 paragraph 2(bb).">
	marginRatioThreshold number (0..2) <"An element defining a margin ratio threshold which is the value above (when it's lower than initial margin ratio) or below (when it's higher than initial margin ratio) which parties agree they will not call a margin from each other.">
	haircut number (0..1) <"An element defining a haircut expressed as the percentage difference between the Market Value of the collateral and the Purchase Price of the repo and calculated as 100 multiplied by a ratio of the difference between the Market Value of the collateral and the Purchase Price of the repo to the Market Value of the collateral. Haircut is alternative way to adjust the value of collateral sold in a repurchase agreement to initial margin ratio. Because an initial margin is a percentage of the Purchase Price, while a haircut is a percentage of the Market Value of collateral, the arithmetic of initial margins and haircuts is slightly different. For example, an initial margin of 102% is not equivalent to a haircut of 2%, but to 1.961% (ie 100/102%). See GMRA 2011 paragraph 2(aa).">
	haircutThreshold number (0..2) <"An element defining a haircut percentage threshold which is the value above (when it's lower than initial haircut) or below (when it's higher than initial haircut) which parties agree they will not call a margin from each other.">

	condition InitialMarginCalculationChoice:
		required choice marginRatio, haircut

type ReturnTerms: <"Specifies the type of return of a performance payout.">

	//commodityReturnTerms CommodityPriceReturnTerms (0..1)
	priceReturnTerms PriceReturnTerms (0..1) <"Return terms based upon the underlier's observed price.">
	dividendReturnTerms DividendReturnTerms (0..1) <"Return terms based upon dividend payments associated to the underlier.">
	varianceReturnTerms VarianceReturnTerms (0..1) <"Return terms based upon the observed variance of the underlier's price.">
	volatilityReturnTerms VolatilityReturnTerms (0..1) <"Return terms based upon the observed volatility of the underlier's price.">
	correlationReturnTerms CorrelationReturnTerms (0..1) <"Return terms based upon the observed correlation between the components of the underlying basket.">

    condition ReturnTermsExists: <"Checks that the return type label matches the actual return terms structure of the product.">
        if priceReturnTerms -> returnType = ReturnTypeEnum -> Total then
            (priceReturnTerms, dividendReturnTerms) only exists
        else if priceReturnTerms -> returnType = ReturnTypeEnum -> Price then
            priceReturnTerms only exists
        else
            priceReturnTerms only exists
            or dividendReturnTerms only exists
            or varianceReturnTerms only exists
            or volatilityReturnTerms only exists
            or correlationReturnTerms only exists

type PerformancePayout extends PayoutBase: <"Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation products.">
    [metadata key]

	observationTerms ObservationTerms (0..1) <"Defines how and when a performance type option or performance type swap is to be observed.">
	valuationDates ValuationDates (1..1) <"Defines how and when a performance type option or performance type swap is to be valued, including both interim and final valuation.">
	paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
	underlier Product (0..1)<"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
	fxFeature FxFeature (0..*) <"Defines quanto or composite FX features that are included in the swap leg.">
	returnTerms ReturnTerms (1..1) <"Specifies the type of return of a performance payout.">

	condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
		priceQuantity exists

	condition NoSharePriceDividendAdjustmentIndex: <"If the underlier is an index, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> index exists then
            returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
            and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

	condition NoSharePriceDividendAdjustmentForeignExchange: <"If the underlier is an foreign exchange, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> foreignExchange exists then
			returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
			and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

	condition CorrelationUnderlierOnlyBasket: <"Correlation Return Terms can only have a basket as underlier, since it needs to compute the correlation between two or more products.">
	    if returnTerms -> correlationReturnTerms exists then
	        underlier -> basket only exists

	condition EquitySpecificAttributes: <"Equity specific attributes cannot be present in non-equity products.">
		if Qualify_UnderlierProduct_Equity( underlier ) = False then
            returnTerms -> varianceReturnTerms -> dividendApplicability is absent
            and returnTerms -> varianceReturnTerms -> equityUnderlierProvisions is absent
            and returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
            and returnTerms -> volatilityReturnTerms -> dividendApplicability is absent
            and returnTerms -> volatilityReturnTerms -> equityUnderlierProvisions is absent
            and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent
            and returnTerms -> correlationReturnTerms -> dividendApplicability is absent
            and returnTerms -> correlationReturnTerms -> equityUnderlierProvisions is absent
            and returnTerms -> correlationReturnTerms -> sharePriceDividendAdjustment is absent

	//condition UnderlierOrObservable: <"The Performance Payout must reference either an underlier or an observable">
		//underlier exists
		//or
		//ObservationTerms -> observable exists

type Payout: <"A class to represent the set of future cashflow methodologies in the form of specific payout class(es) that can be associated for the purpose of specifying a financial product. For example, two interest rate payouts can be combined to specify an interest rate swap, or one interest rate payout can be combined with a credit default payout to specify a credit default swap.">
    [metadata key]

	interestRatePayout InterestRatePayout (0..*) <"All of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg).">
	creditDefaultPayout CreditDefaultPayout (0..1) <"The credit default payout, which provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms.">
	optionPayout OptionPayout (0..*) <"The option payout.">
	commodityPayout CommodityPayout (0..*) <"Defines the payout for the floating leg of a Commodity Swap.">
	forwardPayout ForwardPayout (0..*) <"Represents a forward settling payout. The 'Underlier' attribute captures the underlying payout, which is settled according to the 'SettlementTerms' attribute. Both FX Spot and FX Forward should use this component.">
	fixedPricePayout FixedPricePayout (0..*) <"Defines a payout in which one or more payouts are defined as a fixed price.">
	securityPayout SecurityPayout (0..*) <"The security payout when the product involves some form of securities, such as collateral in a securities financing transaction">
		[deprecated]
	cashflow Cashflow (0..*) <"A cashflow between the parties to the trade. For interest rate and equity products, this corresponds to the FpML additionalPayment element. For credit default swaps, this corresponds to the FpML initialPayment element and the singlePayment element of the fee leg. For option products, it represents the FpML premium element.">
	performancePayout PerformancePayout (0..*) <"The performance payout, which encompasses the equity price returns, dividend returns, volatility return, variance return and correlation provisions.">
	assetPayout AssetPayout (0..*) <"The security payout when the product involves some form of securities, such as collateral in a securities financing transaction">
    structuredPayout New2Payout (0..*) <".....................">
    genericPayout New2StructuredPayout (0..*)  <".....................">

	condition ReturnType_Total_Requires_Dividends: <"A total return implies both a price and a dividend return">
	    if performancePayout -> returnTerms -> priceReturnTerms -> returnType all = ReturnTypeEnum -> Total then
	        performancePayout -> returnTerms -> dividendReturnTerms exists

	condition LastRegularPaymentDate: <"FpML specifies that lastRegularPaymentDate must only be included if there is a final stub. As part of the CDM, this data rule has been adjusted to specify that it only applies to interest rate swaps, as the credit derivatives products can have a specified lastRegularPaymentDate while the stub is typically not applicable to those.">
		if interestRatePayout -> paymentDates -> lastRegularPaymentDate exists
			and interestRatePayout -> stubPeriod -> finalStub exists
		then interestRatePayout count = 2

	condition PayRelativeTo: <"FpML specifies a required payRelativeTo element as part of the PaymentDates. As standardized CDS don't have such payRelativeTo provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
			and interestRatePayout -> paymentDates exists
		then interestRatePayout -> paymentDates -> payRelativeTo exists

	condition PaymentDatesAdjustments: <"FpML specifies a required paymentDatesAdjustments element as part of the PaymentDates. As standardized CDS don't have such paymentDatesAdjustments provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
			and interestRatePayout -> paymentDates exists
		then interestRatePayout -> paymentDates -> paymentDatesAdjustments exists

	condition PaymentFrequency: <"FpML specifies a required paymentFrequency element as part of the PaymentDates. As standardized CDS may not have such paymentFrequency provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
			and interestRatePayout -> paymentDates exists
		then interestRatePayout -> paymentDates -> paymentFrequency exists

	condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
			if optionPayout exists then
				optionPayout -> priceQuantity exists
					or optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2

	condition DayCountFraction: <"FpML specifies a required dayCountFraction element as part of the swapStream/calculationPeriodAmount/calculation. As standardized CDS don't have such specified day count fraction, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
		then interestRatePayout -> dayCountFraction exists

	condition PaymentDates: <"FpML specifies a required paymentDates element as part of the swapStream. As standardized CDS may not have specified payment dates, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
		then interestRatePayout -> dayCountFraction exists

	condition MarketPrice: <"FpML specifies that marketFixedRate and marketPrice only have meaning in a credit index trade">
		if creditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
		then creditDefaultPayout -> transactedPrice -> marketFixedRate is absent
			and creditDefaultPayout -> transactedPrice -> marketPrice is absent

	condition NotionalResetOnPerformancePayout: <"Notional reset only applies to return swaps, and therefore can only exist on an performancePayout.">
		interestRatePayout -> priceQuantity -> reset is absent
		and creditDefaultPayout -> priceQuantity -> reset is absent
		and optionPayout -> priceQuantity -> reset is absent
		and cashflow -> priceQuantity -> reset is absent

	condition NotionalResetInterestRatePayoutExists: <"As the performancePayout->payoutQuantity->reset attribute applies to return swaps, the interestRatePayout needs to be present alongside it.">
		if  performancePayout -> priceQuantity -> reset contains True
		then interestRatePayout exists

type Product: <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
	[metadata key]

	contractualProduct ContractualProduct (0..1) <"Specifies the contractual product's economic terms, product identifier, and product taxonomy.">
	index Index (0..1) <"Identifies an index by referencing a product identifier.">
	loan Loan (0..1) <"Identifies a loan by referencing a product identifier and an optional set of attributes.">
	assetPool AssetPool (0..1) <"Identifies an asset pool product for defining pool of assets backing an asset backed security.">
	foreignExchange ForeignExchange (0..1) <"Defines a foreign exchange spot or forward transaction.">
	commodity Commodity (0..1) <"Identifies a commodity by referencing a product identifier.">
	    [metadata address "pointsTo"=Observable->commodity]
	security Security (0..1) <"Identifies a security by referencing a product identifier and a security type, plus an optional set of attributes.">
	basket Basket (0..1) <"Identifies a custom basket by referencing a product identifier and its constituents.">

	condition: one-of

type Basket extends ProductBase: <"Defines a custom basket by referencing a product identifier and its consituents.">
	basketConstituent Product (1..*) <"Identifies the constituents of the basket">

type TradeLot: <"Specifies the price and quantity of a trade lot, where the same product could be traded multiple times with the same counterparty but in different lots (at a different date, in a different quantity and at a different price). One trade lot combined with a product definition specifies the entire economics of a trade. The lifecycle mechanics of each such trade lot (e.g. cashflow payments) is independent of the other lots.">
	lotIdentifier Identifier (0..*) <"Specifies one or more identifiers for the lot, if any.">
	priceQuantity PriceQuantity (1..*) <"Specifies the settlement characteristics of a trade lot: price, quantity, observable (optionally) and the settlement terms. This attribute has a multiple cardinality to allow to specify the price, quantity and observable of different legs in a single, composite product (e.g. a Swap).">

type TradableProduct: <"Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this product plus an (optional) mechanism for any potential future quantity adjustment.">

	product Product (1..1) <"The underlying product to be included in a contract or execution.">
	tradeLot TradeLot (1..*) <"Specifies the price, quantity and effective date of each trade lot, when the same product may be traded multiple times in different lots with the same counterparty. In a trade increase, a new trade lot is added to the list, with the corresponding effective date. In a trade decrease, the existing trade lot(s) are decreased of the corresponding quantity (and an unwind fee may have to be settled). The multiple cardinality and the ability to increase existing trades is used for Equity Swaps in particular.">
	counterparty Counterparty (2..2) <"Specifies the parties which are the two counterparties to the transaction.  The product is agnostic to the actual parties to the transaction, with the party references abstracted away from the product definition and replaced by the counterparty enum (e.g. CounterpartyEnum values Party1 or Party2). The counterparty enum can then be positioned in the product (e.g. to specify which counterparty is the payer, receiver etc) and this counterparties attribute, which is positioned outside of the product definition, allows the counterparty enum to be associated with an actual party reference.">
		[docReference ICMA GMRA namingConvention "Party"
			provision "Parties entering into GMRA, as specified on page 1 of the GMRA and under 1. (a)."]
	ancillaryParty AncillaryParty (0..*) <"Specifies the parties with ancillary roles in the transaction. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and this AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">
	adjustment NotionalAdjustmentEnum (0..1) <"Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfolio rebalancing etc. It is typically used in the context of Equity Swaps.">

	condition PriceQuantityTriangulation: <"Check PriceQuantity triangulation for each TradeLot.">
	   PriceQuantityTriangulation( tradeLot ) = True

	condition NotionalAdjustment: <"As the adjustment attribute applies to return swaps, the equity payout needs to be present alongside it.">
		if adjustment exists
		then product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> priceReturnTerms exists
		    or product -> contractualProduct -> economicTerms -> payout -> performancePayout exists

  condition DisruptionEventsDeterminingParty:
		if product -> contractualProduct -> economicTerms -> extraordinaryEvents -> additionalDisruptionEvents -> determiningParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> DisruptionEventsDeterminingParty
		and if ancillaryParty -> role contains AncillaryRoleEnum -> DisruptionEventsDeterminingParty
		then product -> contractualProduct -> economicTerms -> extraordinaryEvents -> additionalDisruptionEvents -> determiningParty exists

	condition PerformancePayout_ExtraordinaryDividendsParty:
		if product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
		and if ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
		then product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists

	condition OptionPayout_PredeterminedClearingOrganizationParty:
		if product -> contractualProduct -> economicTerms -> payout -> optionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

	condition ForwardPayout_PredeterminedClearingOrganizationParty:
		if product -> contractualProduct -> economicTerms -> payout -> forwardPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

	condition PredeterminedClearingOrganizationParty:
		if ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty then
		product -> contractualProduct -> economicTerms -> payout -> forwardPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists or
		product -> contractualProduct -> economicTerms -> payout -> optionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists

	condition ExerciseNoticeReceiverPartyManual:
		if product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
		and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
		then product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists

	condition ExerciseNoticeReceiverPartyOptionalEarlyTermination:
		if product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver  exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
		and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
		then product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver  exists

	condition ExerciseNoticeReceiverPartyCancelableProvision:
		if product -> contractualProduct -> economicTerms -> terminationProvision -> cancelableProvision  -> exerciseNotice -> exerciseNoticeReceiver exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
		and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
		then product -> contractualProduct -> economicTerms -> terminationProvision -> cancelableProvision  -> exerciseNotice -> exerciseNoticeReceiver exists

	condition ExerciseNoticeReceiverPartyExtendibleProvision:
		if product -> contractualProduct -> economicTerms -> terminationProvision -> extendibleProvision  -> exerciseNotice -> exerciseNoticeReceiver exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
		and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
		then product -> contractualProduct -> economicTerms -> terminationProvision -> extendibleProvision  -> exerciseNotice -> exerciseNoticeReceiver exists

	condition CalculationAgentIndependent:
		if product -> contractualProduct -> economicTerms -> calculationAgent -> calculationAgentParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
		and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
		then product -> contractualProduct -> economicTerms -> calculationAgent -> calculationAgentParty exists

	condition CalculationAgentOptionalEarlyTermination:
		if product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
		and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
		then product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists

	condition CalculationAgentMandatoryEarlyTermination:
		if product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists
		then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
		and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
		then product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists

type ConstituentWeight: <"A class describing the weight of each of the underlier constituent within the basket, either in absolute or relative terms.">

	openUnits number (0..1) <"The number of units (index or securities) that constitute the underlier of the swap. In the case of a basket swap, this element is used to reference both the number of basket units, and the number of each asset components of the basket when these are expressed in absolute terms.">
	basketPercentage number (0..1) <"The relative weight of each respective basket constituent, expressed in percentage. A basket percentage of 5% would be represented as 0.05.">

	condition BasketPercentage: <"FpML specifies basketPercentage as a RestrictedPercentage type, meaning that the value needs to be comprised between 0 and 1.">
		if basketPercentage exists
		then basketPercentage >= 0.0 and basketPercentage <= 1.0

type ForwardPayout extends PayoutBase: <"Represents a forward settling payout. The underlier attribute captures the underlying payout, which is settled according to the settlementTerms attribute (which is part of PayoutBase). Both FX Spot and FX Forward should use this component.">
	[metadata key]

	underlier Product (1..1) <"Underlying product that the forward is written on, which can be of any type: FX, a contractual product, a security, etc.">

	condition SettlementTerms: <"For foreign exchange contracts, the settlement terms must exist.">
		if underlier -> foreignExchange exists
		then settlementTerms exists

	condition SettlementDate: <"For foreign exchange contracts, either the settlementDate is set or the cashflowDates, but not both. When the cashflowDates are set, they must be the same for the 2 legs of the currency pair.">
		if underlier -> foreignExchange exists then
		(
			settlementTerms -> settlementDate -> valueDate exists
			and underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate is absent
			and underlier -> foreignExchange -> exchangedCurrency2 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate is absent
		) or
		(
			settlementTerms -> settlementDate -> valueDate is absent
			and underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
			and underlier -> foreignExchange -> exchangedCurrency2 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
			and underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate = underlier -> foreignExchange -> exchangedCurrency2 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
		)

	condition FxSettlement: <"For foreign exchange contracts, the settlement type must be either fx non-deliverable settlement or not specified, which implies physical settlement in the case of foreign exchange.">
		if underlier -> foreignExchange exists
		then settlementTerms -> physicalSettlementTerms is absent

type CommoditySchedule: <"A class that allows the full representation of a commodity payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
	schedulePeriod SchedulePeriod (1..*) <"Defines a period of a commodity schedule structure.">

type SchedulePeriod: <"A class that defines the commodity period of a schedule. The period contains a set of start and end dates, quantities, fixing, and pricing data.">
	calculationPeriod DateRange (1..1) <"Period for which the payment is generated.">
    paymentDate date (1..1) <"Adjusted payment date.">
    fixingPeriod DateRange (1..1) <"Period over which the underlying price is observed.">

type FixedPricePayout extends PayoutBase: <"Represents a fixed price payout. There is no underlier associated with this payout type and is based on fixed pricing per a given unit (e.g. in commodities price per barrel)">
	[metadata key]

	paymentDates PaymentDates (1..1) <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
    fixedPrice FixedPrice (1..1) <"Specifies the fixed price on which fixed forward payments are based.">
    schedule CommoditySchedule (0..1) <"Allows the full representation of a commodity payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

	condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
		priceQuantity exists

type CancelableProvision extends BuyerSeller: <"A data defining:  the right of a party to cancel a swap transaction on the specified exercise dates. The provision is for 'walk-away' cancellation (i.e. the fair value of the swap is not paid). A fee payable on exercise can be specified. As a difference from the FpML construct, the canonical model extends the BuyerSeller class.">

	americanExercise AmericanExercise (0..1) <"American exercise. FpML implementations consists in an exercise substitution group.">
	bermudaExercise BermudaExercise (0..1) <"Bermuda exercise. FpML implementations consists in an exercise substitution group.">
	europeanExercise EuropeanExercise (0..1) <"European exercise. FpML implementations consists in an exercise substitution group.">
	exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
	followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
	cancelableProvisionAdjustedDates CancelableProvisionAdjustedDates (0..1) <"The adjusted dates associated with a cancelable provision. These dates have been adjusted for any applicable business day convention.">
	finalCalculationPeriodDateAdjustment FinalCalculationPeriodDateAdjustment (0..*) <"Business date convention adjustment to final payment period per leg (swapStream) upon exercise event. The adjustments can be made in-line with leg level BDC's or they can be specified separately.">
	initialFee Transfer (0..1) <"An initial fee for the cancelable option.">
	callingParty CallingPartyEnum (0..1) <"The party with right to exercise a cancellation. Allows for buyer, seller or either.">
    earliestDate AdjustableOrRelativeDate (0..1) <"The first day when cancelation is permitted to take effect. A party may give notice prior to this date and taken together with the effective period would be necessary to cancel on this date.">
   	expirationDate AdjustableOrRelativeDate (0..1) <"The last day within the term of the contract that cancelation is allowed.">
   	effectiveDate AdjustableOrRelativeDates (0..1) <"The effective date if cancelation is invoked otherwise the cancellation period defines the cancellation date.">
   	effectivePeriod Period (0..1) <"Effective period for cancelation when notice is given. This is the period after notice is given that cancellation becomes effecticve.">
   	earliestCancellationTime BusinessCenterTime (0..1) <"The earliest time in a business day that notice of cancelation can be given.">    	latestCancelationTime BusinessCenterTime (0..1 ) <"The latest time at which notice of cancelation can be given.">

	// condition ExerciseChoice: <"condition to represent an FpML substitution group construct.">
		// optional choice americanExercise, bermudaExercise, europeanExercise

	condition EffectiveDate: <"Must select one of predefined cancellation types of effectiveDate or effectivePeriod.">
		optional choice effectiveDate, effectivePeriod

	condition CancelableProvisionExerciseNoticeReceiverParty:
		if exerciseNotice -> exerciseNoticeReceiver exists
		then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision

type CancelableProvisionAdjustedDates: <"A data to:  define the adjusted dates for a cancelable provision on a swap transaction.">

	cancellationEvent CancellationEvent (1..*) <"The adjusted dates for an individual cancellation date.">

type CancellationEvent: <"The adjusted dates for a specific cancellation date, including the adjusted exercise date and adjusted termination date.">
	[metadata key]

	adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
	adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">

type EarlyTerminationEvent: <"A data to:  define the adjusted dates associated with an early termination provision.">
	[metadata key]

	adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
	adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
	adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
	adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">
	adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

	condition FpML_ird_39: <"FpML validation rule ird-39 - AdjustedExerciseDate must be before or equal to adjustedEarlyTerminationDate.">
		adjustedExerciseDate <= adjustedEarlyTerminationDate

	condition FpML_ird_40: <"FpML validation rule ird-40 - AdjustedExerciseDate must be before or equal to adjustedCashSettlementValuationDate.">
		adjustedExerciseDate <= adjustedCashSettlementValuationDate

	condition FpML_ird_41: <"FpML validation rule ird-41 - AdjustedCashSettlementValuationDate must be before or equal to adjustedCashSettlementPaymentDate.">
		adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type EarlyTerminationProvision: <"A data defining:  an early termination provision for a swap. This early termination is at fair value, i.e. on termination the fair value of the product must be settled between the parties.">
	[metadata key]

	mandatoryEarlyTermination MandatoryEarlyTermination (0..1) <"A mandatory early termination provision to terminate the swap at fair value.">
	mandatoryEarlyTerminationDateTenor Period (0..1) <"Period after trade date of the mandatory early termination date.">
	optionalEarlyTermination OptionalEarlyTermination (0..1) <"An option for either or both parties to terminate the swap at fair value.">
	optionalEarlyTerminationParameters ExercisePeriod (0..1) <"Definition of the first early termination date and the frequency of the termination dates subsequent to that. American exercise is defined by having a frequency of one day.">
    autocallableProvision NewAutocallableProvision (0..1) <"Specifies that an existence condition is attached to the whole Trade, which means the existence of the Trade is contigent i.e. the Trade is deemed to exist by default i.e. having economic effect, unless Knock is activated, that resulting in the Trade being early terminated.">
    callableProvision OptionalEarlyTermination (0..1) <"A data defining: the right of a party to cancel a swap transaction on the specified exercise dates.">

    condition AutocallableMeansKnockOutOnly:
    autocallableProvision -> knockType = NewKnockTypeEnum -> KnockOut

	condition MandatoryEarlyTermination: <"The FpML MandatoryEarlyTermination.model specifies a required choice node. The choice node associated with the FpML EarlyTerminationProvision is quite complex and using the data rule provides a more flexible approach than adding complexity to the condition grammar.">
		(mandatoryEarlyTermination exists or optionalEarlyTermination exists)
			or (mandatoryEarlyTermination exists and optionalEarlyTermination exists)

type NewAutocallableProvision extends NewKnock : <"Specifies that an existence condition is attached to the whole Trade, which means the existence of the Trade is contigent i.e. the Trade is deemed to exist by default i.e. having economic effect, unless Knock is activated, that resulting in the Trade being early terminated.">
  settlementDate SettlementDate (1..1) <"A data defining the settlement date(s), together with applicable adjustments, or as a date relative to some other (anchor) date, or as any date in a range of contiguous business days. This data type provides a level of abstraction on top of the different legacy methods used to specify a settlement / payment date, which vary across product types, asset classes and delivery types.">
  earlyRedemptionPayout NewPayoutOrigin (0..1) <"Represents the origin to the transfer as a reference for lineage purposes, whether it originated from trade level settlement terms or from payment terms on an economic payout.">


type ExercisePeriod: <"This defines the time interval to the start of the exercise period, i.e. the earliest exercise date, and the frequency of subsequent exercise dates (if any).">
	[metadata key]

	earliestExerciseDateTenor Period (1..1) <"The time interval to the first (and possibly only) exercise date in the exercise period.">
	exerciseFrequency Period (0..1) <"The frequency of subsequent exercise dates in the exercise period following the earliest exercise date. An interval of 1 day should be used to indicate an American style exercise period.">

type ExtendibleProvision extends BuyerSeller: <"A data defining:  an option to extend an existing swap transaction on the specified exercise dates for a term ending on the specified new termination date. As a difference from FpML, it extends the BuyerSeller class, which represents the BuyerSeller.model.">

	americanExercise AmericanExercise (0..1) <"American exercise. FpML implementations consists in an exercise substitution group.">
	bermudaExercise BermudaExercise (0..1) <"Bermuda exercise. FpML implementations consists in an exercise substitution group.">
	europeanExercise EuropeanExercise (0..1) <"European exercise. FpML implementations consists in an exercise substitution group.">
	exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
	followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
	extendibleProvisionAdjustedDates ExtendibleProvisionAdjustedDates (0..1) <"The adjusted dates associated with an extendible provision. These dates have been adjusted for any applicable business day convention.">
	callingParty CallingPartyEnum (0..1)

	singlePartyOption PartyRole (0..1) <"If the ability to extend the contract is not available to both parties then this component specifies the buyer and seller of the option.">
	noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before a contract is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
	noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
	extensionTerm RelativeDateOffset (0..1) <"The length of each extension period relative to the effective date of the preceding contract.">
    extensionPeriod AdjustableRelativeOrPeriodicDates (0..1) <"The period within which notice can be given that the contract will be extended.">

	condition ExtendibleProvisionExerciseNoticeReceiverParty:
		if exerciseNotice -> exerciseNoticeReceiver exists
		then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision

type ExtendibleProvisionAdjustedDates: <"A data defining:  the adjusted dates associated with a provision to extend a swap.">

	extensionEvent ExtensionEvent (1..*) <"The adjusted dates associated with a single extendible exercise date.">

type ExtensionEvent: <"A data to:  define the adjusted dates associated with an individual extension event.">
	[metadata key]

	adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
	adjustedExtendedTerminationDate date (1..1) <"The termination date if an extendible provision is exercised. This date should already be adjusted for any applicable business day convention.">

	condition FpML_ird_42: <"FpML validation rule ird-42 - adjustedExerciseDate must be before adjustedExtendedTerminationDate.">
		adjustedExerciseDate < adjustedExtendedTerminationDate

type MandatoryEarlyTermination: <"A data to:  define an early termination provision for which exercise is mandatory.">
	[metadata key]

	mandatoryEarlyTerminationDate AdjustableDate (1..1) <"The early termination date associated with a mandatory early termination of a swap.">
	calculationAgent CalculationAgent (1..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
	cashSettlement SettlementTerms (1..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
	mandatoryEarlyTerminationAdjustedDates MandatoryEarlyTerminationAdjustedDates (0..1) <"The adjusted dates associated with a mandatory early termination provision. These dates have been adjusted for any applicable business day convention.">

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination

type MandatoryEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with a mandatory early termination provision.">

	adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
	adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
	adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">

	condition FpML_ird_44: <"FpML validation rule ird-44 - AdjustedEarlyTerminationDate must be before or equal to adjustedCashSettlementValuationDate must be before or the same as adjustedCashSettlementPaymentDate">
		adjustedEarlyTerminationDate <= adjustedCashSettlementValuationDate
			and adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type OptionalEarlyTermination: <"A data defining:  an early termination provision where either or both parties have the right to exercise.">

	singlePartyOption BuyerSeller (0..1) <"If optional early termination is not available to both parties then this component specifies the buyer and seller of the option. In FpML, this attribute is of type SinglePsrtyOption, which actually consists of the BuyerSeller.model.">
	mutualEarlyTermination boolean (0..1) <"Used for specifying whether the Mutual Early Termination Right that is detailed in the Master Confirmation will apply.">
	americanExercise AmericanExercise (0..1) <"American exercise. FpML implementations consists in an exercise substitution group.">
	bermudaExercise BermudaExercise (0..1) <"Bermuda exercise. FpML implementations consists in an exercise substitution group.">
	europeanExercise EuropeanExercise (0..1) <"European exercise. FpML implementations consists in an exercise substitution group.">
	exerciseNotice ExerciseNotice (0..*) <"Definition of the party to whom notice of exercise should be given.">
	followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
	calculationAgent CalculationAgent (0..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
	cashSettlement SettlementTerms (0..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
	optionalEarlyTerminationAdjustedDates OptionalEarlyTerminationAdjustedDates (0..1) <"An early termination provision to terminate the trade at fair value where one or both parties have the right to decide on termination.">

	condition ExerciseChoice: <"condition to represent an FpML choice construct.">
		optional choice americanExercise, bermudaExercise, europeanExercise

	condition OptionalEarlyTerminationExerciseNoticeReceiverParty:
		if exerciseNotice -> exerciseNoticeReceiver exists
		then exerciseNotice -> exerciseNoticeReceiver contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination

type OptionalEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with an optional early termination provision.">

	earlyTerminationEvent EarlyTerminationEvent (1..*) <"The adjusted dates associated with an individual early termination date.">

type Asian: <"As per ISDA 2002 Definitions.">

	averagingInOut AveragingInOutEnum (1..1)
	strikeFactor number (0..1) <"The factor of strike.">
	averagingPeriodIn AveragingPeriod (0..1) <"The averaging in period.">
	averagingPeriodOut AveragingPeriod (0..1) <"The averaging out period.">

type AveragingCalculation: <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
   averagingMethod AveragingCalculationMethod (1..1) <"Specifies enumerations for the type of averaging calculation.">
   precision Rounding (1..1) <"Rounding applied to the average calculation. ">

type AveragingStrikeFeature: <"Defines the terms required to calculate the average observations associated with an averaging strike.">
   averagingCalculation AveragingCalculation (1..1) <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
   observationTerms ObservationTerms (1..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. ">

type Barrier: <"As per ISDA 2002 Definitions.">

	barrierCap TriggerEvent (0..1) <"A trigger level approached from beneath.">
	barrierFloor TriggerEvent (0..1) <"A trigger level approached from above.">

type CalendarSpread: <"A type for defining a calendar spread feature.">

	expirationDateTwo AdjustableOrRelativeDate (1..1)

type Composite: <"Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.">

	determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which an amount or a date is determined.">
	relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">
	fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
	fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type FxFeature: <"A type for defining FX Features.">

	referenceCurrency string (1..1) <"Specifies the reference currency of the trade.">
		[metadata id]
		[metadata scheme]
	composite Composite (0..1) <"If 'Composite' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price  Strike Price) / (Strike Price  Settlement Price) x Multiplier provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
	quanto Quanto (0..1) <"If 'Quanto' is specified as the Settlement Type in the relevant Transaction Supplement, an amount, as determined by the Calculation Agent in accordance with the Section 8.2 of the Equity Definitions.">
crossCurrency Composite (0..1) <"If 'Cross-Currency' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price  Strike Price) / (Strike Price  Settlement Price) x Multiplier x one unit of the Reference Currency converted into an amount in the Settlement Currency using the rate of exchange of the Settlement Currency as quoted on the Reference Price Source on the Valuation Date, provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
	condition FxFeatureChoice: <" Choice rule to represent an FpML choice construct.">
		required choice composite, quanto, crossCurrency

type Knock: <"Knock In means option to exercise comes into existence. Knock Out means option to exercise goes out of existence.">

	knockIn TriggerEvent (0..1) <"The knock in.">
	knockOut TriggerEvent (0..1) <"The knock out.">

type OptionFeature: <"Defines additional optional features that can be included in an option contract.">

	fxFeature FxFeature (0..*) <"Describes a quanto or composite FX feature.">
	strategyFeature StrategyFeature (0..1) <"Defines a simple strategy feature.">
	averagingFeature AveragingCalculation (0..1) <"Defines an option feature in which an average market observation price is determined on valuation and compared to the strike to determine a settlement amount.">
	barrier Barrier (0..1) <"Specifies a barrier feature.">
	knock Knock (0..1) <"Specifies a knock in or knock out feature.">
	passThrough PassThrough (0..1) <"Specifies the rules for pass-through payments from the underlier, such as dividends.">

type TerminationProvision: <"A class for defining option provisions.">
	cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">
	earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">
	extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">

	condition TerminationProvisionChoice:
		required choice cancelableProvision, extendibleProvision, evergreenProvision, earlyTerminationProvision

type OptionStrike: <"Defines the strike price of an option.">

	strikePrice Price (0..1) <"Defines the strike of an option in the form of a price that could be a cash price, interestRate, or other types.">
	strikeReference FixedRateSpecification (0..1) <"Defines the strike of an option in reference to the spread of the underlying swap (typical practice in the case of an option on a credit single name swaps).">
		[metadata reference]
	referenceSwapCurve ReferenceSwapCurve (0..1) <"Defines the strike of an option when expressed by reference to a swap curve (Typically the case for a convertible bond option).">
	averagingStrikeFeature AveragingStrikeFeature (0..1) <"Defines an  option strike that is calculated from an average of observed market prices.">

	condition: one-of

type OptionStyle: <"The qualification of the option style: American, Bermuda or European. FpML implements those features as part of a substitution group.">

	americanExercise AmericanExercise (0..1)
	bermudaExercise BermudaExercise (0..1)
	europeanExercise EuropeanExercise (0..1)
	condition: one-of

type PassThrough: <"Type which contains pass through payments.">

	passThroughItem PassThroughItem (1..*) <"One to many pass through payment items.">

type PassThroughItem: <"Class to represent a single pass through payment.">

	payerReceiver PayerReceiver (1..1) <"This attribute doesn't exists in the FpML construct, which makes use of the PayerReceiver.model group.">
	passThroughPercentage number (1..1) <"Percentage of payments from the underlier which are passed through.">

type Quanto: <"Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a currency that is different from the currency denomination of the underlier.">

	fxRate FxRate (0..*) <"Specifies a currency conversion rate.">
	fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
	fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type StrategyFeature: <"A class for defining option strategy features.">

	strikeSpread StrikeSpread (0..1) <"Definition of the upper strike in a strike spread.">
	calendarSpread CalendarSpread (0..1) <"Definition of the later expiration date in a calendar spread.">

type StrikeSpread: <"A class for defining a strike spread feature.">

	upperStrike OptionStrike (1..1) <"Upper strike in a strike spread.">
	upperStrikeNumberOfOptions number (1..1) <"Number of options at the upper strike price in a strike spread.">

type AmericanExercise: <"A class defining the exercise period for an American style option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
	[metadata key]

	commencementDate AdjustableOrRelativeDate (1..1) <"The first day of the exercise period for an American style option.">
	expirationDate AdjustableOrRelativeDate (1..1) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
	relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.'">
	earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) to, and including, the expiration date.">
	latestExerciseTime BusinessCenterTime (0..1 ) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
	expirationTime BusinessCenterTime (1..1) <"The latest time for exercise on expirationDate.">
	expirationTimeType ExpirationTimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
	multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
	exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">

type AutomaticExercise: <"A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more than the threshold amount on the exercise date.">

	thresholdRate number (0..1) <"A threshold rate. The threshold of 0.10% would be represented as 0.001">
	isApplicable boolean (0..1) <"Boolean that indicates if it has an automaticExercise">
type BermudaExercise: <"A class defining the Bermuda option exercise dates and the expiration date together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fee.">
	[metadata key]

	bermudaExerciseDates AdjustableOrRelativeDates (1..1) <"The dates that define the Bermuda option exercise dates and the expiration date. The last specified date is assumed to be the expiration date. The dates can either be specified as a series of explicit dates and associated adjustments or as a series of dates defined relative to another schedule of dates, for example, the calculation period start dates. Where a relative series of dates are defined the first and last possible exercise dates can be separately specified.">
	relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.">
	earliestExerciseTime BusinessCenterTime (1..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) on each Bermuda option exercise date and the expiration date.">
	latestExerciseTime BusinessCenterTime (0..1 ) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
	expirationTime BusinessCenterTime (1..1) <"The latest time for exercise on expirationDate.">
	expirationTimeType ExpirationTimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
	multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
	exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">

type EuropeanExercise: <"A class defining the exercise period for a European style option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
	[metadata key]

	expirationDate AdjustableOrRelativeDate (1..*) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
	relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.">
	earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) on the expiration date.">
	expirationTime BusinessCenterTime (1..1) <"The latest time for exercise on expirationDate.">
	expirationTimeType ExpirationTimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
	partialExercise PartialExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.3. Partial Exercise, the buyer of the option has the right to exercise all or less than all the notional amount of the underlying swap on the expiration date, but may not exercise less than the minimum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
	exerciseFee ExerciseFee (0..1) <"A fee to be paid on exercise. This could be represented as an amount or a rate and notional reference on which to apply the rate.">

type ExerciseFee extends PayerReceiver: <"A class defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

	notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
		[metadata reference]
	feeAmount number (0..1) <"The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.">
	feeRate number (0..1) <"A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.">
	feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

	condition ExerciseFeeChoice: <"Choice rule to represent an FpML choice construct.">
		required choice feeAmount, feeRate

type ExerciseFeeSchedule extends PayerReceiver: <"A class to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

	notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
		[metadata reference]
	feeAmountSchedule AmountSchedule (0..1) <"The exercise fee amount schedule. The fees are expressed as currency amounts. The currency of the fee is assumed to be that of the notional schedule referenced.">
	feeRateSchedule Schedule (0..1) <"The exercise free rate schedule. The fees are expressed as percentage rates of the notional being exercised. The currency of the fee is assumed to be that of the notional schedule referenced.">
	feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">
	
	condition ExerciseFeeScheduleChoice: <"Choice rule to represent an FpML choice construct.">
		required choice feeAmountSchedule, feeRateSchedule

type ExerciseNotice: <"Defines to whom and where notice of execution should be given. The exerciseNoticeGiver refers to one or both of the principal parties of the trade. If present the exerciseNoticeReceiver refers to a party, other than the principal party, to whom notice should be given.">

	exerciseNoticeGiver ExerciseNoticeGiverEnum (1..1) <"Specifies the principal party of the trade that has the right to exercise.">
	exerciseNoticeReceiver AncillaryRoleEnum (0..1) <"Specifies the party to which notice of exercise should be given, e.g. by the buyer of the option. Although in many cases it is the buyer of the option who sends the exercise notice to the seller of the option, this component is reused, e.g. in case of OptionEarlyTermination, either or both parties have the right to exercise.">
	businessCenter BusinessCenterEnum (1..1) <"Specifies the location where the exercise must be reported, e.g. where the exercise notice receiver is based.">
		[metadata scheme]

type ExerciseProcedure: <"A class describing how notice of exercise should be given. This can be either manual or automatic.">

	manualExercise ManualExercise (0..1) <"Specifies that the notice of exercise must be given by the buyer to the seller or seller's agent.">
	automaticExercise AutomaticExercise (0..1) <"If automatic is specified, then the notional amount of the underlying swap not previously exercised under the swaption will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.">
	followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
	limitedRightToConfirm boolean (0..1) <"Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Confirm Exercise. If present, (i) the Seller may request the Buyer to confirm its intent if not done on or before the expiration time on the Expiration date (ii) specific rules will apply in relation to the settlement mode.">
	splitTicket boolean (0..1) <"Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the party required to deliver the bonds will divide those to be delivered as notifying party desires to facilitate delivery obligations.">

	condition ExerciseProcedureChoice: <"Choice rule to represent an FpML choice construct.">
		required choice manualExercise, automaticExercise

type ManualExercise: <"A class defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.">

	exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
	fallbackExercise boolean (0..1) <"If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the swaption, will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than one tenth of a percentage point (0.10% or 0.001). The term in-the-money is assumed to have the meaning defined in the 2000 ISDA Definitions, Section 17.4. In-the-money.">

	condition ManualExerciseNoticeReceiverParty:
		if exerciseNotice -> exerciseNoticeReceiver exists
		then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual

type MultipleExercise extends PartialExercise: <"A class defining multiple exercises. As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more than the maximum notional amount, and if an integral multiple amount is specified, the notional exercised must be equal to or, be an integral multiple of, the integral multiple amount. In FpML, MultipleExercise is built upon the PartialExercise.model.">

	maximumNotionalAmount number (0..1) <"The maximum notional amount that can be exercised on a given exercise date.">
	maximumNumberOfOptions int (0..1) <"The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it means that the maximum number of options corresponds to the remaining unexercised options.">

	condition MaximumChoice: <"Choice rule to represent an FpML choice construct.">
		required choice maximumNotionalAmount, maximumNumberOfOptions

	condition MaximumNumberOfOptions: <"FpML MultipleExercise construct specifies the maximumNumberOfOptions as a positive integer.">
		if maximumNumberOfOptions exists
		then maximumNotionalAmount >= 0

	condition MinimumNumberOfOptions: <"FpML MultipleExercise construct specifies the minimumNumberOfOptions as a positive integer.">
		if minimumNumberOfOptions exists
		then minimumNumberOfOptions >= 0

type PartialExercise: <"A class defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all or less than all the notional amount of the underlying swap but may not be less than the minimum notional amount (if specified) and must be an integral multiple of the integral multiple amount if specified.">

	notionaReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.">
		[metadata reference]
	integralMultipleAmount number (0..1) <"A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.">
	minimumNotionalAmount number (0..1) <"The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.">
	minimumNumberOfOptions int (0..1) <"The minimum number of options that can be exercised on a given exercise date.">

	condition MinimumChoice: <"Choice rule to represent an FpML choice construct.">
		required choice minimumNotionalAmount, minimumNumberOfOptions

type Strike: <"A class describing a single cap or floor rate.">
	[metadata key]

	strikeRate number (1..1) <"The rate for a cap or floor.">
		[synonym FIX_5_0_SP2 value "StrikePrice" tag 202]
	buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
	seller PayerReceiverEnum (0..1) <"The party that has sold.">

type StrikeSchedule extends RateSchedule: <"A class describing a schedule of cap or floor rates.">

	buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
	seller PayerReceiverEnum (0..1) <"The party that has sold.">

type CalculationAgentModel: <"This class corresponds to the FpML CalculationAgent.model.">
	[deprecated]
	
	calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
	calculationAgentBusinessCenter BusinessCenterEnum (0..1) <"The city in which the office through which ISDA Calculation Agent is acting for purposes of the transaction is located. The short-form confirm for a trade that is executed under a Sovereign or Asia-Pacific Master Confirmation Agreement (MCA), does not need to specify the Calculation Agent. However, the confirm does need to specify the Calculation Agent city. This is due to the fact that the MCA sets the value for Calculation Agent but does not set the value for Calculation Agent city.">

type AssetPayout extends PayoutBase: <"Security finance payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction. Plus additional description for ICMA.">
    [metadata key]

    assetLeg AssetLeg (1..*) <"Defines each asset movement as a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    securityInformation Product (1..1) <"Specifies the Purchased Security.  Within SecurityPayout we include a condition which validates that the product must be a Security (see below condition 'ProductMustBeSecurity').">
    durationType Duration (1..1) <"Specifies the Duration Terms of the Security Finance transaction. e.g. Open or Term.">
		[deprecated]
    minimumFee Money (0..1) <"A contractual minimum amount which the borrower will pay, regardless of the duration of the loan. A mechanism for making sure that a trade generates enough income.">
    dividendTerms DividendTerms (0..1) <"Specifies the terms under which dividends received by the borrower are passed through to the lender.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
		priceQuantity exists

	condition ProductMustBeSecurity: <"Validates that the Purchased Security must be a security.">
        securityInformation -> security exists

	condition DividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then the Duration should be Term.">
        if dividendTerms exists
        then durationType -> durationType = DurationTypeEnum -> Term

type DividendTerms: <"Information related to dividends and payments.">
    manufacturedIncomeRequirement DividendPayoutRatio (1..1) <"Specifies the proportion of the value of the dividend on the borrowed shares that the borrower is legally obligated to return to the lender.">
    dividendEntitlement DividendEntitlementEnum (0..1) <"Defines the date on which the receiver of the equity return is entitled to the dividend.">
    minimumBillingAmount Money (0..1) <"daily fee increments accrue until a threshold is crossed, at which point payment becomes due)">

type AssetLeg: <"Defines each asset movement of an asset payout.">
    settlementDate AdjustableOrRelativeDate (1..1) <"Specifies the settlement date of securities.  In a repo transaction the purchase date would always be the effective date as specified under Economic Terms, the repurchase date would always be the termination date as specified under Economic Terms.">
 	deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

type Duration: <"Specifies the Duration Terms of the Security Financing Transaction, and optionally any Evergreen terms.">
    [deprecated]
    durationType DurationTypeEnum (1..1) <"Specifies the Duration Terms of the Security Financing transaction. e.g. Open or Term.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">

type EvergreenProvision: <"Specifies a transaction which automatically extends for a specified timeframe until the exercise of an embedded option.">
	singlePartyOption PartyRole (0..1) <"If evergreen termination is not available to both parties then this component specifies the buyer and seller of the option.">
	noticePeriod RelativeDateOffset (1..1) <"The length of each evergreen extension period relative to the effective date of the preceding contract.">
	noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before an evergreen is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
	noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionFrequency AdjustableRelativeOrPeriodicDates (1..1) <"The frequency with which the evergreen contract will be extended if notice is not given.">
    finalPeriodFeeAdjustment Price (0..1) <"An optional adjustment to the rate for the last period of the evergreen i.e. the period from when notice is given to stop rolling the contract through to the termination date.">

type New2Payout:<"...">
  optionPayout New2OptionPayout (0..1)
  interestRatePayout New2InterestRatePayout (0..1)
  performancePayout New2PerformancePayout (0..1)

type New2PerformancePayout extends New2StructuredPayoutBase:
  [metadata key]
  corePayout NewReturnTerms (0..*)
  multipleCorePayoutAggregationMethod NewObservationConditions (0..1)

  condition MultipleAggregationExists:
  if corePayout count > 1 
  then multipleCorePayoutAggregationMethod->aggregationFeatures exists

type NewReturnTerms:
  priceReturn NewGenericPriceReturn (0..*)
  varianceReturn NewVarianceReturn (0..*)
  volatilityReturn NewVolatilityReturn (0..*)
  correlationReturn NewCorrelationReturn (0..*)
  multipleReturnAggregationMethod NewObservationConditions (0..1)

  condition MultipleAggregationExists:
  if priceReturn count > 1 
  or varianceReturn count > 1 
  or volatilityReturn count > 1 
  or correlationReturn count > 1 
  then multipleReturnAggregationMethod->aggregationFeatures exists

type NewGenericPriceReturn:
  returnRatioMinusStrike NewPriceReturn (1..1)
  strikeMinusReturnRatio NewPriceReturn (0..1)
  structuredFeatures New2StructuredFeatures (0..1)

type New2DifferentialBasis:
  strikeMinusPrice New2StrikeDifferential (0..1)
  priceMinusStrike New2StrikeDifferential (0..1)

  condition : one-of

type New2StrikeDifferential:
  strike NewObservationBasis (1..1)
  observablePrice NewObservationBasis (1..1)

type NewPriceReturn:
  returnRatio NewReturnRatio (1..*)
  returnStrike NewObservationBasis (0..1)
  multipleReturnRatioAggregationMethod NewObservationConditions (0..1)

  condition MultipleRatioExists:
  if returnRatio count > 1 
  then multipleReturnRatioAggregationMethod->aggregationFeatures exists

type NewReturnRatio:
  ratioDenominator NewObservationBasis (1..1)
  ratioNumerator NewObservationBasis (1..1)

type NewVarianceReturn:
  volatilityStrike NewObservationBasis (0..1)
  varianceStrike NewObservationBasis (1..1)
  realisedVariance NewReturnBase (1..1)
  structuredFeatures New2StructuredFeatures (0..1)

type NewVolatilityReturn:
  volatilityStrike NewObservationBasis (1..1)
  realisedVolatility NewReturnBase (1..1)
  structuredFeatures New2StructuredFeatures (0..1)
 
type NewCorrelationReturn:
  correlationStrike NewObservationBasis (1..1)
  realisedCorrelation NewReturnBase (1..1)
  structuredFeatures New2StructuredFeatures (0..1)

type NewReturnBase extends NewObservationBasis:
  naturalLogOfPriceReturn NewReturnRatio (0..*) <"To further custom the type of return involved in the final payout, for the purpose of structuring such return e.g. say the return involved in the realized volatility is made of worst of price basket components prices, or of geometrical means of the basket components prices, etc.">
  squaredNaturalLogOfPriceReturn NewReturnRatio (0..*) <"To further custom the type of return involved in the final payout, for the purpose of structuring such return e.g. say the return involved in the realized volatility is made of worst of price basket components prices, or of geometrical means of the basket components prices.">
  multipleReturnRatioAggregationMethod NewObservationConditions (0..1)
  valuation Valuation (1..1) <"Contains all non-date valuation information.">
  annualizationFactor int (0..1) <"This specifies the numerator of an annualization factor. Frequently this number is equal to the number of observations of prices in a year e.g. 252.">
  dividendApplicability DividendApplicability (0..1) <"The parameters which define whether dividends are applicable">
  equityUnderlierProvisions EquityUnderlierProvisions (0..1) <"Contains Equity Underlyer provisions regarding jurisdiction and fallbacks.">
  sharePriceDividendAdjustment boolean (0..1) <"Indicates whether the price of shares is adjusted for dividends or not.">
  expectedN int (1..1) <"Expected number of trading days.">
  initialLevel number (0..1) <"Contract will strike off this initial level. Providing just the initialLevel without initialLevelSource, infers that this is AgreedInitialPrice - a specified Initial Index Level.">
  initialLevelSource DeterminationMethodEnum (0..1) <"In this context, this is AgreedInitialPrice - a specified Initial Index Level.">
  meanAdjustment boolean (0..1) <"Specifies whether Mean Adjustment is applicable or not in the calculation of the Realized Volatility, Variance or Correlation">
  performance calculation (0..1) <"Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance'. Cumulative performance is used as a notional multiplier factor on both legs of an Equity Swap.">

  condition InitialLevelOrInitialLevelSource: <"At least one of initialLevel and initialLevelSource must be present, or both">
    if initialLevel is absent then initialLevelSource exists
    and if initialLevelSource is absent then initialLevel exists

  condition PositiveExpectedN: <"The number of expected trading dates must be positive">
    expectedN > 0

 condition EitherNaturalOrSquaredFunctionExists :
  optional choice naturalLogOfPriceReturn, squaredNaturalLogOfPriceReturn
 
 condition MultipleReturnRatioAggregationMethod :
    if naturalLogOfPriceReturn exists or squaredNaturalLogOfPriceReturn exists
    then multipleReturnRatioAggregationMethod exists

type New2InterestRatePayout extends New2StructuredPayoutBase:
  [metadata key]
  corePayout NewRateSpecification (0..*) <"The specification of the rate value(s) applicable to the contract using either a floating rate calculation, a single fixed rate, a fixed rate schedule, or an inflation rate calculation.">
  dayCountFraction cdm.base.datetime.daycount.DayCountFractionEnum (0..1) <"The day count fraction. The cardinality has been relaxed when compared with the FpML interest rate swap for the purpose of accommodating standardized credit default swaps which DCF is not explicitly stated as part of the economic terms. The data rule InterestRatePayout_dayCountFraction requires that the DCF be stated for interest rate products.">
  [metadata scheme]
  calculationPeriodDates CalculationPeriodDates (0..1) <"The parameters used to generate the calculation period dates schedule, including the specification of any initial or final stub calculation periods.">
  paymentDelay boolean (0..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">
  resetDates ResetDates (0..1) <"The reset dates schedule, i.e. the dates on which the new observed index value is applied for each period and the interest rate hence begins to accrue.">
  averagingMethod AveragingWeightingMethodEnum (0..1) <"If averaging is applicable, this component specifies whether a weighted or unweighted average method of calculation is to be used. The component must only be included when averaging applies.">
  discountingMethod DiscountingMethod (0..1) <"The parameters specifying any discounting conventions that may apply. This element must only be included if discounting applies.">
  compoundingMethod CompoundingMethodEnum (0..1) <"If one or more calculation period contributes to a single payment amount this element specifies whether compounding is applicable and, if so, what compounding method is to be used. This element must only be included when more than one calculation period contributes to a single payment amount.">
  cashflowRepresentation CashflowRepresentation (0..1) <"The cashflow representation of the swap stream.">
  stubPeriod StubPeriod (0..1) <"The stub calculation period amount parameters. This element must only be included if there is an initial or final stub calculation period. Even then, it must only be included if either the stub references a different floating rate tenor to the regular calculation periods, or if the stub is calculated as a linear interpolation of two different floating rate tenors, or if a specific stub rate or stub amount has been negotiated.">
  bondReference BondReference (0..1) <"Reference to a bond underlier to represent an asset swap or Condition Precedent Bond.">
  fixedAmount calculation (0..1) <"Fixed Amount Calculation">
  floatingAmount calculation (0..1) <"Floating Amount Calculation">
  multipleCorePayoutAggregationMethod NewObservationConditions (0..1)

  condition MultipleAggregationExists:
  if corePayout count > 1 
  then multipleCorePayoutAggregationMethod->aggregationFeatures exists

type New2OptionPayout extends New2StructuredPayoutBase:
 [metadata key]
  optionType NewOptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
  optionStyle OptionStyle (1..1) <"The option exercise can be of American style, Bermuda style or European style. The FpML implementation makes use of a substitution group.">
  corePayout New2OptionExplicitFormula (1..*) <"Generic definition of an optionPayout explicit formula, set out in two types, whether the variable argument depends of a Differential basis or a Performance basis."> 
  exerciseProcedure ExerciseProcedure (1..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">
  underlier Product (1..1) <"The product underlying the option, which can be of any type including ContractualProduct or Security.">
  multipleCorePayoutAggregationMethod NewObservationConditions (0..1)
  
  condition Put:
  if optionType = NewOptionTypeEnum -> Put then corePayout->maxOfZeroAndDifferential->strikeMinusPrice exists or corePayout->maxOfZeroAndReturn->strikeMinusReturnRatio exists

  condition Call:
  if optionType = NewOptionTypeEnum -> Call then corePayout->maxOfZeroAndDifferential->priceMinusStrike exists or corePayout->maxOfZeroAndReturn->returnRatioMinusStrike exists

  condition MultipleAggregationExists:
  if corePayout count > 1 
  then multipleCorePayoutAggregationMethod->aggregationFeatures exists

type New2OptionExplicitFormula: <"Generic definition of an optionPayout explicit formula, set out in two types, whether the variable argument depends of a Differential basis or a Performance basis."> 

  maxOfZeroAndDifferential New2DifferentialBasis (0..1)
  maxOfZeroAndReturn NewGenericPriceReturn (0..1)

  condition : 
  required choice maxOfZeroAndDifferential, maxOfZeroAndReturn

type NewPayoutOrigin : <"Defines the origin to the value as a reference for lineage purposes, whether it originated from trade level settlement terms or from payment terms on an economic payout.">
  optionPayout New2OptionPayout (0..1)
  [metadata reference]
  interestRatePayout New2InterestRatePayout (0..1)
  [metadata reference]
  performancePayout New2PerformancePayout (0..1)
  [metadata reference]

type NewProduct: <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
  [metadata key]

  contractualProduct ContractualProduct (0..1) <"Specifies the contractual product's economic terms, product identifier, and product taxonomy.">
  index Index (0..1) <"Identifies an index by referencing a product identifier.">
  loan Loan (0..1) <"Identifies a loan by referencing a product identifier and an optional set of attributes.">
  commodity Commodity (0..1) <"Identifies a commodity by referencing a product identifier.">
    [metadata address "pointsTo"=Observable->commodity]
  security Security (0..1) <"Identifies a security by referencing a product identifier and a security type, plus an optional set of attributes.">
  basket NewBasket (0..1) <"Identifies a custom basket by referencing a product identifier and its constituents.">
  futuresPriceValuation boolean (0..1) <"When applicable, then the observable price shall be the Official Settlement Price on the relevant derivative market i.e. the Related Exchange. Unless otherwise specified, Futures Price Valuation shall only apply to the Observation End Date.">
  exchange string (0..1) <"Defines the main spot Exchange to look at for any spot price observation related to the observable or underlier product.">
  relatedExchange string (0..*) <"Defines the main Derivatives Exchange to look at for any derivatoves price observation related to the observable or underlier product ; in case multiple would exist, either list them all one by one, else All Exchanges election could be used in regards to relevant ISDA Definitions or any other applicable related documentation that the Trade may refer to.">
  digitalAsset ProductBase (0..1) <"Identifies an digital asset by referencing a product identifier.">

type NewKnock: <"Specifies that an existence condition is attached to the parent object, which means the economic effect of the object is contigent i.e. depending whether the related trigger is knocked. There are two types of existence conditions, either knock-In or Knock-Out : Knock-In means that the Object to which Knock is applicable is deemed not to exist by default i.e. having no economic effect, unless the Knock is activated in accordance with triggerTerms and observationTerms, that resulting in the Object coming into existence ; reversely Knock-Out means that the related Object is deemed to exist by default i.e. having economic effect, unless Knock is activated, that resulting in the object going out of existence, thus loosing any economic effect. The duration of the existence or non-existence of the related Object once the Knock-In or Knock-Out has been activated e.g. knocked once for all or during the knocked day and then reset in previous state, etc. is specified with knockEffectDuration.">

  knockType NewKnockTypeEnum (1..1) <"Specifies whether effect of the Knock trigger being met is to activate i.e. when Knock-In or to disactivate i.e. when Knock-Out the Object to which the Knock is relative to.">
  triggerTerms NewTriggerTerms (1..*) <"Specifies the criteria for determining whether the triggerLevel is deemed to have been knocked or not by the observable value.">
  observationTerms NewObservationBasis (1..1) <"The basic set of terms for an observation to be defined in an exhaustive manner the Observable defines WHAT is observed, the observationDates defines WHEN the observation shall occurr and the observationConditions further define HOW the observation shall be made.">
  knockEffectDuration Frequency (1..1) <"The duration of the existence or non-existence of the related Object once the Knock-In or Knock-Out has been activated e.g. 1T standing for 1 'Term' would indicate a 'one touch' effect that is to say if knocked once, this means once for all until trade is terminated, else 1D would indicate the effect exists for the knocking day only, then this coupled with a daily observation would correspond to daily knock being reset e.g. that would represent the same as bounded variance involved in corridor varswap as an example, etc.">
//   knockEffectDurationType NewEffectivenessDurationType (1..1) <"The duration of the existence or non-existence of the related Object once the Knock-In or Knock-Out has been activated e.g. knocked once for all or during the knocked day and then reset in previous state, etc.">

type NewTriggerTerms : <"Specifies the criteria for determining whether the triggerLevel is deemed to have been knocked or not by the observable value.">
  triggerLevel NewObservableValue (1..1)
  coreObservableTriggerCondition TriggerTypeEnum (1..1) <"Specifies the criteria for determining whether the triggerLevel is deemed to have been knocked or not by the observable value.">
  multipleObservableTriggerCondition NewMultipleObservableConditionEnum (0..1) <"Further specifies the coreObservableCondition when multiple observable values shall be taken into account for determining whether the triggerLevel is deemed to have been knocked or not.">

type New2StructuredPayoutBase extends PayoutBase : 
  //[metadata key]
  valuationTerms ValuationDates (1..1) <"Defines how and when a performance type option or performance type swap is to be valued, including both interim and final valuation dates.">
  observationTerms NewObservationBasis (1..1) <"The basic set of terms to define the observation of a value : the Observable defines WHAT is observed, the observationDates defines WHEN the observation shall occurr ; and the observationConditions further define HOW the observation shall be made.">
  paymentTerms PaymentDates (1..1) <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
  fxFeature FxFeature (0..*) <"Specifies whether FX Feature embedded in the Payout Leg applies to the related Payout as Composite or Quanto or CrossCurrency. ">
  structuredFeatures New2StructuredFeatures (0..1) <"Define a core set of optional features for structuring the Payout e.g. make its existence contigent via knockCondition, bounds its value via capFloorBarrier, leverage its value via multipler or delevrage it via divisor .">

type NewSpreadRateReturn:
  longPositionRate NewRateSpecification (1..1)
  shortPositiontRate NewRateSpecification (1..1)
  structuredFeatures New2StructuredFeatures (0..1)

type NewBasket extends ProductBase: <"Defines a custom basket by referencing a product identifier and its consituents.">
  basketConstituent NewObservable (1..*) <"Identifies the constituents of the basket">

type New2Ratio:
  ratioDenominator New3ObservationBasis (1..1)
  ratioNumerator New3ObservationBasis (1..1)
  structuredFeatures New2StructuredFeatures (0..1)

type New2ObservationBasis extends NewObservationBasis:
  structuredFeatures New2StructuredFeatures (0..1)

type New3ObservationBasis extends New2ObservationBasis:
  genericPayout New2StructuredPayout (0..1)

  condition : 
  required choice observableValue, genericPayout

type New2CumulativeKnock:
  cumulativeKnockCondition New2Knock (0..*)

type New2Knock extends NewKnock:<"Specifies that an existence condition is attached to the parent object, which means the economic effect of the object is contigent i.e. depending whether the related trigger is knocked.">
  cumulativeKnockCondition New2Knock (0..*) <"Defines additional Knock Conditions which are cumulative in regards of the root parent Knock Condition i.e. respective triggers for both Knock Conditions, the root one and the cumulative one, must be met for the purpose of having an effect. From a logical perspective, a cumulativeKnockCondition has the meaning of an 'AND' condition. As an indication, for the purpose of defining additional Knock Conditions with logical meaning of an 'OR' condition i.e. either is sufficient to have an effect, one should define multiple Knock at the same root level.">

type New2Multiplier extends New2ObservationBasis:
  dayCountFraction cdm.base.datetime.daycount.DayCountFractionEnum (0..1) <"The multiplier value is the dayCountFraction.">
  numberOfDaysInObservationPeriod boolean (0..1) <"The multiplier value is the number of days observed in the relevant Observation Period.">
  numberOfKnockedObservations int (0..1) <"The multiplier value is the number of times a Knock Condition is met.">

 condition MultiplierValueIsFixedOrObservable:
 required choice observableValue, dayCountFraction, numberOfDaysInObservationPeriod, numberOfKnockedObservations

  condition KnockedObservations:
  if numberOfKnockedObservations exists 
  then structuredFeatures -> knockCondition exists

type New2AggregationFeatures: <"The basic mathematical commutative functions, to represent the calculation method for aggregating multiple values into a single value, either per time series or per observable series.">
  datesAggregationPerGivenObservable NewBasicCommutativeFunctionsEnum (0..1) <"The calculation method per time series i.e. for aggregating multiple dated values into a single value, per each given observable.">
  observablesAggregationPerGivenDate NewBasicCommutativeFunctionsEnum (0..1) <"The calculation method per observable series i.e. for aggregating multiple observable values into a single value, per each given observation date.">
  averagingMethod AveragingCalculationMethod (0..1) <"Defines the ways in which multiple values can be aggregated into a single value.">
  rankingAggregationPerGivenDate NewRankingMethod (0..1) <"Defines that one or several values shall be selected in regards of their rank in the value series e.g. the 2nd and/or the 3rd and/or the 'nth' when sorting either from lowest to the highest value in the series, or vice-versa.">
  
  condition AveragingMethodologyExists :
  if datesAggregationPerGivenObservable = NewBasicCommutativeFunctionsEnum -> Average
  or observablesAggregationPerGivenDate = NewBasicCommutativeFunctionsEnum -> Average
  then averagingMethod exists

  condition OnlyOneMethodExists:
  optional choice rankingAggregationPerGivenDate, observablesAggregationPerGivenDate, datesAggregationPerGivenObservable

type NewRankingMethod : <"Defines that one or several values shall be selected in regards of their rank in the value series e.g. the 2nd and/or the 3rd and/or the 'nth' when sorting either from lowest to the highest value in the series, or vice-versa.">
  nthFromMinToMax int (0..*) <"Defines that one or several values shall be selected if being the 'nth' value, when sorting it from the lowest to the highest value in the series">
  nthFromMaxToMin int (0..*) <"Defines that one or several values shall be selected if being the 'nth' value, when sorting it from the highest to the lowest value in the series">

type NewRebalancing:
  rebalancingConditions New2Knock (1..*)
  rebalancingEffectiveDates AdjustableRelativeOrPeriodicDates (1..1)

type New2StructuredPayout extends New2StructuredPayoutBase:
  denominatorValue New2StructuredPayout (0..*)
  numeratorValue New2StructuredPayout (0..*)
  denominatorAggregation NewObservationConditions (0..1)
  numeratorAggregation NewObservationConditions (0..1)
  ratioAggregation NewObservationConditions (0..1)

type New2StructuredFeatures: <"Define a core set of optional features for structuring the parent object e.g. make its existence contigent via knockCondition, bounds its value via capFloorBarrier, leverage its value via multipler or delevrage it via divisor .">
  knockCondition New2Knock (0..*) <"Specifies that the parent object is contigent i.e. is deemed to exist (or not to exist) by default until the trigger is knocked Out (or knocked In). For clarity, Knock-In means that the Object to which Knock is applicable is deemed not to exist by default i.e. having no economic effect, unless the Knock is activated in accordance with triggerTerms and observationTerms, that resulting in the Object coming into existence ; reversely Knock-Out means that the related Object is deemed to exist by default i.e. having economic effect, unless Knock is activated, that resulting in the object going out of existence, thus loosing any economic effect. The duration of the existence or non-existence of the related Object once the Knock-In or Knock-Out has been activated e.g. knocked once for all or during the knocked day and then reset in previous state, etc. is specified with knockEffectDuration.">
  capFloorBarrier NewBarrier (0..*) <"Specifies that the parent object value is bounded as a lowest level when barrierType is a Floor, else as a highest level when it is a Cap. For clarity, a Cap represents a function which resulting value is the Minimum between the barrierLevel and the value of the related Object ; a Floor represents a function which resulting value is the Maximum between the barrierLevel and the value of the related Object.">
  multiplier New2Multiplier (0..*)
  divisor New2Multiplier (0..*)

type NewBarrier: <"Defines a function which resulting value is bounded as a lowest level when barrierType is a Floor, else as a highest level when it is a Cap. For clarity, a Cap represents a function which resulting value is the Minimum between the barrierLevel and the value of the related Object ; reversely a Floor represents a function which resulting value is the Maximum between the barrierLevel and the value of the related Object.">
	barrierType CapFloorEnum (1..1) <"The enumerated values to specify whether the barrierLevel is a Cap or Floor : ">
	barrierLevel NewObservationBasis (1..1) <"The value of the Cap or Floor level.">
	barrierKnockCondition NewKnock (0..1) <"Specifies whether a Knock Condition is attached to the Barrier, which means economic effect of the Barrier is contigent i.e. depending whether the related trigger is knocked.">




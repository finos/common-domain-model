namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.*
import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*

import cdm.observable.event.*
import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.event.common.*

import cdm.product.asset.*
import cdm.product.common.*
import cdm.product.common.settlement.*
import cdm.product.common.schedule.*
import cdm.product.qualification.*
import cdm.product.collateral.*

import cdm.mapping.config.*

type ContractualProduct extends ProductBase: <" A class to specify the contractual products' economic terms, alongside their product identification and product taxonomy. The contractual product class is meant to be used across the pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
    [metadata key]
    [metadata template]

    economicTerms EconomicTerms (1..1) <"The economic terms associated with a contractual product, i.e. the set of features that are price-forming.">

    condition PrimaryAssetClass: <"Specifies that when nonStandardisedTerms are True that a primary asset class must be specified.">
        if economicTerms -> nonStandardisedTerms = True
        then productTaxonomy -> primaryAssetClass exists

type EconomicTerms: <" This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, the effective and termination date and the date adjustment provisions when applying uniformily across the payout components. This class also includes the legal provisions which have valuation implications: cancelable provision, extendible provision, early termination provision and extraordinary events specification.">

    effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
        [docReference ICMA GMRA namingConvention "Purchase Date"
            provision "As defined in GMRA paragraph 2(mm) The date on which Purchased Securities are sold or are to be sold by Seller to Buyer."]
        [docReference ICMA ERCCBestPractice namingConvention "Purchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the value date of a repo."]
    terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
        [docReference ICMA GMRA namingConvention "Repurchase Date"
            provision "As defined in GMRA paragraph 2(qq) The date on which Buyer is to sell Equivalent Securities to Seller."]
        [docReference ICMA ERCCBestPractice namingConvention "Repurchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the maturity date of a repo."]
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day adjustment convention when it applies across all the payout components. This specification of the business day convention and financial business centers is used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
    payout Payout (1..1) <"The payout specifies the future cashflow computation methodology which characterizes a financial product.">
    terminationProvision TerminationProvision (0..1) <"Contains optional provisions pertaining to the termination characteristics of a contract.">
    calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
    nonStandardisedTerms boolean (0..1) <"Specifies, when boolean value is True, that additional economic terms exist that have not been included in the product representation.">
    // ICMA-P2
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">

    condition FpML_cd_26_28: <"FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate. This data rule tackles those two FpML validation rules at once, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute.">
        if payout -> creditDefaultPayout exists
                and payout -> cashflow exists
                and effectiveDate exists
                and payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate exists
                and payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate is absent
        then payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate all > effectiveDate -> adjustableDate -> unadjustedDate or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> adjustedDate all > effectiveDate -> adjustableDate -> adjustedDate or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate -> adjustedDate all > effectiveDate -> relativeDate -> adjustedDate

    condition FpML_cd_27: <"FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        if payout -> creditDefaultPayout exists
                and payout -> cashflow exists
                and terminationDate exists
                and payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate all < terminationDate -> adjustableDate -> unadjustedDate or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> adjustedDate all < terminationDate -> adjustableDate -> adjustedDate or payout -> cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate -> adjustedDate all < terminationDate -> adjustableDate -> adjustedDate

    condition FpML_cd_30: <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        if payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and terminationDate exists
        then payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> unadjustedDate

    condition IndependentCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentIndependent

    condition AssetPayoutDividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then it should be a Term trade.">
        if payout -> assetPayout -> dividendTerms exists
        then terminationDate exists

    condition ExtendibleProvisionExerciseDetails: <"Ensure that the correct details are specified for an extendible contract.">
        if payout -> assetPayout is absent
        then // Not Security Lending/Repo so must be Interest Rate Swap, which must set an exercise option type
            if terminationProvision -> extendibleProvision exists
            then (terminationProvision -> extendibleProvision -> americanExercise exists
                        and terminationProvision -> extendibleProvision -> bermudaExercise is absent
                        and terminationProvision -> extendibleProvision -> europeanExercise is absent)
                    or (terminationProvision -> extendibleProvision -> americanExercise is absent
                        and terminationProvision -> extendibleProvision -> bermudaExercise exists
                        and terminationProvision -> extendibleProvision -> europeanExercise is absent)
                    or (terminationProvision -> extendibleProvision -> americanExercise is absent
                        and terminationProvision -> extendibleProvision -> bermudaExercise is absent
                        and terminationProvision -> extendibleProvision -> europeanExercise exists)
                        and terminationProvision -> extendibleProvision -> followUpConfirmation exists

type OptionExercise: <" A class to represent the applicable terms to qualify an option exercise: the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">

    optionStyle OptionStyle (1..1) <"The option exercise can be of American style, Bermuda style or European style. The FpML implementation makes use of a substitution group.">
    strike OptionStrike (0..1) <"Specifies the strike of the option on credit default swap.">
    exerciseProcedure ExerciseProcedure (0..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">

type OptionPayout extends PayoutBase: <" The option payout specification terms. The associated globalKey denotes the ability to associate a hash value to the respective OptionPayout instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    [metadata key]

    buyerSeller BuyerSeller (1..1)
    optionType OptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
    feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">
    exerciseTerms OptionExercise (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
    underlier Product (1..1) <"The product underlying the option, which can be of any type including ContractualProduct or Security.">
    observationTerms ObservationTerms (0..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. To be used for option contracts that reference a benchmark price.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">

    condition ClearedPhysicalSettlementExists:
        if settlementTerms -> physicalSettlementTerms exists
                and underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout only exists
                and underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2
        then settlementTerms -> physicalSettlementTerms -> clearedPhysicalSettlement exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

type SecurityLeg: <" Terms defining a security leg in a securities financing transaction, which can either be the near leg or the far leg and is closely modelled onto the nearLeg and farLeg types in FpML">
    [metadata key]

    buyerSeller BuyerSeller (1..1) <"Whether the leg is a buyer or seller of security">
    settlementDate AdjustableOrRelativeDate (1..1) <"Settlement or Payment Date for the security leg">
    settlementAmount Money (0..1) <"Settlement amount for the security leg">
    settlementCurrency string (0..1) <"Settlement Currency for use where the Settlement Amount cannot be known in advance.">
    fxRate ExchangeRate (0..1) <"FX rate in case when cash settlement amount is in a different currency to the security.">
    deliveryDate AdjustableOrRelativeDate (0..1) <"Delivery Date for the transaction. Delivery Date can be populated when it is not equal to the Settlement Date.">
    deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

    condition SecurityLegChoice:
        required choice settlementAmount, settlementCurrency

type SecurityPayout: <" Security payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction.">
    [metadata key]
    [deprecated]

    securityLeg SecurityLeg (1..*) <"Each SecurityLeg represent a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    initialMargin InitialMargin (0..1) <"RepoDurationEnum.">
    repoDuration RepoDurationEnum (0..1) <"A duration code for the repo transaction. This defines a type of a repo transaction with fixed duration.">
    securityValuation SecurityValuation (1..*) <"The underlying securities and their valuation for the security leg.">

type InitialMargin: <" Defines initial margin applied to a repo transaction. Initial margin is an agreed premium to the Purchase Price of a repo to determine the required Market Value of the collateral to be delivered on the Purchase Date. It reflects quality of the collateral. Its aim is to calculate the risk-adjusted or liquidation value of collateral.">
    [deprecated]

    marginType MarginTypeEnum (1..1) <"An element defining the type of assets (cash or securities) specified to apply as margin to the repo transaction. See GMRA 2011 paragraph 2(h) for 'Cash Margin' and GMRA 2011 paragraph 2(cc) for 'Margin Securities'.">
    margin InitialMarginCalculation (1..*) <"Initial margin calculation for a collateral asset. Initial margin requirements may be specified for multiple pieces of collateral.">
    marginThreshold Money (0..1) <"An element defining a margin threshold which is the Net Exposure of a trade below which parties agree they will not call a margin from each other.">
    minimumTransferAmount Money (0..1) <"An element defining a minimum transfer amount which is the minimum margin call parties will make once the margin threshold (or margin ratio threshold / haircut threshold) has been exceeded.">

    condition MarginThreshold:
        if marginThreshold exists then marginThreshold -> value > 0

    condition MinimumTransferAmount:
        if minimumTransferAmount exists
        then minimumTransferAmount -> value > 0

type InitialMarginCalculation: <" Defines the initial margin calculation applicable to a single piece of collateral.">
    [deprecated]

    marginRatio number (0..1) <"An element defining an initial margin expressed as a ratio of the Market Value of the collateral to the Purchase Price. A default value of initial margin ratio of 1.00 means there is no margin and thus no risk related with the collateral. See GMRA 2000 paragraph 2(z) and GMRA 2011 paragraph 2(bb).">
    marginRatioThreshold number (0..2) <"An element defining a margin ratio threshold which is the value above (when it's lower than initial margin ratio) or below (when it's higher than initial margin ratio) which parties agree they will not call a margin from each other.">
    haircut number (0..1) <"An element defining a haircut expressed as the percentage difference between the Market Value of the collateral and the Purchase Price of the repo and calculated as 100 multiplied by a ratio of the difference between the Market Value of the collateral and the Purchase Price of the repo to the Market Value of the collateral. Haircut is alternative way to adjust the value of collateral sold in a repurchase agreement to initial margin ratio. Because an initial margin is a percentage of the Purchase Price, while a haircut is a percentage of the Market Value of collateral, the arithmetic of initial margins and haircuts is slightly different. For example, an initial margin of 102% is not equivalent to a haircut of 2%, but to 1.961% (ie 100/102%). See GMRA 2011 paragraph 2(aa).">
    haircutThreshold number (0..2) <"An element defining a haircut percentage threshold which is the value above (when it's lower than initial haircut) or below (when it's higher than initial haircut) which parties agree they will not call a margin from each other.">

    condition InitialMarginCalculationChoice:
        required choice marginRatio, haircut

type ReturnTerms: <"Specifies the type of return of a performance payout.">

    // commodityReturnTerms CommodityPriceReturnTerms (0..1)
    priceReturnTerms PriceReturnTerms (0..1) <"Return terms based upon the underlier's observed price.">
    dividendReturnTerms DividendReturnTerms (0..1) <"Return terms based upon dividend payments associated to the underlier.">
    varianceReturnTerms VarianceReturnTerms (0..1) <"Return terms based upon the observed variance of the underlier's price.">
    volatilityReturnTerms VolatilityReturnTerms (0..1) <"Return terms based upon the observed volatility of the underlier's price.">
    correlationReturnTerms CorrelationReturnTerms (0..1) <"Return terms based upon the observed correlation between the components of the underlying basket.">

    condition ReturnTermsExists: <"Checks that the return type label matches the actual return terms structure of the product.">
        if priceReturnTerms -> returnType = ReturnTypeEnum -> Total
        then (priceReturnTerms, dividendReturnTerms) only exists
        else if priceReturnTerms -> returnType = ReturnTypeEnum -> Price
        then priceReturnTerms only exists
        else priceReturnTerms only exists
            or dividendReturnTerms only exists
            or varianceReturnTerms only exists
            or volatilityReturnTerms only exists
            or correlationReturnTerms only exists

type PerformancePayout extends PayoutBase: <"Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation products.">
    [metadata key]

    observationTerms ObservationTerms (0..1) <"Defines how and when a performance type option or performance type swap is to be observed.">
    valuationDates ValuationDates (1..1) <"Defines how and when a performance type option or performance type swap is to be valued, including both interim and final valuation.">
    paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
    underlier Product (0..1) <"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
    fxFeature FxFeature (0..*) <"Defines quanto or composite FX features that are included in the swap leg.">
    returnTerms ReturnTerms (1..1) <"Specifies the type of return of a performance payout.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition NoSharePriceDividendAdjustmentIndex: <"If the underlier is an index, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> index exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition NoSharePriceDividendAdjustmentForeignExchange: <"If the underlier is an foreign exchange, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> foreignExchange exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition CorrelationUnderlierOnlyBasket: <"Correlation Return Terms can only have a basket as underlier, since it needs to compute the correlation between two or more products.">
        if returnTerms -> correlationReturnTerms exists
        then underlier -> basket only exists

    condition EquitySpecificAttributes: <"Equity specific attributes cannot be present in non-equity products.">
        if Qualify_UnderlierProduct_Equity(underlier) = False
        then returnTerms -> varianceReturnTerms -> dividendApplicability is absent
                and returnTerms -> varianceReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> dividendApplicability is absent
                and returnTerms -> volatilityReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> correlationReturnTerms -> dividendApplicability is absent
                and returnTerms -> correlationReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> correlationReturnTerms -> sharePriceDividendAdjustment is absent

// condition UnderlierOrObservable: <"The Performance Payout must reference either an underlier or an observable">
// underlier exists
// or
// ObservationTerms -> observable exists
type Payout: <"A class to represent the set of future cashflow methodologies in the form of specific payout class(es) that can be associated for the purpose of specifying a financial product. For example, two interest rate payouts can be combined to specify an interest rate swap, or one interest rate payout can be combined with a credit default payout to specify a credit default swap.">
    [metadata key]

    interestRatePayout InterestRatePayout (0..*) <"All of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg).">
    creditDefaultPayout CreditDefaultPayout (0..1) <"The credit default payout, which provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms.">
    optionPayout OptionPayout (0..*) <"The option payout.">
    commodityPayout CommodityPayout (0..*) <"Defines the payout for the floating leg of a Commodity Swap.">
    forwardPayout ForwardPayout (0..*) <"Represents a forward settling payout. The 'Underlier' attribute captures the underlying payout, which is settled according to the 'SettlementTerms' attribute. Both FX Spot and FX Forward should use this component.">
    fixedPricePayout FixedPricePayout (0..*) <"Defines a payout in which one or more payouts are defined as a fixed price.">
    securityPayout SecurityPayout (0..*) <"The security payout when the product involves some form of securities, such as collateral in a securities financing transaction">
        [deprecated]
    cashflow Cashflow (0..*) <"A cashflow between the parties to the trade. For interest rate and equity products, this corresponds to the FpML additionalPayment element. For credit default swaps, this corresponds to the FpML initialPayment element and the singlePayment element of the fee leg. For option products, it represents the FpML premium element.">
    performancePayout PerformancePayout (0..*) <"The performance payout, which encompasses the equity price returns, dividend returns, volatility return, variance return and correlation provisions.">
    assetPayout AssetPayout (0..*) <"The security payout when the product involves some form of securities, such as collateral in a securities financing transaction">

    condition ReturnType_Total_Requires_Dividends: <"A total return implies both a price and a dividend return">
        if performancePayout -> returnTerms -> priceReturnTerms -> returnType all = ReturnTypeEnum -> Total
        then performancePayout -> returnTerms -> dividendReturnTerms exists

    condition LastRegularPaymentDate: <"FpML specifies that lastRegularPaymentDate must only be included if there is a final stub. As part of the CDM, this data rule has been adjusted to specify that it only applies to interest rate swaps, as the credit derivatives products can have a specified lastRegularPaymentDate while the stub is typically not applicable to those.">
        if interestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and interestRatePayout -> stubPeriod -> finalStub exists
        then interestRatePayout count = 2

    condition PayRelativeTo: <"FpML specifies a required payRelativeTo element as part of the PaymentDates. As standardized CDS don't have such payRelativeTo provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if interestRatePayout count = 2 and interestRatePayout -> paymentDates exists
        then interestRatePayout -> paymentDates -> payRelativeTo exists

    condition PaymentDatesAdjustments: <"FpML specifies a required paymentDatesAdjustments element as part of the PaymentDates. As standardized CDS don't have such paymentDatesAdjustments provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if interestRatePayout count = 2 and interestRatePayout -> paymentDates exists
        then interestRatePayout -> paymentDates -> paymentDatesAdjustments exists

    condition PaymentFrequency: <"FpML specifies a required paymentFrequency element as part of the PaymentDates. As standardized CDS may not have such paymentFrequency provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if interestRatePayout count = 2 and interestRatePayout -> paymentDates exists
        then interestRatePayout -> paymentDates -> paymentFrequency exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        if optionPayout exists
        then optionPayout -> priceQuantity exists
                or optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2

    condition DayCountFraction: <"FpML specifies a required dayCountFraction element as part of the swapStream/calculationPeriodAmount/calculation. As standardized CDS don't have such specified day count fraction, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if interestRatePayout count = 2
        then interestRatePayout -> dayCountFraction exists

    condition PaymentDates: <"FpML specifies a required paymentDates element as part of the swapStream. As standardized CDS may not have specified payment dates, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if interestRatePayout count = 2
        then interestRatePayout -> dayCountFraction exists

    condition MarketPrice: <"FpML specifies that marketFixedRate and marketPrice only have meaning in a credit index trade">
        if creditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
        then creditDefaultPayout -> transactedPrice -> marketFixedRate is absent
                and creditDefaultPayout -> transactedPrice -> marketPrice is absent

    condition NotionalResetOnPerformancePayout: <"Notional reset only applies to return swaps, and therefore can only exist on an performancePayout.">
        interestRatePayout -> priceQuantity -> reset is absent
            and creditDefaultPayout -> priceQuantity -> reset is absent
            and optionPayout -> priceQuantity -> reset is absent
            and cashflow -> priceQuantity -> reset is absent

    condition NotionalResetInterestRatePayoutExists: <"As the performancePayout->payoutQuantity->reset attribute applies to return swaps, the interestRatePayout needs to be present alongside it.">
        if performancePayout -> priceQuantity -> reset contains True
        then interestRatePayout exists

type Product: <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
    [metadata key]

    contractualProduct ContractualProduct (0..1) <"Specifies the contractual product's economic terms, product identifier, and product taxonomy.">
    index Index (0..1) <"Identifies an index by referencing a product identifier.">
    loan Loan (0..1) <"Identifies a loan by referencing a product identifier and an optional set of attributes.">
    assetPool AssetPool (0..1) <"Identifies an asset pool product for defining pool of assets backing an asset backed security.">
    foreignExchange ForeignExchange (0..1) <"Defines a foreign exchange spot or forward transaction.">
    commodity Commodity (0..1) <"Identifies a commodity by referencing a product identifier.">
        [metadata address "pointsTo"=Observable->commodity]
    security Security (0..1) <"Identifies a security by referencing a product identifier and a security type, plus an optional set of attributes.">
    basket Basket (0..1) <"Identifies a custom basket by referencing a product identifier and its constituents.">

    condition:
        one-of

type Basket extends ProductBase: <"Defines a custom basket by referencing a product identifier and its consituents.">
    basketConstituent Product (1..*) <"Identifies the constituents of the basket">

type TradeLot: <"Specifies the price and quantity of a trade lot, where the same product could be traded multiple times with the same counterparty but in different lots (at a different date, in a different quantity and at a different price). One trade lot combined with a product definition specifies the entire economics of a trade. The lifecycle mechanics of each such trade lot (e.g. cashflow payments) is independent of the other lots.">
    lotIdentifier Identifier (0..*) <"Specifies one or more identifiers for the lot, if any.">
    priceQuantity PriceQuantity (1..*) <"Specifies the settlement characteristics of a trade lot: price, quantity, observable (optionally) and the settlement terms. This attribute has a multiple cardinality to allow to specify the price, quantity and observable of different legs in a single, composite product (e.g. a Swap).">

type TradableProduct: <"Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this product plus an (optional) mechanism for any potential future quantity adjustment.">

    product Product (1..1) <"The underlying product to be included in a contract or execution.">
    tradeLot TradeLot (1..*) <"Specifies the price, quantity and effective date of each trade lot, when the same product may be traded multiple times in different lots with the same counterparty. In a trade increase, a new trade lot is added to the list, with the corresponding effective date. In a trade decrease, the existing trade lot(s) are decreased of the corresponding quantity (and an unwind fee may have to be settled). The multiple cardinality and the ability to increase existing trades is used for Equity Swaps in particular.">
    counterparty Counterparty (2..2) <"Specifies the parties which are the two counterparties to the transaction.  The product is agnostic to the actual parties to the transaction, with the party references abstracted away from the product definition and replaced by the counterparty enum (e.g. CounterpartyEnum values Party1 or Party2). The counterparty enum can then be positioned in the product (e.g. to specify which counterparty is the payer, receiver etc) and this counterparties attribute, which is positioned outside of the product definition, allows the counterparty enum to be associated with an actual party reference.">
        [docReference ICMA GMRA namingConvention "Party"
            provision "Parties entering into GMRA, as specified on page 1 of the GMRA and under 1. (a)."]
    ancillaryParty AncillaryParty (0..*) <"Specifies the parties with ancillary roles in the transaction. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and this AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">
    adjustment NotionalAdjustmentEnum (0..1) <"Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfolio rebalancing etc. It is typically used in the context of Equity Swaps.">

    condition PriceQuantityTriangulation: <"Check PriceQuantity triangulation for each TradeLot.">
        PriceQuantityTriangulation(tradeLot) = True

    condition NotionalAdjustment: <"As the adjustment attribute applies to return swaps, the equity payout needs to be present alongside it.">
        if adjustment exists
        then product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> priceReturnTerms exists
                or product -> contractualProduct -> economicTerms -> payout -> performancePayout exists

    condition PerformancePayout_ExtraordinaryDividendsParty:
        if product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                    then product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists

    condition OptionPayout_PredeterminedClearingOrganizationParty:
        if product -> contractualProduct -> economicTerms -> payout -> optionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition ForwardPayout_PredeterminedClearingOrganizationParty:
        if product -> contractualProduct -> economicTerms -> payout -> forwardPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition PredeterminedClearingOrganizationParty:
        if ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty
        then product -> contractualProduct -> economicTerms -> payout -> forwardPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
                or product -> contractualProduct -> economicTerms -> payout -> optionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists

    condition ExerciseNoticeReceiverPartyManual:
        if product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                    then product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyOptionalEarlyTermination:
        if product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                    then product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyCancelableProvision:
        if product -> contractualProduct -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                    then product -> contractualProduct -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyExtendibleProvision:
        if product -> contractualProduct -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                    then product -> contractualProduct -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition CalculationAgentIndependent:
        if product -> contractualProduct -> economicTerms -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                    then product -> contractualProduct -> economicTerms -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentOptionalEarlyTermination:
        if product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                    then product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentMandatoryEarlyTermination:
        if product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                    then product -> contractualProduct -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists

type ConstituentWeight: <"A class describing the weight of each of the underlier constituent within the basket, either in absolute or relative terms.">

    openUnits number (0..1) <"The number of units (index or securities) that constitute the underlier of the swap. In the case of a basket swap, this element is used to reference both the number of basket units, and the number of each asset components of the basket when these are expressed in absolute terms.">
    basketPercentage number (0..1) <"The relative weight of each respective basket constituent, expressed in percentage. A basket percentage of 5% would be represented as 0.05.">

    condition BasketPercentage: <"FpML specifies basketPercentage as a RestrictedPercentage type, meaning that the value needs to be comprised between 0 and 1.">
        if basketPercentage exists
        then basketPercentage >= 0.0 and basketPercentage <= 1.0

type ForwardPayout extends PayoutBase: <"Represents a forward settling payout. The underlier attribute captures the underlying payout, which is settled according to the settlementTerms attribute (which is part of PayoutBase). Both FX Spot and FX Forward should use this component.">
    [metadata key]

    underlier Product (1..1) <"Underlying product that the forward is written on, which can be of any type: FX, a contractual product, a security, etc.">
    deliveryTerm string (0..1) <"Also called contract month or delivery month. However, it's not always a month. It is usually expressed using a code, e.g. Z23 would be the Dec 2023 contract, (Z = December). For crude oil, the corresponding contract might be called CLZ23.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition SettlementTerms: <"For foreign exchange contracts, the settlement terms must exist.">
        if underlier -> foreignExchange exists
        then settlementTerms exists

    condition SettlementDate: <"For foreign exchange contracts, either the settlementDate is set or the cashflowDates, but not both. When the cashflowDates are set, they must be the same for the 2 legs of the currency pair.">
        if underlier -> foreignExchange exists
        then (settlementTerms -> settlementDate -> valueDate exists
                    and underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate is absent
                    and underlier -> foreignExchange -> exchangedCurrency2 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate is absent)
                or (settlementTerms -> settlementDate -> valueDate is absent
                    and underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
                    and underlier -> foreignExchange -> exchangedCurrency2 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
                    and underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate = underlier -> foreignExchange -> exchangedCurrency2 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate)

    condition FxSettlement: <"For foreign exchange contracts, the settlement type must be either fx non-deliverable settlement or not specified, which implies physical settlement in the case of foreign exchange.">
        if underlier -> foreignExchange exists
        then settlementTerms -> physicalSettlementTerms is absent

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

type CalculationSchedule: <"A class that allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    schedulePeriod SchedulePeriod (1..*) <"Defines a period of a calculation schedule structure.">

type SchedulePeriod: <"A class that defines the period of a schedule. The period contains a set of start and end dates, quantities, fixing, and pricing data.">
    calculationPeriod DateRange (1..1) <"Period for which the payment is generated.">
    paymentDate date (1..1) <"Adjusted payment date.">
    fixingPeriod DateRange (1..1) <"Period over which the underlying price is observed.">
    deliveryPeriod CalculationScheduleDeliveryPeriods (0..1) <"Period and time profile over which the delivery takes place.">

type FixedPricePayout extends PayoutBase: <"Represents a fixed price payout. There is no underlier associated with this payout type and is based on fixed pricing per a given unit (e.g. in commodities price per barrel)">
    [metadata key]

    paymentDates PaymentDates (1..1) <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
    fixedPrice FixedPrice (1..1) <"Specifies the fixed price on which fixed forward payments are based.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

type CancelableProvision extends BuyerSeller: <"A data defining:  the right of a party to cancel a swap transaction on the specified exercise dates. The provision is for 'walk-away' cancellation (i.e. the fair value of the swap is not paid). A fee payable on exercise can be specified. As a difference from the FpML construct, the canonical model extends the BuyerSeller class.">

    americanExercise AmericanExercise (0..1) <"American exercise. FpML implementations consists in an exercise substitution group.">
    bermudaExercise BermudaExercise (0..1) <"Bermuda exercise. FpML implementations consists in an exercise substitution group.">
    europeanExercise EuropeanExercise (0..1) <"European exercise. FpML implementations consists in an exercise substitution group.">
    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    cancelableProvisionAdjustedDates CancelableProvisionAdjustedDates (0..1) <"The adjusted dates associated with a cancelable provision. These dates have been adjusted for any applicable business day convention.">
    finalCalculationPeriodDateAdjustment FinalCalculationPeriodDateAdjustment (0..*) <"Business date convention adjustment to final payment period per leg (swapStream) upon exercise event. The adjustments can be made in-line with leg level BDC's or they can be specified separately.">
    initialFee Transfer (0..1) <"An initial fee for the cancelable option.">
    callingParty CallingPartyEnum (0..1) <"The party with right to exercise a cancellation. Allows for buyer, seller or either.">
    earliestDate AdjustableOrRelativeDate (0..1) <"The first day when cancelation is permitted to take effect. A party may give notice prior to this date and taken together with the effective period would be necessary to cancel on this date.">
    expirationDate AdjustableOrRelativeDate (0..1) <"The last day within the term of the contract that cancelation is allowed.">
    effectiveDate AdjustableOrRelativeDates (0..1) <"The effective date if cancelation is invoked otherwise the cancellation period defines the cancellation date.">
    effectivePeriod Period (0..1) <"Effective period for cancelation when notice is given. This is the period after notice is given that cancellation becomes effecticve.">
    earliestCancellationTime BusinessCenterTime (0..1) <"The earliest time in a business day that notice of cancelation can be given.">
    latestCancelationTime BusinessCenterTime (0..1) <"The latest time at which notice of cancelation can be given.">

    // condition ExerciseChoice: <"condition to represent an FpML substitution group construct.">
    // optional choice americanExercise, bermudaExercise, europeanExercise
    condition EffectiveDate: <"Must select one of predefined cancellation types of effectiveDate or effectivePeriod.">
        optional choice effectiveDate, effectivePeriod

    condition CancelableProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision

type CancelableProvisionAdjustedDates: <"A data to:  define the adjusted dates for a cancelable provision on a swap transaction.">

    cancellationEvent CancellationEvent (1..*) <"The adjusted dates for an individual cancellation date.">

type CancellationEvent: <"The adjusted dates for a specific cancellation date, including the adjusted exercise date and adjusted termination date.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">

type EarlyTerminationEvent: <"A data to:  define the adjusted dates associated with an early termination provision.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">
    adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_39: <"FpML validation rule ird-39 - AdjustedExerciseDate must be before or equal to adjustedEarlyTerminationDate.">
        adjustedExerciseDate <= adjustedEarlyTerminationDate

    condition FpML_ird_40: <"FpML validation rule ird-40 - AdjustedExerciseDate must be before or equal to adjustedCashSettlementValuationDate.">
        adjustedExerciseDate <= adjustedCashSettlementValuationDate

    condition FpML_ird_41: <"FpML validation rule ird-41 - AdjustedCashSettlementValuationDate must be before or equal to adjustedCashSettlementPaymentDate.">
        adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type EarlyTerminationProvision: <"A data defining:  an early termination provision for a swap. This early termination is at fair value, i.e. on termination the fair value of the product must be settled between the parties.">
    [metadata key]

    mandatoryEarlyTermination MandatoryEarlyTermination (0..1) <"A mandatory early termination provision to terminate the swap at fair value.">
    mandatoryEarlyTerminationDateTenor Period (0..1) <"Period after trade date of the mandatory early termination date.">
    optionalEarlyTermination OptionalEarlyTermination (0..1) <"An option for either or both parties to terminate the swap at fair value.">
    optionalEarlyTerminationParameters ExercisePeriod (0..1) <"Definition of the first early termination date and the frequency of the termination dates subsequent to that. American exercise is defined by having a frequency of one day.">

    condition MandatoryEarlyTermination: <"The FpML MandatoryEarlyTermination.model specifies a required choice node. The choice node associated with the FpML EarlyTerminationProvision is quite complex and using the data rule provides a more flexible approach than adding complexity to the condition grammar.">
        (mandatoryEarlyTermination exists or optionalEarlyTermination exists)
            or (mandatoryEarlyTermination exists and optionalEarlyTermination exists)

type ExercisePeriod: <"This defines the time interval to the start of the exercise period, i.e. the earliest exercise date, and the frequency of subsequent exercise dates (if any).">
    [metadata key]

    earliestExerciseDateTenor Period (1..1) <"The time interval to the first (and possibly only) exercise date in the exercise period.">
    exerciseFrequency Period (0..1) <"The frequency of subsequent exercise dates in the exercise period following the earliest exercise date. An interval of 1 day should be used to indicate an American style exercise period.">

type ExtendibleProvision extends BuyerSeller: <"A data defining:  an option to extend an existing swap transaction on the specified exercise dates for a term ending on the specified new termination date. As a difference from FpML, it extends the BuyerSeller class, which represents the BuyerSeller.model.">

    americanExercise AmericanExercise (0..1) <"American exercise. FpML implementations consists in an exercise substitution group.">
    bermudaExercise BermudaExercise (0..1) <"Bermuda exercise. FpML implementations consists in an exercise substitution group.">
    europeanExercise EuropeanExercise (0..1) <"European exercise. FpML implementations consists in an exercise substitution group.">
    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    extendibleProvisionAdjustedDates ExtendibleProvisionAdjustedDates (0..1) <"The adjusted dates associated with an extendible provision. These dates have been adjusted for any applicable business day convention.">
    callingParty CallingPartyEnum (0..1)
    singlePartyOption PartyRole (0..1) <"If the ability to extend the contract is not available to both parties then this component specifies the buyer and seller of the option.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before a contract is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionTerm RelativeDateOffset (0..1) <"The length of each extension period relative to the effective date of the preceding contract.">
    extensionPeriod AdjustableRelativeOrPeriodicDates (0..1) <"The period within which notice can be given that the contract will be extended.">

    condition ExtendibleProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision

type ExtendibleProvisionAdjustedDates: <"A data defining:  the adjusted dates associated with a provision to extend a swap.">

    extensionEvent ExtensionEvent (1..*) <"The adjusted dates associated with a single extendible exercise date.">

type ExtensionEvent: <"A data to:  define the adjusted dates associated with an individual extension event.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedExtendedTerminationDate date (1..1) <"The termination date if an extendible provision is exercised. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_42: <"FpML validation rule ird-42 - adjustedExerciseDate must be before adjustedExtendedTerminationDate.">
        adjustedExerciseDate < adjustedExtendedTerminationDate

type MandatoryEarlyTermination: <"A data to:  define an early termination provision for which exercise is mandatory.">
    [metadata key]

    mandatoryEarlyTerminationDate AdjustableDate (1..1) <"The early termination date associated with a mandatory early termination of a swap.">
    calculationAgent CalculationAgent (1..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (1..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    mandatoryEarlyTerminationAdjustedDates MandatoryEarlyTerminationAdjustedDates (0..1) <"The adjusted dates associated with a mandatory early termination provision. These dates have been adjusted for any applicable business day convention.">

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination

type MandatoryEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with a mandatory early termination provision.">

    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">

    condition FpML_ird_44: <"FpML validation rule ird-44 - AdjustedEarlyTerminationDate must be before or equal to adjustedCashSettlementValuationDate must be before or the same as adjustedCashSettlementPaymentDate">
        adjustedEarlyTerminationDate <= adjustedCashSettlementValuationDate and adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type OptionalEarlyTermination: <"A data defining:  an early termination provision where either or both parties have the right to exercise.">

    singlePartyOption BuyerSeller (0..1) <"If optional early termination is not available to both parties then this component specifies the buyer and seller of the option. In FpML, this attribute is of type SinglePsrtyOption, which actually consists of the BuyerSeller.model.">
    mutualEarlyTermination boolean (0..1) <"Used for specifying whether the Mutual Early Termination Right that is detailed in the Master Confirmation will apply.">
    americanExercise AmericanExercise (0..1) <"American exercise. FpML implementations consists in an exercise substitution group.">
    bermudaExercise BermudaExercise (0..1) <"Bermuda exercise. FpML implementations consists in an exercise substitution group.">
    europeanExercise EuropeanExercise (0..1) <"European exercise. FpML implementations consists in an exercise substitution group.">
    exerciseNotice ExerciseNotice (0..*) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    calculationAgent CalculationAgent (0..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (0..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    optionalEarlyTerminationAdjustedDates OptionalEarlyTerminationAdjustedDates (0..1) <"An early termination provision to terminate the trade at fair value where one or both parties have the right to decide on termination.">

    condition ExerciseChoice: <"condition to represent an FpML choice construct.">
        optional choice americanExercise, bermudaExercise, europeanExercise

    condition OptionalEarlyTerminationExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination

type OptionalEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with an optional early termination provision.">

    earlyTerminationEvent EarlyTerminationEvent (1..*) <"The adjusted dates associated with an individual early termination date.">

type Asian: <"As per ISDA 2002 Definitions.">

    averagingInOut AveragingInOutEnum (1..1)
    strikeFactor number (0..1) <"The factor of strike.">
    averagingPeriodIn AveragingPeriod (0..1) <"The averaging in period.">
    averagingPeriodOut AveragingPeriod (0..1) <"The averaging out period.">

type AveragingCalculation: <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    averagingMethod AveragingCalculationMethod (1..1) <"Specifies enumerations for the type of averaging calculation.">
    precision Rounding (1..1) <"Rounding applied to the average calculation. ">

type AveragingStrikeFeature: <"Defines the terms required to calculate the average observations associated with an averaging strike.">
    averagingCalculation AveragingCalculation (1..1) <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    observationTerms ObservationTerms (1..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. ">

type Barrier: <"As per ISDA 2002 Definitions.">

    barrierCap TriggerEvent (0..1) <"A trigger level approached from beneath.">
    barrierFloor TriggerEvent (0..1) <"A trigger level approached from above.">

type CalendarSpread: <"A type for defining a calendar spread feature.">

    expirationDateTwo AdjustableOrRelativeDate (1..1)

type Composite: <"Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.">

    determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which an amount or a date is determined.">
    relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type FxFeature: <"A type for defining FX Features.">

    referenceCurrency string (1..1) <"Specifies the reference currency of the trade.">
        [metadata id]
        [metadata scheme]
    composite Composite (0..1) <"If 'Composite' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price – Strike Price) / (Strike Price – Settlement Price) x Multiplier provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    quanto Quanto (0..1) <"If 'Quanto' is specified as the Settlement Type in the relevant Transaction Supplement, an amount, as determined by the Calculation Agent in accordance with the Section 8.2 of the Equity Definitions.">
    crossCurrency Composite (0..1) <"If 'Cross-Currency' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price – Strike Price) / (Strike Price – Settlement Price) x Multiplier x one unit of the Reference Currency converted into an amount in the Settlement Currency using the rate of exchange of the Settlement Currency as quoted on the Reference Price Source on the Valuation Date, provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    condition FxFeatureChoice: <" Choice rule to represent an FpML choice construct.">
        required choice composite, quanto, crossCurrency

type Knock: <"Knock In means option to exercise comes into existence. Knock Out means option to exercise goes out of existence.">

    knockIn TriggerEvent (0..1) <"The knock in.">
    knockOut TriggerEvent (0..1) <"The knock out.">

type OptionFeature: <"Defines additional optional features that can be included in an option contract.">

    fxFeature FxFeature (0..*) <"Describes a quanto or composite FX feature.">
    strategyFeature StrategyFeature (0..1) <"Defines a simple strategy feature.">
    averagingFeature AveragingCalculation (0..1) <"Defines an option feature in which an average market observation price is determined on valuation and compared to the strike to determine a settlement amount.">
    barrier Barrier (0..1) <"Specifies a barrier feature.">
    knock Knock (0..1) <"Specifies a knock in or knock out feature.">
    passThrough PassThrough (0..1) <"Specifies the rules for pass-through payments from the underlier, such as dividends.">

type TerminationProvision: <"A class for defining option provisions.">
    cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">
    earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">
    extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">

    condition TerminationProvisionChoice:
        required choice cancelableProvision, extendibleProvision, evergreenProvision, earlyTerminationProvision

type OptionStrike: <"Defines the strike price of an option.">

    strikePrice Price (0..1) <"Defines the strike of an option in the form of a price that could be a cash price, interestRate, or other types.">
    strikeReference FixedRateSpecification (0..1) <"Defines the strike of an option in reference to the spread of the underlying swap (typical practice in the case of an option on a credit single name swaps).">
        [metadata reference]
    referenceSwapCurve ReferenceSwapCurve (0..1) <"Defines the strike of an option when expressed by reference to a swap curve (Typically the case for a convertible bond option).">
    averagingStrikeFeature AveragingStrikeFeature (0..1) <"Defines an  option strike that is calculated from an average of observed market prices.">

    condition:
        one-of

type OptionStyle: <"The qualification of the option style: American, Bermuda or European. FpML implements those features as part of a substitution group.">

    americanExercise AmericanExercise (0..1)
    bermudaExercise BermudaExercise (0..1)
    europeanExercise EuropeanExercise (0..1)

    condition:
        one-of

type PassThrough: <"Type which contains pass through payments.">

    passThroughItem PassThroughItem (1..*) <"One to many pass through payment items.">

type PassThroughItem: <"Class to represent a single pass through payment.">

    payerReceiver PayerReceiver (1..1) <"This attribute doesn't exists in the FpML construct, which makes use of the PayerReceiver.model group.">
    passThroughPercentage number (1..1) <"Percentage of payments from the underlier which are passed through.">

type Quanto: <"Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a currency that is different from the currency denomination of the underlier.">

    fxRate FxRate (0..*) <"Specifies a currency conversion rate.">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type StrategyFeature: <"A class for defining option strategy features.">

    strikeSpread StrikeSpread (0..1) <"Definition of the upper strike in a strike spread.">
    calendarSpread CalendarSpread (0..1) <"Definition of the later expiration date in a calendar spread.">

type StrikeSpread: <"A class for defining a strike spread feature.">

    upperStrike OptionStrike (1..1) <"Upper strike in a strike spread.">
    upperStrikeNumberOfOptions number (1..1) <"Number of options at the upper strike price in a strike spread.">

type AmericanExercise: <"A class defining the exercise period for an American style option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
    [metadata key]

    commencementDate AdjustableOrRelativeDate (1..1) <"The first day of the exercise period for an American style option.">
    expirationDate AdjustableOrRelativeDate (1..1) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
    relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.'">
    earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) to, and including, the expiration date.">
    latestExerciseTime BusinessCenterTime (0..1) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
    expirationTime BusinessCenterTime (1..1) <"The latest time for exercise on expirationDate.">
    expirationTimeType ExpirationTimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
    multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
    exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">

type AutomaticExercise: <"A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more than the threshold amount on the exercise date.">

    thresholdRate number (0..1) <"A threshold rate. The threshold of 0.10% would be represented as 0.001">
    isApplicable boolean (0..1) <"Boolean that indicates if it has an automaticExercise">
type BermudaExercise: <"A class defining the Bermuda option exercise dates and the expiration date together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fee.">
    [metadata key]

    bermudaExerciseDates AdjustableOrRelativeDates (1..1) <"The dates that define the Bermuda option exercise dates and the expiration date. The last specified date is assumed to be the expiration date. The dates can either be specified as a series of explicit dates and associated adjustments or as a series of dates defined relative to another schedule of dates, for example, the calculation period start dates. Where a relative series of dates are defined the first and last possible exercise dates can be separately specified.">
    relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.">
    earliestExerciseTime BusinessCenterTime (1..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) on each Bermuda option exercise date and the expiration date.">
    latestExerciseTime BusinessCenterTime (0..1) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
    expirationTime BusinessCenterTime (1..1) <"The latest time for exercise on expirationDate.">
    expirationTimeType ExpirationTimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
    multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
    exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">

type EuropeanExercise: <"A class defining the exercise period for a European style option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
    [metadata key]

    expirationDate AdjustableOrRelativeDate (1..*) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
    relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.">
    earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) on the expiration date.">
    expirationTime BusinessCenterTime (1..1) <"The latest time for exercise on expirationDate.">
    expirationTimeType ExpirationTimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
    partialExercise PartialExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.3. Partial Exercise, the buyer of the option has the right to exercise all or less than all the notional amount of the underlying swap on the expiration date, but may not exercise less than the minimum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
    exerciseFee ExerciseFee (0..1) <"A fee to be paid on exercise. This could be represented as an amount or a rate and notional reference on which to apply the rate.">

type ExerciseFee extends PayerReceiver: <"A class defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmount number (0..1) <"The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.">
    feeRate number (0..1) <"A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmount, feeRate

type ExerciseFeeSchedule extends PayerReceiver: <"A class to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmountSchedule AmountSchedule (0..1) <"The exercise fee amount schedule. The fees are expressed as currency amounts. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feeRateSchedule Schedule (0..1) <"The exercise free rate schedule. The fees are expressed as percentage rates of the notional being exercised. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeScheduleChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmountSchedule, feeRateSchedule

type ExerciseNotice: <"Defines to whom and where notice of execution should be given. The exerciseNoticeGiver refers to one or both of the principal parties of the trade. If present the exerciseNoticeReceiver refers to a party, other than the principal party, to whom notice should be given.">

    exerciseNoticeGiver ExerciseNoticeGiverEnum (1..1) <"Specifies the principal party of the trade that has the right to exercise.">
    exerciseNoticeReceiver AncillaryRoleEnum (0..1) <"Specifies the party to which notice of exercise should be given, e.g. by the buyer of the option. Although in many cases it is the buyer of the option who sends the exercise notice to the seller of the option, this component is reused, e.g. in case of OptionEarlyTermination, either or both parties have the right to exercise.">
    businessCenter BusinessCenterEnum (1..1) <"Specifies the location where the exercise must be reported, e.g. where the exercise notice receiver is based.">
        [metadata scheme]

type ExerciseProcedure: <"A class describing how notice of exercise should be given. This can be either manual or automatic.">

    manualExercise ManualExercise (0..1) <"Specifies that the notice of exercise must be given by the buyer to the seller or seller's agent.">
    automaticExercise AutomaticExercise (0..1) <"If automatic is specified, then the notional amount of the underlying swap not previously exercised under the swaption will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    limitedRightToConfirm boolean (0..1) <"Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Confirm Exercise. If present, (i) the Seller may request the Buyer to confirm its intent if not done on or before the expiration time on the Expiration date (ii) specific rules will apply in relation to the settlement mode.">
    splitTicket boolean (0..1) <"Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the party required to deliver the bonds will divide those to be delivered as notifying party desires to facilitate delivery obligations.">

    condition ExerciseProcedureChoice: <"Choice rule to represent an FpML choice construct.">
        required choice manualExercise, automaticExercise

type ManualExercise: <"A class defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    fallbackExercise boolean (0..1) <"If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the swaption, will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than one tenth of a percentage point (0.10% or 0.001). The term in-the-money is assumed to have the meaning defined in the 2000 ISDA Definitions, Section 17.4. In-the-money.">

    condition ManualExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual

type MultipleExercise extends PartialExercise: <"A class defining multiple exercises. As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more than the maximum notional amount, and if an integral multiple amount is specified, the notional exercised must be equal to or, be an integral multiple of, the integral multiple amount. In FpML, MultipleExercise is built upon the PartialExercise.model.">

    maximumNotionalAmount number (0..1) <"The maximum notional amount that can be exercised on a given exercise date.">
    maximumNumberOfOptions int (0..1) <"The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it means that the maximum number of options corresponds to the remaining unexercised options.">

    condition MaximumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice maximumNotionalAmount, maximumNumberOfOptions

    condition MaximumNumberOfOptions: <"FpML MultipleExercise construct specifies the maximumNumberOfOptions as a positive integer.">
        if maximumNumberOfOptions exists
        then maximumNotionalAmount >= 0

    condition MinimumNumberOfOptions: <"FpML MultipleExercise construct specifies the minimumNumberOfOptions as a positive integer.">
        if minimumNumberOfOptions exists
        then minimumNumberOfOptions >= 0

type PartialExercise: <"A class defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all or less than all the notional amount of the underlying swap but may not be less than the minimum notional amount (if specified) and must be an integral multiple of the integral multiple amount if specified.">

    notionaReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.">
        [metadata reference]
    integralMultipleAmount number (0..1) <"A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.">
    minimumNotionalAmount number (0..1) <"The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.">
    minimumNumberOfOptions int (0..1) <"The minimum number of options that can be exercised on a given exercise date.">

    condition MinimumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice minimumNotionalAmount, minimumNumberOfOptions

type Strike: <"A class describing a single cap or floor rate.">
    [metadata key]

    strikeRate number (1..1) <"The rate for a cap or floor.">
        [synonym FIX_5_0_SP2 value "StrikePrice" tag 202]
    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type StrikeSchedule extends RateSchedule: <"A class describing a schedule of cap or floor rates.">

    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type CalculationAgentModel: <"This class corresponds to the FpML CalculationAgent.model.">
    [deprecated]

    calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
    calculationAgentBusinessCenter BusinessCenterEnum (0..1) <"The city in which the office through which ISDA Calculation Agent is acting for purposes of the transaction is located. The short-form confirm for a trade that is executed under a Sovereign or Asia-Pacific Master Confirmation Agreement (MCA), does not need to specify the Calculation Agent. However, the confirm does need to specify the Calculation Agent city. This is due to the fact that the MCA sets the value for Calculation Agent but does not set the value for Calculation Agent city.">

type AssetPayout extends PayoutBase: <"Security finance payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction. Plus additional description for ICMA.">
    [metadata key]

    assetLeg AssetLeg (1..*) <"Defines each asset movement as a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    securityInformation Product (1..1) <"Specifies the Purchased Security.  Within SecurityPayout we include a condition which validates that the product must be a Security (see below condition 'ProductMustBeSecurity').">
    durationType Duration (1..1) <"Specifies the Duration Terms of the Security Finance transaction. e.g. Open or Term.">
        [deprecated]
    minimumFee Money (0..1) <"A contractual minimum amount which the borrower will pay, regardless of the duration of the loan. A mechanism for making sure that a trade generates enough income.">
    dividendTerms DividendTerms (0..1) <"Specifies the terms under which dividends received by the borrower are passed through to the lender.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition ProductMustBeSecurity: <"Validates that the Purchased Security must be a security.">
        securityInformation -> security exists

    condition DividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then the Duration should be Term.">
        if dividendTerms exists
        then durationType -> durationType = DurationTypeEnum -> Term

type DividendTerms: <"Information related to dividends and payments.">
    manufacturedIncomeRequirement DividendPayoutRatio (1..1) <"Specifies the proportion of the value of the dividend on the borrowed shares that the borrower is legally obligated to return to the lender.">
    dividendEntitlement DividendEntitlementEnum (0..1) <"Defines the date on which the receiver of the equity return is entitled to the dividend.">
    minimumBillingAmount Money (0..1) <"daily fee increments accrue until a threshold is crossed, at which point payment becomes due)">

type AssetLeg: <"Defines each asset movement of an asset payout.">
    settlementDate AdjustableOrRelativeDate (1..1) <"Specifies the settlement date of securities.  In a repo transaction the purchase date would always be the effective date as specified under Economic Terms, the repurchase date would always be the termination date as specified under Economic Terms.">
    deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

type Duration: <"Specifies the Duration Terms of the Security Financing Transaction, and optionally any Evergreen terms.">
    [deprecated]
    durationType DurationTypeEnum (1..1) <"Specifies the Duration Terms of the Security Financing transaction. e.g. Open or Term.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">

type EvergreenProvision: <"Specifies a transaction which automatically extends for a specified timeframe until the exercise of an embedded option.">
    singlePartyOption PartyRole (0..1) <"If evergreen termination is not available to both parties then this component specifies the buyer and seller of the option.">
    noticePeriod RelativeDateOffset (1..1) <"The length of each evergreen extension period relative to the effective date of the preceding contract.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before an evergreen is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionFrequency AdjustableRelativeOrPeriodicDates (1..1) <"The frequency with which the evergreen contract will be extended if notice is not given.">
    finalPeriodFeeAdjustment Price (0..1) <"An optional adjustment to the rate for the last period of the evergreen i.e. the period from when notice is given to stop rolling the contract through to the termination date.">

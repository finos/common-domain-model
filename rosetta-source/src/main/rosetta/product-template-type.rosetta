namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.*
import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.datetime.daycount.*

import cdm.base.staticdata.party.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*

import cdm.observable.event.*
import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.event.common.*

import cdm.product.asset.*
import cdm.product.common.*
import cdm.product.common.settlement.*
import cdm.product.common.schedule.*
import cdm.product.qualification.*
import cdm.product.collateral.*

import cdm.mapping.config.*

type TransferableProduct extends Asset: <"A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific EconomicTerms.">
    economicTerms EconomicTerms (1..1) <"The price forming features, including payouts and provisions.">

type EconomicTerms: <" This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, the effective and termination date and the date adjustment provisions when applying uniformily across the payout components. This class also includes the legal provisions which have valuation implications: cancelable provision, extendible provision, early termination provision and extraordinary events specification.">

    effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
        [docReference ICMA GMRA namingConvention "Purchase Date"
            provision "As defined in GMRA paragraph 2(mm) The date on which Purchased Securities are sold or are to be sold by Seller to Buyer."]
        [docReference ICMA ERCCBestPractice namingConvention "Purchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the value date of a repo."]
    terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
        [docReference ICMA GMRA namingConvention "Repurchase Date"
            provision "As defined in GMRA paragraph 2(qq) The date on which Buyer is to sell Equivalent Securities to Seller."]
        [docReference ICMA ERCCBestPractice namingConvention "Repurchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the maturity date of a repo."]
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day adjustment convention when it applies across all the payout components. This specification of the business day convention and financial business centers is used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
    payout Payout (1..*) <"The payout specifies the future cashflow computation methodology which characterizes a financial product.">
    newPayout NewPayout (0..*)
    terminationProvision TerminationProvision (0..1) <"Contains optional provisions pertaining to the termination characteristics of a contract.">
    calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
    nonStandardisedTerms boolean (0..1) <"Specifies, when boolean value is True, that additional economic terms exist that have not been included in the product representation.">
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">

    condition ReturnType_Total_Requires_Dividends: <"A total return implies both a price and a dividend return">
        if payout -> PerformancePayout -> returnTerms -> priceReturnTerms -> returnType all = ReturnTypeEnum -> Total
        then payout -> PerformancePayout -> returnTerms -> dividendReturnTerms exists

    condition LastRegularPaymentDate: <"FpML specifies that lastRegularPaymentDate must only be included if there is a final stub. As part of the CDM, this data rule has been adjusted to specify that it only applies to interest rate swaps, as the credit derivatives products can have a specified lastRegularPaymentDate while the stub is typically not applicable to those.">
        if payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and payout -> InterestRatePayout -> stubPeriod -> finalStub exists
        then payout -> InterestRatePayout count = 2

    condition PayRelativeTo: <"FpML specifies a required payRelativeTo element as part of the PaymentDates. As standardized CDS don't have such payRelativeTo provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2 and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> payRelativeTo exists

    condition PaymentDatesAdjustments: <"FpML specifies a required paymentDatesAdjustments element as part of the PaymentDates. As standardized CDS don't have such paymentDatesAdjustments provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2 and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> paymentDatesAdjustments exists

    condition PaymentFrequency: <"FpML specifies a required paymentFrequency element as part of the PaymentDates. As standardized CDS may not have such paymentFrequency provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2 and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> paymentFrequency exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        if payout -> OptionPayout exists
        then payout -> OptionPayout -> priceQuantity exists
                or payout -> OptionPayout -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2

    condition DayCountFraction: <"FpML specifies a required dayCountFraction element as part of the swapStream/calculationPeriodAmount/calculation. As standardized CDS don't have such specified day count fraction, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
        then payout -> InterestRatePayout -> dayCountFraction exists

    condition PaymentDates: <"FpML specifies a required paymentDates element as part of the swapStream. As standardized CDS may not have specified payment dates, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
        then payout -> InterestRatePayout -> dayCountFraction exists

    condition MarketPrice: <"FpML specifies that marketFixedRate and marketPrice only have meaning in a credit index trade">
        if payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
        then payout -> CreditDefaultPayout -> transactedPrice -> marketFixedRate is absent
                and payout -> CreditDefaultPayout -> transactedPrice -> marketPrice is absent

    condition NotionalResetOnPerformancePayout: <"Notional reset only applies to return swaps, and therefore can only exist on an performancePayout or interestRatePayouts that are associated with it.">
        payout -> CreditDefaultPayout -> priceQuantity -> reset is absent
            and payout -> AssetPayout -> priceQuantity -> reset is absent
            and payout -> CommodityPayout -> priceQuantity -> reset is absent
            and payout -> FixedPricePayout -> priceQuantity -> reset is absent
            and payout -> SettlementPayout -> priceQuantity -> reset is absent
            and payout -> OptionPayout -> priceQuantity -> reset is absent
            and payout -> Cashflow -> priceQuantity -> reset is absent

    condition NotionalResetInterestRatePayoutExists: <"As the performancePayout->payoutQuantity->reset attribute applies to return swaps, the interestRatePayout needs to be present alongside it.">
        if payout -> PerformancePayout -> priceQuantity -> reset contains True
        then payout -> InterestRatePayout exists

    condition FpML_cd_26_28: <"FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate. This data rule tackles those two FpML validation rules at once, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute.">
        if payout -> CreditDefaultPayout exists
                and payout -> Cashflow exists
                and effectiveDate exists
                and payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate exists
                and payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate is absent
        then payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate all > effectiveDate -> adjustableDate -> unadjustedDate or payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> adjustedDate all > effectiveDate -> adjustableDate -> adjustedDate or payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate -> adjustedDate all > effectiveDate -> relativeDate -> adjustedDate

    condition FpML_cd_27: <"FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        if payout -> CreditDefaultPayout exists
                and payout -> Cashflow exists
                and terminationDate exists
                and payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> unadjustedDate all < terminationDate -> adjustableDate -> unadjustedDate or payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> adjustedDate all < terminationDate -> adjustableDate -> adjustedDate or payout -> Cashflow -> settlementTerms -> settlementDate -> adjustableOrRelativeDate -> relativeDate -> adjustedDate all < terminationDate -> adjustableDate -> adjustedDate

    condition FpML_cd_30: <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        if payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and terminationDate exists
        then payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> unadjustedDate
                or payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> adjustedDate

    condition IndependentCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentIndependent

    condition AssetPayoutDividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then it should be a Term trade.">
        if payout -> AssetPayout -> dividendTerms exists
        then terminationDate exists

type OptionPayout extends PayoutBase: <" The option payout specification terms. The associated globalKey denotes the ability to associate a hash value to the respective OptionPayout instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    buyerSeller BuyerSeller (1..1)
    feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">
    observationTerms ObservationTerms (0..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. To be used for option contracts that reference a benchmark price.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    underlier Underlier (1..1) <"The financial product underlying the option, which can be of any type including an Asset, Basket, Index or a NonTransferableProduct.">
    optionType OptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
    exerciseTerms ExerciseTerms (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
    strike OptionStrike (0..1) <"Specifies the strike of the option">

    condition ClearedPhysicalSettlementExists:
        if settlementTerms -> physicalSettlementTerms exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2
        then settlementTerms -> physicalSettlementTerms -> clearedPhysicalSettlement exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

    condition OptionStylePresent: <"This condition ensures that an optionPayout contains the style of option within its exercise terms.">
        exerciseTerms -> style exists

    condition OptionTypePresent: <"This condition ensures that an option type is set when the underlier is not a non-transferable product.">
        if underlier -> Product -> NonTransferableProduct is absent
        then optionType exists

type ReturnTerms: <"Specifies the type of return of a performance payout.">

    priceReturnTerms PriceReturnTerms (0..1) <"Return terms based upon the underlier's observed price.">
    dividendReturnTerms DividendReturnTerms (0..1) <"Return terms based upon dividend payments associated to the underlier.">
    varianceReturnTerms VarianceReturnTerms (0..1) <"Return terms based upon the observed variance of the underlier's price.">
    volatilityReturnTerms VolatilityReturnTerms (0..1) <"Return terms based upon the observed volatility of the underlier's price.">
    correlationReturnTerms CorrelationReturnTerms (0..1) <"Return terms based upon the observed correlation between the components of the underlying basket.">

    condition ReturnTermsExists: <"Checks that the return type label matches the actual return terms structure of the product.">
        if priceReturnTerms -> returnType = ReturnTypeEnum -> Total
        then (priceReturnTerms, dividendReturnTerms) only exists
        else if priceReturnTerms -> returnType = ReturnTypeEnum -> Price
        then priceReturnTerms only exists
        else priceReturnTerms only exists
            or dividendReturnTerms only exists
            or varianceReturnTerms only exists
            or volatilityReturnTerms only exists
            or correlationReturnTerms only exists

type NewPerformancePayout extends NewPayoutBase: <"Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation products.">
    paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
    underlier Underlier (0..1) <"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
    fxFeature FxFeature (0..*) <"Defines quanto or composite FX features that are included in the swap leg.">
    returnTerms NewReturnTerms (1..1) <"Specifies the type of return of a performance payout.">
    portfolioReturnTerms NewPortfolioReturnTerms (0..*) <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level">

type NewReturnTerms:
    priceReturnTerms NewPriceReturnTerms (0..1) <"Return terms based upon the underlier's observed price.">
    dividendReturnTerms DividendReturnTerms (0..1) <"Return terms based upon dividend payments associated to the underlier.">
    varianceReturnTerms NewVarianceReturnTerms (0..1) <"Return terms based upon the observed variance of the underlier's price.">
    volatilityReturnTerms NewVolatilityReturnTerms (0..1) <"Return terms based upon the observed volatility of the underlier's price.">
    correlationReturnTerms NewCorrelationReturnTerms (0..1) <"Return terms based upon the observed correlation between the components of the underlying basket.">

 //   condition ReturnTermsExists: <"Checks that the return type label matches the actual return terms structure of the product.">

type NewPriceReturnTerms:

    corePayoutTerms NewPriceReturnCoreCalculationTerms (1..1)

type NewVarianceReturnTerms:

    corePayoutTerms NewVarianceReturnCoreCalculationTerms (1..1)
    volatilityStrikePrice Price (0..1) <"Optinally specifies the volatility strike, which value is expected to be equal to the squared root of the variance strike value.">
         [metadata address "pointsTo"=PriceQuantity->price]
    expectedN number (1..1)
    varianceCapFactor number (0..1) <"When any, the value used to calculate the variance cap amount to be applied to the realized variance. As an indication, the varianceCapFactor value is usually equal to: 2.5^2 (and the variance cap amount value is usually equal to: varianceCapFactor x varianceStrikePrice).">
    volatilityCapFactor number (0..1) <"Optionally specifies the volatilityCapFactor which value is expected to be equal to the squared root of the varianceCapFactor, and is usually equal to: 2.5.">
    meanAdjustment boolean (0..1)
    vegaNotionalAmount NonNegativeQuantitySchedule (0..1) <"Vega Notional represents the approximate gain/loss at maturity for a 1% difference between RVol (realised vol) and KVol (strike vol). It does not necessarily represent the Vega Risk of the trade.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    exchangeTradedContractNearest Observable (0..1) <"Specification of the exchange traded contract nearest.">
        [metadata address "pointsTo"=PriceQuantity->observable]

type NewVolatilityReturnTerms:

    corePayoutTerms NewVolatilityReturnCoreCalculationTerms (1..1)
    expectedN number (1..1)
    volatilityCapFactor number (0..1) <"Optionally specifies the volatilityCapFactor which value is usually equal to: 2.5.">
    meanAdjustment boolean (0..1)


type NewCorrelationReturnTerms:

type NewPortfolioReturnTerms extends NewReturnTerms:
    [metadata key]

    payerReceiver PayerReceiver (1..1) <"Canonical representation of the payer and receiver parties applicable to each individual return leg.">
    underlier Observable (1..1) <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    quantity NonNegativeQuantitySchedule (0..1) <"Specifies a quantity schedule for the underlier, which applies to each individual return leg.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    initialValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Final Price | Specifies the final valuation price of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

type NewPriceReturnCoreCalculationTerms:
    observablePrice PayoutObservable (0..1) // optional cardinality, assuming that if not populated, then observable is deemed to be the underlier
    rateReturnRatio number (1..1) <"The ratio value to substract from the return for the purpose of calculating the rate of return. As an indication, typical value =1, notably when calculating in accordance with 2002 ISDA Equity Definitions VE.">
    returnType ReturnTypeEnum (1..1) <"The type of return associated with the swap, notably when calculating the return in accordance with 2002 ISDA Equity Definitions VE.">
    calculatedValue DatedValue (0..1) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">
        [metadata reference]

type NewVarianceReturnCoreCalculationTerms:

    varianceStrikePrice Price (1..1) <"Specifies the variance strike.">
         [metadata address "pointsTo"=PriceQuantity->price]
    finalRealizedVariance PayoutObservable (1..1) <"Specifies the observable of the option (corresponding for instance to the Reference Price, if referencing the 2002 ISDA Equity Derivaitves Definitions as an applicable documentation to the related Trade). ">
    calculatedValue DatedValue (0..1) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">
        [metadata reference]

type NewVolatilityReturnCoreCalculationTerms:

    volatilityStrikePrice Price (1..1) <"Optinally specifies the volatility strike, which value is expected to be equal to the squared root of the variance strike value.">
         [metadata address "pointsTo"=PriceQuantity->price]
    finalRealizedVolatility PayoutObservable (1..1) <"Specifies the observable of the option (corresponding for instance to the Reference Price, if referencing the 2002 ISDA Equity Derivatives Definitions as an applicable documentation to the related Trade). ">
    calculatedValue DatedValue (0..1) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">
        [metadata reference]

type NewCorrelationCoreCalculationTerms:

type PerformancePayout extends PayoutBase: <"Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation products.">
    observationTerms ObservationTerms (0..1) <"Defines how and when a performance type option or performance type swap is to be observed.">
    valuationDates ValuationDates (1..1) <"Defines how and when a performance type option or performance type swap is to be valued, including both interim and final valuation.">
    paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
    underlier Underlier (0..1) <"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
    fxFeature FxFeature (0..*) <"Defines quanto or composite FX features that are included in the swap leg.">
    returnTerms ReturnTerms (0..1) <"Specifies the type of return of a performance payout.">
    portfolioReturnTerms PortfolioReturnTerms (0..*) <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level">
    initialValuationPrice PriceSchedule (0..*) <"Specifies the net initial valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the net initial valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"Specifies the net final valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

    condition Underlier: <"The underlier on a performance payout can only be an observable.">
        underlier -> Observable exists

    condition PortfolioOrStraightReturn:
        required choice returnTerms, portfolioReturnTerms

    condition PortfolioReturnIsMultipleReturns: <"No single portfolioReturnTerms instance shall exist because it would be a duplicate of straight returnTerms.">
        if portfolioReturnTerms exists
        then portfolioReturnTerms count > 1

    condition UnderlierOfPortfolioIsBasket: <"A portfolio made of multiple individual legs in portfolio, is a strategy that consider the Basket in transparency, thus having a Basket as an underlier of the PerformancePayout that is aggregation level and multiple individual legs in portfolio, each with an underlier to correspond to each Basket consituent. This is particular usage of portfolio attribute, hence the condition, being aknowledged that other usages would not require Basket to exist at this level, for instance a dispersion strategy where 'N+1' multiple portfolio return legs would exist, '1' with underlier->Basket, other 'N' ones with single underliers, where the Basket is at same level as the other legs (therefore no aggregation shall exist via Basket at PerformancePayout level.">
        if portfolioReturnTerms -> priceReturnTerms exists
        then underlier -> Observable -> basket exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition NoSharePriceDividendAdjustmentIndex: <"If the underlier is an index, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> Observable -> index exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition NoSharePriceDividendAdjustmentForeignExchange: <"If the underlier is an foreign exchange, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> Observable -> index -> ForeignExchangeRateIndex exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition CorrelationUnderlierOnlyBasket: <"Correlation Return Terms can only have a basket as underlier, since it needs to compute the correlation between two or more products.">
        if returnTerms -> correlationReturnTerms exists
        then underlier -> Observable -> basket exists

    condition EquitySpecificAttributes: <"Equity specific attributes cannot be present in non-equity products.">
        if Qualify_UnderlierObservable_Equity(underlier -> Observable) = False
        then returnTerms -> varianceReturnTerms -> dividendApplicability is absent
                and returnTerms -> varianceReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> dividendApplicability is absent
                and returnTerms -> volatilityReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> correlationReturnTerms -> dividendApplicability is absent
                and returnTerms -> correlationReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> correlationReturnTerms -> sharePriceDividendAdjustment is absent

type PortfolioReturnTerms extends ReturnTerms: <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level.">
    [metadata key]

    payerReceiver PayerReceiver (1..1) <"Canonical representation of the payer and receiver parties applicable to each individual return leg.">
    underlier Observable (1..1) <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    quantity NonNegativeQuantitySchedule (0..1) <"Specifies a quantity schedule for the underlier, which applies to each individual return leg.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    initialValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Final Price | Specifies the final valuation price of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

choice Payout: <"Represents the set of future cashflow methodologies in the form of specific payout data type(s) which result from the financial product.  Examples: a trade in a cash asset will use only a settlement payout; for derivatives, two interest rate payouts can be combined to specify an interest rate swap; one interest rate payout can be combined with a credit default payout to specify a credit default swap.">
    [metadata key]

    AssetPayout          <"Defines the assets and movements in a security financing transaction.">
    Cashflow             <"A cashflow between the parties to the trade. For interest rate and equity products, this corresponds to the FpML additionalPayment element. For credit default swaps, this corresponds to the FpML initialPayment element and the singlePayment element of the fee leg. For option products, it represents the FpML premium element.">
    CommodityPayout      <"Defines the payout for the floating leg of a Commodity Swap.">
    CreditDefaultPayout  <"The credit default payout, which provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms.">
    FixedPricePayout     <"Defines a payout in which one or more payouts are defined as a fixed price.">
    InterestRatePayout   <"All of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg).">
    OptionPayout         <"The option payout.">
    PerformancePayout    <"The performance payout, which encompasses the equity price returns, dividend returns, volatility return, variance return and correlation provisions.">
    SettlementPayout     <"Represents a forward settling payout. The 'Underlier' attribute captures the underlying payout, which is settled according to the 'SettlementTerms' attribute. Both FX Spot and FX Forward should use this component.">

type NewPayout: <"Represents the set of future cashflow methodologies in the form of specific payout data type(s) which result from the financial product.  Examples: a trade in a cash asset will use only a settlement payout; for derivatives, two interest rate payouts can be combined to specify an interest rate swap; one interest rate payout can be combined with a credit default payout to specify a credit default swap.">
    [metadata key]

    interestRatePayout NewInterestRatePayout (0..*) <"The rate return payout.">
    optionPayout NewOptionPayout (0..*)  <"The option payout.">
    performancePayout  NewPerformancePayout  (0..*)  <"The performance payout, which encompasses the equity price returns, dividend returns, volatility return, variance return and correlation provisions.">
    settlementPayout  NewSettlementPayout  (0..*)  <"Represents a forward settling payout. The 'Underlier' attribute captures the underlying payout, which is settled according to the 'SettlementTerms' attribute. Both FX Spot and FX Forward should use this component.">

 type NewSettlementPayout extends NewPayoutBase: 
    underlier Underlier (1..1) <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, or the cash settlement of an index rate.">
    deliveryTerm string (0..1) <"Also called contract month or delivery month. However, it's not always a month. It is usually expressed using a code, e.g. Z23 would be the Dec 2023 contract, (Z = December). For crude oil, the corresponding contract might be called CLZ23.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Underlier: <"The underlier for a settlement payout cannot be a NonTransferableProduct.">
        underlier -> Product -> NonTransferableProduct is absent

    condition Basket: <"If the underlier is a basket, it must contain only transferable assets.">
        if underlier -> Observable -> basket exists
        then underlier -> Observable -> basket -> basketConstituent -> asset only exists

    condition Index: <"If the underlier is an Index, then it can only be cash settled.">
        if underlier -> Observable -> index exists
        then settlementTerms -> cashSettlementTerms exists

    condition SettlementTerms: <"Settlement Terms should be defined except for cash.">
        if underlier -> Observable -> asset -> Cash exists
        then settlementTerms exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

 type NewInterestRatePayout extends NewPayoutBase: <" A class to specify all of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg). The associated globalKey denotes the ability to associate a hash value to the InterestRatePayout instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">

    corePayoutTerms NewInterestRateCoreCalculationTerms (1..1)
    calculationMethods NewInterestRateSpecificCalculationTerms (0..1)
    dayCountFraction DayCountFractionEnum (1..1) <"The day count fraction. The cardinality has been relaxed when compared with the FpML interest rate swap for the purpose of accommodating standardized credit default swaps which DCF is not explicitly stated as part of the economic terms. The data rule InterestRatePayout_dayCountFraction requires that the DCF be stated for interest rate products.">
        [metadata scheme]
    resetDates ResetDates (0..1) <"The reset dates schedule, i.e. the dates on which the new observed index value is applied for each period and the interest rate hence begins to accrue.">
    paymentDates PaymentDates (0..1) <"The payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the reset dates).">
    paymentDelay boolean (0..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">
    stubPeriod StubPeriod (0..1) <"The stub calculation period amount parameters. This element must only be included if there is an initial or final stub calculation period. Even then, it must only be included if either the stub references a different floating rate tenor to the regular calculation periods, or if the stub is calculated as a linear interpolation of two different floating rate tenors, or if a specific stub rate or stub amount has been negotiated.">

  condition FpML_ird_6: <"FpML validation rule ird-6 - If paymentDates/firstPaymentDate exists, and if calculationPeriodDates/effectiveDate exists, then paymentDates/firstPaymentDate must be after calculationPeriodDates/effectiveDate/unadjustedDate.">
    if paymentDates -> firstPaymentDate exists
        and observationTerms -> calculationPeriodDates -> effectiveDate exists
    then paymentDates -> firstPaymentDate > observationTerms -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

  condition FpML_ird_23: <"FpML validation rule ird-23 - If the initialStub exists, the calculationPeriodDates element referenced by the @href attribute of stubCalculationPeriodAmount/calculationPeriodDatesReference contains firstRegularPeriodStartDate.">
    if stubPeriod -> initialStub exists
    then observationTerms -> calculationPeriodDates -> firstRegularPeriodStartDate exists

  condition FpML_ird_24: <"FpML validation rule ird-24 - The finalStub exists if and only if the calculationPeriodDates element referenced by calculationPeriodDates/@href contains a lastRegularPeriodEndDate.">
    if stubPeriod -> finalStub exists
    then observationTerms -> calculationPeriodDates -> lastRegularPeriodEndDate exists

  condition InitialStubFinalStub: <"Data rule to represent the FpML nested XML construct as part of StubCalculationPeriodAmount.">
    if stubPeriod exists
    then stubPeriod -> initialStub exists or stubPeriod -> finalStub exists

  condition CashSettlementTerms: <"Cash Settlements Terms must exist when the settlement currency is different to the notional currency of the trade.">
    if settlementTerms -> settlementCurrency exists
        and (settlementTerms -> settlementCurrency <> quantity -> corePayoutQuantity -> unit -> currency
          or settlementTerms -> settlementCurrency any <> structuredTerms -> multiplierDivisor -> multiplier -> fixedPrice -> unit -> currency
          or structuredTerms -> multiplierDivisor -> multiplier -> observablePrice -> index -> ForeignExchangeRateIndex exists)
    then settlementTerms -> cashSettlementTerms -> valuationMethod exists and settlementTerms -> cashSettlementTerms -> valuationDate exists
          
  condition FpML_ird_7_1: <"FpML validation rule ird-7 1/2 - The existence of compoundingMethod is prohibited when the calculation period and payment frequencies are the same.">
    if paymentDates -> paymentFrequency -> period = observationTerms -> calculationPeriodDates -> calculationPeriodFrequency -> period
        and paymentDates -> paymentFrequency -> periodMultiplier = observationTerms ->calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier
    then (calculationMethods -> compoundingMethod is absent or calculationMethods-> compoundingMethod = CompoundingMethodEnum -> None)

  condition FpML_ird_7_2: <"FpML validation rule ird-7 2/2 - The existence of compoundingMethod is required when the calculation period and payment frequencies differ.">
    if (paymentDates -> paymentFrequency -> period exists
          and observationTerms -> calculationPeriodDates -> calculationPeriodFrequency -> period exists
          and paymentDates -> paymentFrequency -> period <> observationTerms -> calculationPeriodDates -> calculationPeriodFrequency -> period)
        or (paymentDates -> paymentFrequency -> periodMultiplier exists
          and observationTerms -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier exists
          and paymentDates -> paymentFrequency -> periodMultiplier <> observationTerms -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
    then  calculationMethods-> compoundingMethod exists

  condition FpML_ird_9: <"FpML validation rule ird-9 - If calculationPeriodAmount/calculation/compoundingMethod exists, then resetDates must exist.">
    if  calculationMethods-> compoundingMethod exists then resetDates exists

  condition CalculationPeriodDatesFirstCompoundingPeriodEndDate: <"FpML specifies that the firstCompoundingPeriodEndDate must only be specified when the compounding method is specified and not equal to a value of None.">
    if  calculationMethods-> compoundingMethod is absent or calculationMethods-> compoundingMethod = CompoundingMethodEnum -> None
    then observationTerms -> calculationPeriodDates -> firstCompoundingPeriodEndDate is absent

type NewInterestRateSpecificCalculationTerms :

    discountingMethod DiscountingMethod (0..1) <"The parameters specifying any discounting conventions that may apply. This element must only be included if discounting applies.">
    compoundingMethod CompoundingMethodEnum (0..1) <"If one or more calculation period contributes to a single payment amount this element specifies whether compounding is applicable and, if so, what compounding method is to be used. This element must only be included when more than one calculation period contributes to a single payment amount.">
    negativeInterestRateTreatment NegativeInterestRateTreatmentEnum (0..1) <"The specification of any provisions for calculating payment obligations when a floating rate is negative (either due to a quoted negative floating rate or by operation of a spread that is subtracted from the floating rate).">
    overnightCalculationMethod cdm.observable.asset.calculatedrate.FloatingRateCalculationParameters (0..1) <"Support for modular calculated rates, such such as lockout compound calculations.">
    overnightFallbackRate  cdm.observable.asset.calculatedrate.FallbackRateParameters (0..1) <"Definition of any fallback rate that may be applicable.">

type NewInterestRateCoreCalculationTerms: <"Specifies the endpoints required for resolving the core formula of an interest return payout = referencedRate x dayCountFraction.">
      // at target, we expected this component being annotated with: [calculation]
    
    rateSpecification RateSpecificationBase (1..1) <"The specification of the rate value(s) applicable to the contract using either a floating rate calculation, a single fixed rate, a fixed rate schedule, or an inflation rate calculation.">
    calculatedValue DatedValue (0..1) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">
        [metadata reference]

choice RateSpecificationBase:<"Specifies whether reference rate is a straight rate or a spread (composite rate).">

  NewRateSpecification <"Specifies the reference rate i.e. fixed interest rate, floating interest rate or inflation rate.">
  NewSpreadSpecification <"Specifies a composite rate, that is a rate differential made of at least two rate legs, broken down into longRate series and shortRate series.">

type NewSpreadSpecification :  
  longRate NewRateSpecification (1..*)
  shortRate NewRateSpecification (1..*)
  structuredTerms NewStructuredTerms (0..1)
  calculatedValue DatedValue (0..1) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">
        [metadata reference]

type NewOptionPayout extends NewPayoutBase :

    corePayoutTerms NewOptionCorePayoutTerms (1..1)
    underlier Underlier (1..1) <"The financial product underlying the option, which can be of any type including an Asset, Basket, Index or a NonTransferableProduct.">
    exerciseTerms ExerciseTerms (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">

    condition OptionStylePresent: <"This condition ensures that an optionPayout contains the style of option within its exercise terms.">
        exerciseTerms -> style exists
    
    condition ClearedPhysicalSettlementExists:
        if settlementTerms -> physicalSettlementTerms exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2
        then settlementTerms -> physicalSettlementTerms -> clearedPhysicalSettlement exists

type PayoutObservable extends Observable : <"Specifies the object to be observed for a price, it could be an asset or a reference.">
    structuredTerms NewStructuredTerms (0..1)
        [metadata reference]
    priceObservation PriceSchedule (0..*)
        [metadata address]
    
    condition PriceObservation: <"Recording the observation of a price necessarily consists in recording a pair of information : the price value and the observation date.">
    if priceObservation exists
    then priceObservation -> datedValue exists

type NewOptionCorePayoutTerms: <"Specifies the endpoints required for resolving the core formula of an option payout : either max(0 ; strikePrice - observablePrice) or max(0 ; observablePrice - strikePrice), as determined by the optionType">
      // at target, we expected this component being annotated with: [calculation]
    
    optionType OptionTypeEnum (1..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
    strikePrice NewBasePrice (1..1) <"Specifies the strike.">
    observablePrice PayoutObservable (1..1) <"Specifies the observable (corresponding for instance to the Reference Price, if referencing the 2002 ISDA Equity Derivaitves Definitions as an applicable documentation to the related Trade). ">
    calculatedValue DatedValue (0..*) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">

choice Underlier: <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, a product, or the cash settlement of an index rate.  Conditions are usually applied when used in a data type, such as a payout, to ensure this aligns with the use case.">
    Observable <"Specifies the object to be observed for a price, it could be an asset or a reference.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    Product <"Enables either a TransferableProduct or a NonTransferableProduct to be used in an underlier.">

choice Product: <"Enables either a TransferableProduct or a NonTransferableProduct to be used in an underlier.">
    TransferableProduct <"A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific EconomicTerms.">
    NonTransferableProduct <"The non-transferable product data type represents a product that can be traded (as part of a TradableProduct) but cannot be transferred to others.">

type NonTransferableProduct: <"A data type to specify the financial product's economic terms, alongside the product identification and product taxonomy. The non-transferable product data type represents a product that can be traded (as part of a TradableProduct) but cannot be transferred to others.  It is meant to be used across the pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
    [metadata key]
    identifier ProductIdentifier (0..*) <"Comprises a identifier and a source to uniquely identify the nonTransferableProduct. ">
    taxonomy ProductTaxonomy (0..*) <"Specifies the product taxonomy, which is composed of a taxonomy value and a taxonomy source.">
    economicTerms EconomicTerms (1..1) <"The price forming features, including payouts and provisions.">

    condition PrimaryAssetClass: <"Specifies that when nonStandardisedTerms are True that a primary asset class must be specified.">
        if economicTerms -> nonStandardisedTerms = True
        then taxonomy -> primaryAssetClass exists

type TradeLot: <"Specifies the price and quantity of a trade lot, where the same product could be traded multiple times with the same counterparty but in different lots (at a different date, in a different quantity and at a different price). One trade lot combined with a product definition specifies the entire economics of a trade. The lifecycle mechanics of each such trade lot (e.g. cashflow payments) is independent of the other lots.">
    lotIdentifier Identifier (0..*) <"Specifies one or more identifiers for the lot, if any.">
    priceQuantity PriceQuantity (1..*) <"Specifies the settlement characteristics of a trade lot: price, quantity, observable (optionally) and the settlement terms. This attribute has a multiple cardinality to allow to specify the price, quantity and observable of different legs in a single, composite product (e.g. a Swap).">

type TradableProduct: <"Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this product plus an (optional) mechanism for any potential future quantity adjustment.">

    product NonTransferableProduct (1..1) <"The underlying product to be included in a contract or execution.">
    tradeLot TradeLot (1..*) <"Specifies the price, quantity and effective date of each trade lot, when the same product may be traded multiple times in different lots with the same counterparty. In a trade increase, a new trade lot is added to the list, with the corresponding effective date. In a trade decrease, the existing trade lot(s) are decreased of the corresponding quantity (and an unwind fee may have to be settled). The multiple cardinality and the ability to increase existing trades is used for Equity Swaps in particular.">
    counterparty Counterparty (2..2) <"Specifies the parties which are the two counterparties to the transaction.  The product is agnostic to the actual parties to the transaction, with the party references abstracted away from the product definition and replaced by the counterparty enum (e.g. CounterpartyEnum values Party1 or Party2). The counterparty enum can then be positioned in the product (e.g. to specify which counterparty is the payer, receiver etc) and this counterparties attribute, which is positioned outside of the product definition, allows the counterparty enum to be associated with an actual party reference.">
        [docReference ICMA GMRA namingConvention "Party"
            provision "Parties entering into GMRA, as specified on page 1 of the GMRA and under 1. (a)."]
    ancillaryParty AncillaryParty (0..*) <"Specifies the parties with ancillary roles in the transaction. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and this AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">
    adjustment NotionalAdjustmentEnum (0..1) <"Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfolio rebalancing etc. It is typically used in the context of Equity Swaps.">

    condition PriceQuantityTriangulation: <"Check PriceQuantity triangulation for each TradeLot.">
        PriceQuantityTriangulation(tradeLot) = True

    condition NotionalAdjustment: <"As the adjustment attribute applies to return swaps, the equity payout needs to be present alongside it.">
        if adjustment exists
        then product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
                or product -> economicTerms -> payout -> PerformancePayout exists

    condition PerformancePayout_ExtraordinaryDividendsParty:
        if product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                    then product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists

    condition OptionPayout_PredeterminedClearingOrganizationParty:
        if product -> economicTerms -> payout -> OptionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition ForwardPayout_PredeterminedClearingOrganizationParty:
        if product -> economicTerms -> payout -> SettlementPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition PredeterminedClearingOrganizationParty:
        if ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty
        then product -> economicTerms -> payout -> SettlementPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
                or product -> economicTerms -> payout -> OptionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists

    condition ExerciseNoticeReceiverPartyManual:
        if product -> economicTerms -> payout -> OptionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                    then product -> economicTerms -> payout -> OptionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyOptionalEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyCancelableProvision:
        if product -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                    then product -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyExtendibleProvision:
        if product -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                    then product -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition CalculationAgentIndependent:
        if product -> economicTerms -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                    then product -> economicTerms -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentOptionalEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentMandatoryEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists

type ConstituentWeight: <"A class describing the weight of each of the underlier constituent within the basket, either in absolute or relative terms.">

    openUnits number (0..1) <"The number of units (index or securities) that constitute the underlier of the swap. In the case of a basket swap, this element is used to reference both the number of basket units, and the number of each asset components of the basket when these are expressed in absolute terms.">
    basketPercentage number (0..1) <"The relative weight of each respective basket constituent, expressed in percentage. A basket percentage of 5% would be represented as 0.05.">

    condition BasketPercentage: <"FpML specifies basketPercentage as a RestrictedPercentage type, meaning that the value needs to be comprised between 0 and 1.">
        if basketPercentage exists
        then basketPercentage >= 0.0 and basketPercentage <= 1.0

type SettlementPayout extends PayoutBase: <"Represents a forward settling payout. The underlier attribute captures the underlying payout, which is settled according to the settlementTerms attribute (which is part of PayoutBase). Both FX Spot and FX Forward should use this component.">
    underlier Underlier (1..1) <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, or the cash settlement of an index rate.">
    deliveryTerm string (0..1) <"Also called contract month or delivery month. However, it's not always a month. It is usually expressed using a code, e.g. Z23 would be the Dec 2023 contract, (Z = December). For crude oil, the corresponding contract might be called CLZ23.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Underlier: <"The underlier for a settlement payout cannot be a NonTransferableProduct.">
        underlier -> Product -> NonTransferableProduct is absent

    condition Basket: <"If the underlier is a basket, it must contain only transferable assets.">
        if underlier -> Observable -> basket exists
        then underlier -> Observable -> basket -> basketConstituent -> asset only exists

    condition Index: <"If the underlier is an Index, then it can only be cash settled.">
        if underlier -> Observable -> index exists
        then settlementTerms -> cashSettlementTerms exists

    condition SettlementTerms: <"Settlement Terms should be defined except for cash.">
        if underlier -> Observable -> asset -> Cash exists
        then settlementTerms exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

type CalculationSchedule: <"A class that allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    schedulePeriod SchedulePeriod (1..*) <"Defines a period of a calculation schedule structure.">

type SchedulePeriod: <"A class that defines the period of a schedule. The period contains a set of start and end dates, quantities, fixing, and pricing data.">
    calculationPeriod DateRange (1..1) <"Period for which the payment is generated.">
    paymentDate date (1..1) <"Adjusted payment date.">
    fixingPeriod DateRange (1..1) <"Period over which the underlying price is observed.">
    deliveryPeriod CalculationScheduleDeliveryPeriods (0..1) <"Period and time profile over which the delivery takes place.">

type FixedPricePayout extends PayoutBase: <"Represents a fixed price payout. There is no underlier associated with this payout type and is based on fixed pricing per a given unit (e.g. in commodities price per barrel)">
    paymentDates PaymentDates (1..1) <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
    fixedPrice FixedPrice (1..1) <"Specifies the fixed price on which fixed forward payments are based.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

type CancelableProvision extends BuyerSeller: <"A data defining:  the right of a party to cancel a swap transaction on the specified exercise dates. The provision is for 'walk-away' cancellation (i.e. the fair value of the swap is not paid). A fee payable on exercise can be specified. As a difference from the FpML construct, the canonical model extends the BuyerSeller class.">
    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    cancelableProvisionAdjustedDates CancelableProvisionAdjustedDates (0..1) <"The adjusted dates associated with a cancelable provision. These dates have been adjusted for any applicable business day convention.">
    finalCalculationPeriodDateAdjustment FinalCalculationPeriodDateAdjustment (0..*) <"Business date convention adjustment to final payment period per leg (swapStream) upon exercise event. The adjustments can be made in-line with leg level BDC's or they can be specified separately.">
    initialFee Transfer (0..1) <"An initial fee for the cancelable option.">
    callingParty CallingPartyEnum (0..1) <"The party with right to exercise a cancellation. Allows for buyer, seller or either.">
    earliestDate AdjustableOrRelativeDate (0..1) <"The first day when cancelation is permitted to take effect. A party may give notice prior to this date and taken together with the effective period would be necessary to cancel on this date.">
    expirationDate AdjustableOrRelativeDate (0..1) <"The last day within the term of the contract that cancelation is allowed.">
    effectiveDate AdjustableOrRelativeDates (0..1) <"The effective date if cancelation is invoked otherwise the cancellation period defines the cancellation date.">
    effectivePeriod Period (0..1) <"Effective period for cancelation when notice is given. This is the period after notice is given that cancellation becomes effecticve.">
    earliestCancellationTime BusinessCenterTime (0..1) <"The earliest time in a business day that notice of cancelation can be given.">
    latestCancelationTime BusinessCenterTime (0..1) <"The latest time at which notice of cancelation can be given.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the cancelable provision, including details such as exercise style, exercise fees, and any other relevant conditions or terms governing the cancellation of the swap transaction.">

    condition EffectiveDate: <"Must select one of predefined cancellation types of effectiveDate or effectivePeriod.">
        optional choice effectiveDate, effectivePeriod

    condition CancelableProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision

type CancelableProvisionAdjustedDates: <"A data to:  define the adjusted dates for a cancelable provision on a swap transaction.">

    cancellationEvent CancellationEvent (1..*) <"The adjusted dates for an individual cancellation date.">

type CancellationEvent: <"The adjusted dates for a specific cancellation date, including the adjusted exercise date and adjusted termination date.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">

type EarlyTerminationEvent: <"A data to:  define the adjusted dates associated with an early termination provision.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">
    adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_39: <"FpML validation rule ird-39 - AdjustedExerciseDate must be before or equal to adjustedEarlyTerminationDate.">
        adjustedExerciseDate <= adjustedEarlyTerminationDate

    condition FpML_ird_40: <"FpML validation rule ird-40 - AdjustedExerciseDate must be before or equal to adjustedCashSettlementValuationDate.">
        adjustedExerciseDate <= adjustedCashSettlementValuationDate

    condition FpML_ird_41: <"FpML validation rule ird-41 - AdjustedCashSettlementValuationDate must be before or equal to adjustedCashSettlementPaymentDate.">
        adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type EarlyTerminationProvision: <"A data defining:  an early termination provision for a swap. This early termination is at fair value, i.e. on termination the fair value of the product must be settled between the parties.">
    [metadata key]

    mandatoryEarlyTermination MandatoryEarlyTermination (0..1) <"A mandatory early termination provision to terminate the swap at fair value.">
    mandatoryEarlyTerminationDateTenor Period (0..1) <"Period after trade date of the mandatory early termination date.">
    optionalEarlyTermination OptionalEarlyTermination (0..1) <"An option for either or both parties to terminate the swap at fair value.">
    optionalEarlyTerminationParameters ExercisePeriod (0..1) <"Definition of the first early termination date and the frequency of the termination dates subsequent to that. American exercise is defined by having a frequency of one day.">

    condition MandatoryEarlyTermination: <"The FpML MandatoryEarlyTermination.model specifies a required choice node. The choice node associated with the FpML EarlyTerminationProvision is quite complex and using the data rule provides a more flexible approach than adding complexity to the condition grammar.">
        (mandatoryEarlyTermination exists or optionalEarlyTermination exists)
            or (mandatoryEarlyTermination exists and optionalEarlyTermination exists)

type ExercisePeriod: <"This defines the time interval to the start of the exercise period, i.e. the earliest exercise date, and the frequency of subsequent exercise dates (if any).">
    [metadata key]

    earliestExerciseDateTenor Period (1..1) <"The time interval to the first (and possibly only) exercise date in the exercise period.">
    exerciseFrequency Period (0..1) <"The frequency of subsequent exercise dates in the exercise period following the earliest exercise date. An interval of 1 day should be used to indicate an American style exercise period.">

type ExtendibleProvision extends BuyerSeller: <"A data defining:  an option to extend an existing swap transaction on the specified exercise dates for a term ending on the specified new termination date. As a difference from FpML, it extends the BuyerSeller class, which represents the BuyerSeller.model.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    extendibleProvisionAdjustedDates ExtendibleProvisionAdjustedDates (0..1) <"The adjusted dates associated with an extendible provision. These dates have been adjusted for any applicable business day convention.">
    callingParty CallingPartyEnum (0..1)
    singlePartyOption PartyRole (0..1) <"If the ability to extend the contract is not available to both parties then this component specifies the buyer and seller of the option.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before a contract is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionTerm RelativeDateOffset (0..1) <"The length of each extension period relative to the effective date of the preceding contract.">
    extensionPeriod AdjustableRelativeOrPeriodicDates (0..1) <"The period within which notice can be given that the contract will be extended.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the extendible provision, including details such as exercise style, exercise fees, and any other relevant conditions or terms governing the extension of the swap transaction.">

    condition ExtendibleProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision

type ExtendibleProvisionAdjustedDates: <"A data defining:  the adjusted dates associated with a provision to extend a swap.">

    extensionEvent ExtensionEvent (1..*) <"The adjusted dates associated with a single extendible exercise date.">

type ExtensionEvent: <"A data to:  define the adjusted dates associated with an individual extension event.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedExtendedTerminationDate date (1..1) <"The termination date if an extendible provision is exercised. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_42: <"FpML validation rule ird-42 - adjustedExerciseDate must be before adjustedExtendedTerminationDate.">
        adjustedExerciseDate < adjustedExtendedTerminationDate

type MandatoryEarlyTermination: <"A data to:  define an early termination provision for which exercise is mandatory.">
    [metadata key]

    mandatoryEarlyTerminationDate AdjustableDate (1..1) <"The early termination date associated with a mandatory early termination of a swap.">
    calculationAgent CalculationAgent (1..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (1..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    mandatoryEarlyTerminationAdjustedDates MandatoryEarlyTerminationAdjustedDates (0..1) <"The adjusted dates associated with a mandatory early termination provision. These dates have been adjusted for any applicable business day convention.">

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination

type MandatoryEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with a mandatory early termination provision.">

    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">

    condition FpML_ird_44: <"FpML validation rule ird-44 - AdjustedEarlyTerminationDate must be before or equal to adjustedCashSettlementValuationDate must be before or the same as adjustedCashSettlementPaymentDate">
        adjustedEarlyTerminationDate <= adjustedCashSettlementValuationDate and adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type OptionalEarlyTermination: <"A data defining:  an early termination provision where either or both parties have the right to exercise.">

    singlePartyOption BuyerSeller (0..1) <"If optional early termination is not available to both parties then this component specifies the buyer and seller of the option. In FpML, this attribute is of type SinglePsrtyOption, which actually consists of the BuyerSeller.model.">
    mutualEarlyTermination boolean (0..1) <"Used for specifying whether the Mutual Early Termination Right that is detailed in the Master Confirmation will apply.">
    exerciseNotice ExerciseNotice (0..*) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    calculationAgent CalculationAgent (0..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (0..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    optionalEarlyTerminationAdjustedDates OptionalEarlyTerminationAdjustedDates (0..1) <"An early termination provision to terminate the trade at fair value where one or both parties have the right to decide on termination.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the optional early termination, including details such as exercise style, exercise fees, and any other relevant conditions or terms.">

    condition OptionalEarlyTerminationExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination

type OptionalEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with an optional early termination provision.">

    earlyTerminationEvent EarlyTerminationEvent (1..*) <"The adjusted dates associated with an individual early termination date.">

type Asian: <"As per ISDA 2002 Definitions.">

    averagingInOut AveragingInOutEnum (1..1)
    strikeFactor number (0..1) <"The factor of strike.">
    averagingPeriodIn AveragingPeriod (0..1) <"The averaging in period.">
    averagingPeriodOut AveragingPeriod (0..1) <"The averaging out period.">

type AveragingCalculation: <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    averagingMethod AveragingCalculationMethod (1..1) <"Specifies enumerations for the type of averaging calculation.">
    precision Rounding (1..1) <"Rounding applied to the average calculation. ">

type AveragingStrikeFeature: <"Defines the terms required to calculate the average observations associated with an averaging strike.">
    averagingCalculation AveragingCalculation (1..1) <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    observationTerms ObservationTerms (1..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. ">

type Barrier: <"As per ISDA 2002 Definitions.">

    barrierCap TriggerEvent (0..1) <"A trigger level approached from beneath.">
    barrierFloor TriggerEvent (0..1) <"A trigger level approached from above.">

type CalendarSpread: <"A type for defining a calendar spread feature.">

    expirationDateTwo AdjustableOrRelativeDate (1..1)

type Composite: <"Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.">

    determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which an amount or a date is determined.">
    relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type FxFeature: <"A type for defining FX Features.">

    referenceCurrency string (1..1) <"Specifies the reference currency of the trade.">
        [metadata id]
        [metadata scheme]
    composite Composite (0..1) <"If 'Composite' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price  Strike Price) / (Strike Price  Settlement Price) x Multiplier provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    quanto Quanto (0..1) <"If 'Quanto' is specified as the Settlement Type in the relevant Transaction Supplement, an amount, as determined by the Calculation Agent in accordance with the Section 8.2 of the Equity Definitions.">
    crossCurrency Composite (0..1) <"If 'Cross-Currency' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price  Strike Price) / (Strike Price  Settlement Price) x Multiplier x one unit of the Reference Currency converted into an amount in the Settlement Currency using the rate of exchange of the Settlement Currency as quoted on the Reference Price Source on the Valuation Date, provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    condition FxFeatureChoice: <" Choice rule to represent an FpML choice construct.">
        required choice composite, quanto, crossCurrency

type Knock: <"Knock In means option to exercise comes into existence. Knock Out means option to exercise goes out of existence.">

    knockIn TriggerEvent (0..1) <"The knock in.">
    knockOut TriggerEvent (0..1) <"The knock out.">

type OptionFeature: <"Defines additional optional features that can be included in an option contract.">

    fxFeature FxFeature (0..*) <"Describes a quanto or composite FX feature.">
    strategyFeature StrategyFeature (0..1) <"Defines a simple strategy feature.">
    averagingFeature AveragingCalculation (0..1) <"Defines an option feature in which an average market observation price is determined on valuation and compared to the strike to determine a settlement amount.">
    barrier Barrier (0..1) <"Specifies a barrier feature.">
    knock Knock (0..1) <"Specifies a knock in or knock out feature.">
    passThrough PassThrough (0..1) <"Specifies the rules for pass-through payments from the underlier, such as dividends.">

type TerminationProvision: <"A class for defining option provisions.">
    cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">
    earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">
    extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">

    condition TerminationProvisionChoice:
        required choice cancelableProvision, extendibleProvision, evergreenProvision, earlyTerminationProvision

type OptionStrike: <"Defines the strike price of an option.">

    strikePrice Price (0..1) <"Defines the strike of an option in the form of a price that could be a cash price, interestRate, or other types.">
    strikeReference FixedRateSpecification (0..1) <"Defines the strike of an option in reference to the spread of the underlying swap (typical practice in the case of an option on a credit single name swaps).">
        [metadata reference]
    referenceSwapCurve ReferenceSwapCurve (0..1) <"Defines the strike of an option when expressed by reference to a swap curve (Typically the case for a convertible bond option).">
    averagingStrikeFeature AveragingStrikeFeature (0..1) <"Defines an  option strike that is calculated from an average of observed market prices.">

    condition:
        one-of

type PassThrough: <"Type which contains pass through payments.">

    passThroughItem PassThroughItem (1..*) <"One to many pass through payment items.">

type PassThroughItem: <"Class to represent a single pass through payment.">

    payerReceiver PayerReceiver (1..1) <"This attribute doesn't exists in the FpML construct, which makes use of the PayerReceiver.model group.">
    passThroughPercentage number (1..1) <"Percentage of payments from the underlier which are passed through.">

type Quanto: <"Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a currency that is different from the currency denomination of the underlier.">

    fxRate FxRate (0..*) <"Specifies a currency conversion rate.">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type StrategyFeature: <"A class for defining option strategy features.">

    strikeSpread StrikeSpread (0..1) <"Definition of the upper strike in a strike spread.">
    calendarSpread CalendarSpread (0..1) <"Definition of the later expiration date in a calendar spread.">

type StrikeSpread: <"A class for defining a strike spread feature.">

    upperStrike OptionStrike (1..1) <"Upper strike in a strike spread.">
    upperStrikeNumberOfOptions number (1..1) <"Number of options at the upper strike price in a strike spread.">

type ExerciseTerms: <"A class defining the exercise period for an option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
    [metadata key]

    style OptionExerciseStyleEnum (0..1) <"Whether the option has a single exercise (european), multiple exercise dates (bermuda), or a continuous range of exercise (american).">
    commencementDate AdjustableOrRelativeDate (0..1) <"The first day of the exercise period for an American style option.">
    exerciseDates AdjustableOrRelativeDates (0..1) <"The dates that define the Bermuda option exercise dates and the expiration date. The last specified date is assumed to be the expiration date. The dates can either be specified as a series of explicit dates and associated adjustments or as a series of dates defined relative to another schedule of dates, for example, the calculation period start dates. Where a relative series of dates are defined the first and last possible exercise dates can be separately specified.">
    expirationDate AdjustableOrRelativeDate (0..*) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
    relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.'">
    earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) to, and including, the expiration date.">
    latestExerciseTime BusinessCenterTime (0..1) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
    expirationTime BusinessCenterTime (0..1) <"The latest time for exercise on expirationDate. It is made mandatory given that for all option styles, this field is required.">
    expirationTimeType TimeTypeEnum (0..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
    multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
    exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">
    exerciseProcedure ExerciseProcedure (0..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">
    exerciseFee ExerciseFee (0..1) <"A fee to be paid on exercise. This could be represented as an amount or a rate and notional reference on which to apply the rate.">
    partialExercise PartialExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.3. Partial Exercise, the buyer of the option has the right to exercise all or less than all the notional amount of the underlying swap on the expiration date, but may not exercise less than the minimum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">

    condition ExpirationTime: <"This condition ensures consistency between expirationTimeTypeEnum value and the specific time, when being effectively specified.">
    if expirationTimeType exists 
    then  expirationTimeType = TimeTypeEnum -> SpecificTime
    
    condition ExerciseDateExpirationDateChoice: <"Required choice rule between exercise dates and expiration date. The exerciseDates field can be used to extract the expiration date of a bermuda option, while the expirationDate field refers to the expiration date of an american or european option.">
        required choice exerciseDates, expirationDate

    condition CommencementAndExpirationDate: <"Condition to check that expiration date is present when commencement date is present.">
        if commencementDate exists then expirationDate exists

    condition AmericanExercise: <"Condition to check that only fields expected for an american option are present.">
        if style = OptionExerciseStyleEnum -> American
        then commencementDate exists
                and exerciseFee is absent
                and partialExercise is absent
                and expirationDate count = 1

    condition EuropeanExercise: <"Condition to check that only fields expected for a european option are present.">
        if style = OptionExerciseStyleEnum -> European
        then expirationDate exists
                and exerciseFeeSchedule is absent
                and multipleExercise is absent
                and latestExerciseTime is absent
                and commencementDate is absent

    condition BermudaExercise: <"Condition to check that only fields expected for a bermuda option are present.">
        if style = OptionExerciseStyleEnum -> Bermuda
        then exerciseDates exists
                and earliestExerciseTime exists
                and partialExercise is absent
                and exerciseFee is absent

type AutomaticExercise: <"A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more than the threshold amount on the exercise date.">

    thresholdRate number (0..1) <"A threshold rate. The threshold of 0.10% would be represented as 0.001">
    isApplicable boolean (0..1) <"Boolean that indicates if it has an automaticExercise">

type ExerciseFee extends PayerReceiver: <"A class defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmount number (0..1) <"The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.">
    feeRate number (0..1) <"A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmount, feeRate

type ExerciseFeeSchedule extends PayerReceiver: <"A class to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmountSchedule AmountSchedule (0..1) <"The exercise fee amount schedule. The fees are expressed as currency amounts. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feeRateSchedule Schedule (0..1) <"The exercise free rate schedule. The fees are expressed as percentage rates of the notional being exercised. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeScheduleChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmountSchedule, feeRateSchedule

type ExerciseNotice: <"Defines to whom and where notice of execution should be given. The exerciseNoticeGiver refers to one or both of the principal parties of the trade. If present the exerciseNoticeReceiver refers to a party, other than the principal party, to whom notice should be given.">

    exerciseNoticeGiver ExerciseNoticeGiverEnum (1..1) <"Specifies the principal party of the trade that has the right to exercise.">
    exerciseNoticeReceiver AncillaryRoleEnum (0..1) <"Specifies the party to which notice of exercise should be given, e.g. by the buyer of the option. Although in many cases it is the buyer of the option who sends the exercise notice to the seller of the option, this component is reused, e.g. in case of OptionEarlyTermination, either or both parties have the right to exercise.">
    businessCenter BusinessCenterEnum (1..1) <"Specifies the location where the exercise must be reported, e.g. where the exercise notice receiver is based.">
        [metadata scheme]

type ExerciseProcedure: <"A class describing how notice of exercise should be given. This can be either manual or automatic.">

    manualExercise ManualExercise (0..1) <"Specifies that the notice of exercise must be given by the buyer to the seller or seller's agent.">
    automaticExercise AutomaticExercise (0..1) <"If automatic is specified, then the notional amount of the underlying swap not previously exercised under the swaption will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    limitedRightToConfirm boolean (0..1) <"Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Confirm Exercise. If present, (i) the Seller may request the Buyer to confirm its intent if not done on or before the expiration time on the Expiration date (ii) specific rules will apply in relation to the settlement mode.">
    splitTicket boolean (0..1) <"Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the party required to deliver the bonds will divide those to be delivered as notifying party desires to facilitate delivery obligations.">

    condition ExerciseProcedureChoice: <"Choice rule to represent an FpML choice construct.">
        required choice manualExercise, automaticExercise

type ManualExercise: <"A class defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    fallbackExercise boolean (0..1) <"If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the swaption, will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than one tenth of a percentage point (0.10% or 0.001). The term in-the-money is assumed to have the meaning defined in the 2000 ISDA Definitions, Section 17.4. In-the-money.">

    condition ManualExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual

type MultipleExercise extends PartialExercise: <"A class defining multiple exercises. As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more than the maximum notional amount, and if an integral multiple amount is specified, the notional exercised must be equal to or, be an integral multiple of, the integral multiple amount. In FpML, MultipleExercise is built upon the PartialExercise.model.">

    maximumNotionalAmount number (0..1) <"The maximum notional amount that can be exercised on a given exercise date.">
    maximumNumberOfOptions int (0..1) <"The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it means that the maximum number of options corresponds to the remaining unexercised options.">

    condition MaximumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice maximumNotionalAmount, maximumNumberOfOptions

    condition MaximumNumberOfOptions: <"FpML MultipleExercise construct specifies the maximumNumberOfOptions as a positive integer.">
        if maximumNumberOfOptions exists
        then maximumNotionalAmount >= 0

    condition MinimumNumberOfOptions: <"FpML MultipleExercise construct specifies the minimumNumberOfOptions as a positive integer.">
        if minimumNumberOfOptions exists
        then minimumNumberOfOptions >= 0

type PartialExercise: <"A class defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all or less than all the notional amount of the underlying swap but may not be less than the minimum notional amount (if specified) and must be an integral multiple of the integral multiple amount if specified.">

    notionaReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.">
        [metadata reference]
    integralMultipleAmount number (0..1) <"A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.">
    minimumNotionalAmount number (0..1) <"The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.">
    minimumNumberOfOptions int (0..1) <"The minimum number of options that can be exercised on a given exercise date.">

    condition MinimumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice minimumNotionalAmount, minimumNumberOfOptions

type Strike: <"A class describing a single cap or floor rate.">
    [metadata key]

    strikeRate number (1..1) <"The rate for a cap or floor.">
        [synonym FIX_5_0_SP2 value "StrikePrice" tag 202]
    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type StrikeSchedule extends RateSchedule: <"A class describing a schedule of cap or floor rates.">

    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type AssetPayout extends PayoutBase: <"Security finance payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction. Plus additional description for ICMA.">
    assetLeg AssetLeg (1..*) <"Defines each asset movement as a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    underlier Asset (1..1) <"Specifies the Purchased Asset, usually a Security.">
    // [metadata address "pointsTo"=PriceQuantity->observable->Asset->Instrument->Security]
    minimumFee Money (0..1) <"A contractual minimum amount which the borrower will pay, regardless of the duration of the loan. A mechanism for making sure that a trade generates enough income.">
    dividendTerms DividendTerms (0..1) <"Specifies the terms under which dividends received by the borrower are passed through to the lender.">
    repoType RepoTypeEnum (0..1) <"Repurchase transactions and buy/sell-backs are both types of repo; this enumerator helps differentiate the two.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition UnderlierNotCash: <"The purchased asset in an assetPayout should not be cash.">    
        underlier -> Cash is absent

type DividendTerms: <"Information related to dividends and payments.">
    manufacturedIncomeRequirement DividendPayoutRatio (1..1) <"Specifies the proportion of the value of the dividend on the borrowed shares that the borrower is legally obligated to return to the lender.">
    dividendEntitlement DividendEntitlementEnum (0..1) <"Defines the date on which the receiver of the equity return is entitled to the dividend.">
    minimumBillingAmount Money (0..1) <"daily fee increments accrue until a threshold is crossed, at which point payment becomes due)">

type AssetLeg: <"Defines each asset movement of an asset payout.">
    settlementDate AdjustableOrRelativeDate (1..1) <"Specifies the settlement date of securities.  In a repo transaction the purchase date would always be the effective date as specified under Economic Terms, the repurchase date would always be the termination date as specified under Economic Terms.">
    deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

type EvergreenProvision: <"Specifies a transaction which automatically extends for a specified timeframe until the exercise of an embedded option.">
    singlePartyOption PartyRole (0..1) <"If evergreen termination is not available to both parties then this component specifies the buyer and seller of the option.">
    noticePeriod RelativeDateOffset (1..1) <"The length of each evergreen extension period relative to the effective date of the preceding contract.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before an evergreen is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionFrequency AdjustableRelativeOrPeriodicDates (1..1) <"The frequency with which the evergreen contract will be extended if notice is not given.">
    finalPeriodFeeAdjustment Price (0..1) <"An optional adjustment to the rate for the last period of the evergreen i.e. the period from when notice is given to stop rolling the contract through to the termination date.">


  //condition : 
  //required choice fixedPrice, observablePrice

type NewBasePrice:

    fixedPrice PriceSchedule (0..1)
        [metadata address]
    observablePrice PayoutObservable (0..1)

    condition : 
  required choice fixedPrice, observablePrice

type NewBaseValue extends NewBasePrice:

  quantity QuantitySchedule (0..1)
        [metadata address]

    condition : 
  required choice fixedPrice, observablePrice, quantity

type NewStructuredTerms:
    [metadata key]

  aggregationFeature NewValueAggregation (0..1) <"Represent functional operations of type : [ F(X1, X2, ...Xn) = X0 ] where : [X1], [X2], ..., X[Xn] are values of the parent object; [X0] is the unique output value after resolving; F([X]) is a commutative function to apply for resolving input values i.e. Sum, Multiply, Min, Max, Average. The aggregationMethod is operating multiple values either when multiple attribute exit in array, else when multiple values exist in time series in type DatedValue.">
    [metadata reference] 
  knockCondition NewKnockCondition (0..*) <"Represents the funtional operation [ F(X,In) = X x (Boolean) ] or the functional operation [ F(X,Out) = X x (1 - Boolean) ] where : [In] or [Out] designates the knockType, [Boolean] equals [1] when the triggerCondition is verified as true, else equals [0], and [X] is the value of the object for which KnockCondition is defined as an attribute.">
    [metadata reference]
  capFloorBarrier NewCapFloorBarrier (0..*) <"Represents the functional operation [ F(X,Cap) = min(X,Cap) ] or the functional operation [ F(X,Floor) = max(X,Floor) ] where : [Cap] or [Floor] is the value of the barrierLevel for the given barrierType and [X] is the value of the object for which CapFloor is defined as an attribute.">
    [metadata reference]
  multiplierDivisor NewMultiplierDivisor (0..1) <"Represents the functional operation [ F(X) = X x M ] or the functional operation [ F(X) = X x 1/D ] where: [M] is the value of a Multiplier, [D] is the value of a Divisor and [X] is the value of the object for which Divisor is defined as an attribute.">
    [metadata reference]
  
  condition MultipleCapFloor:<"One cannot cumulate two Cap or two Floor with each other, or more, unless some of these are contigent (rephrasing, for the avoidance of doubt : a Cap cannot apply to another Cap, respectively a Floor cannot apply to another Floor, unless at least one of them is contigent).">
  if capFloorBarrier -> barrierType all = NewCapFloorEnum -> Cap
  or capFloorBarrier -> barrierType all = NewCapFloorEnum -> Floor
  or capFloorBarrier count > 2
  then capFloorBarrier -> knockCondition exists

//valueOperator NewValueOperator (0..1)
  //  [metadata reference] 

type NewValueAggregation: <"The aggregation operation to be applied for resolving multiple values of the object for which this attribute is populated, into one value i.e. the aggregationMethod represents a enumerated list of functional operations of type : [ F(X1, X2, ...Xn) = X0 ] where : [X1], [X2], ..., X[Xn] are values of the parent object and [X0] is the unique output value after resolving, and : F([X]) is the commutative function to apply for resolving input values e.g. Sum, Multiply, Min, Max, Average. 
  The aggregationMethod is processing either values in array, else values in time series. 
  Besides, multiple aggregation or ranking are composable in sorted manner via the aggregationLoop attribute (considering a matrix of dateValue with observable in row and date in column for instance, then any combination of vertical or horizontal aggreation can be represented). 
  Optionnaly, a rankingMethod may be defined prior to aggregating the values, say for representing so-called 'rainbow' features in some derivatives products (example : net payout consisting in ranking the 1th, the 2nd and the 3rd performance among multiple ones being compared, usually with distinct weight per rank, before being aggregated to calculate the final value).">
 [metadata key]
  aggregationMethod NewAggregationMethod (1..1) <"Defines the method in which multiple values can be aggregated into a single value. It is a set of commutative functions e.g. Sum, Multiply, Min, Max, Average. Importantly, two dimensions may be considered when aggregating : value series resulting from an object with unbound cardinality, else multiple value resulting from dateValue series - hence an optional choice below between the attributes which represent each of these two dimentions : valueSeriesAggregation or datedValueSeriesAggregation.">
  rankingMethod NewRankingMethod (0..*) <"Defines that one or several values shall be selected in regards of their rank in the value series e.g. the 2nd and/or the 3rd and/or the 'nth' when sorting either from lowest to the highest value in the series, or vice-versa. As an indication, when only one is to be selected that being either the Best or the Worst, then aggregationMethod shall be used (instead of rankingMethod, hence condition below) with Max or Min value, as relevant.">
  aggregationDate NewDateRelativeToEnum (0..1) <"The enumerated values to specify the type of date to be used as an anchor.">
  aggregationLoop NewValueAggregation (0..1) <"Permits to compound valueAggregation series in sorted manner, assuming that sorting order shall be read from the left end-value to the right start-value of the nested series e.g. say aggregationMethod(a) shall be applied first then aggregationMethod(b) shall apply to the calculatedValue(a), then one shall represent such loop as aggregationMethod(b)->aggregationLoop->aggregationMethod(a). As indication, such 'left-to-right' interpretation of nesting series is straight applicaiton of the base set theory interpretation per which the embedded inclusion of parties sets within each others is per se an ordering expression e.g. given sets of parties (a) and ((a),b) then considering embedded inclusions would result in resolving (a) as being the start value and ((a),b) being the subsequent value.">
  bespokeName NewBespokeName (0..1) <"Any bespoke name or description that may be specified.">
  calculatedValue DatedValue (0..1) <"The numerical value or dated value which corresponds to the resolved value of the parent object for which this attribute is populated e.g. output from valueOperator or aggregationOperator.">
    [metadata reference]

//type NewValueOperator: <"The set of operations mostly inspired from usual features found in structured product terms, to be applied for resolving the value of the object for which this attribute is populated. Each attribute represents a functional operation of type : F(X,Operator) where [X] is the value of the object for which [Operator] is defined as an attribute. This set encompasses three foundational types of operations, which permit (1) to make the existence of the parent object contigent via KnockCondition or (2) to bound its value via CapFloorBarrier or (3) to modulate the slope of its value via multiplerDivisor.">
  //[metadata key]

  //knockCondition NewKnockCondition (0..*) <"Represents the funtional operation [ F(X,In) = X x (Boolean) ] or the functional operation [ F(X,Out) = X x (1 - Boolean) ] where : [In] or [Out] designates the knockType, [Boolean] equals [1] when the triggerCondition is verified as true, else equals [0], and [X] is the value of the object for which KnockCondition is defined as an attribute. If any, multiple instance represent additive expression in series e.g. say knockCondition[K1], knockCondition[K2,], ..., knockCondition[Kn] exist, then this represents the functional operation [ F(X, knockCondition) = F(X,K1) + F(X,K2) + ... + F(X,Kn) ], where the '+' sign is equivalent to the logical meaning of an 'OR/OR' condition i.e. at least one being verified is sufficient for the KnockCondition to apply'. As an indication, for the purpose of defining multiple Knock Conditions with logical meaning of an 'AND/AND' condition i.e. cumulative conditions where all must be verified for the parent KnockCondition to apply, one shall define such nested series via knockCondition -> cumulativeKnockCondition attribute.">
 //   [metadata reference]
 // capFloorBarrier NewCapFloorBarrier (0..*) <"Represents the functional operation [ F(X,Cap) = min(X,Cap) ] or the functional operation [ F(X,Floor) = max(X,Floor) ] where : [Cap] or [Floor] is the value of the barrierLevel for the given barrierType and [X] is the value of the object for which CapFloor is defined as an attribute. If any, multiple instance represent additive expression in series e.g. say Cap[C1], Cap[C2,], ..., Cap[Cn] exist, then this represents the functional operation [ F(X,C) = F(X,C1) + F(X,C2) + ... + F(X,Cn) ], where the '+' sign is equivalent to logical expression type 'OR'. As an indication, if multiple Cap exist as with such example, each will exist with distinct knockCondition, meaning barrierLevel values are contigent ; else when multiple barrierLevel values are fixed, then only one Cap shall exist with multiple datedValue defined in the PriceSchedule type of barrierLevel.">
  //  [metadata reference]
 // multiplierDivisor NewMultiplierDivisor (0..1) <"Represents the functional operation [ F(X) = X x M ] or the functional operation [ F(X) = X x 1/D ] where: [M] is the value of a Multiplier, [D] is the value of a Divisor and [X] is the value of the object for which Divisor is defined as an attribute.">
  //  [metadata reference]
  
 // condition MultipleCapFloor:<"One cannot cumulate two Cap or two Floor with each other, or more, unless some of these are contigent (rephrasing, for the avoidance of doubt : a Cap cannot apply to another Cap, respectively a Floor cannot apply to another Floor, unless at least one of them is contigent).">
  //if capFloorBarrier -> barrierType all = NewCapFloorEnum -> Cap
 // or capFloorBarrier -> barrierType all = NewCapFloorEnum -> Floor
 // or capFloorBarrier count > 2
 // then capFloorBarrier -> knockCondition exists

type NewKnockCondition: <"Represents the functional operation [ F(X,In) = X x (Boolean) ] or the functional operation [ F(X,Out) = X x (1 - Boolean) ] where : [In] or [Out] designates the knockType, [Boolean] equals [1] when the triggerCondition is verified as true, else equals [0], and [X] is the value of the object for which KnockCondition is defined as an attribute. Accordingly, this specifies that the existence of the parent object for which KnockCondition is defined as an attribute is contigent, either because it does not exists until the condition is verified as true, which is defined as the Knock-In type, or because it does exist unless the condition is verified as true, which is defined as the Knock-Out type.">
  [metadata key]

  knockType NewKnockTypeEnum (1..1) <"Designates the knockType, either [In] or [Out] in the funtional operation [ F(X,In) = X x (Boolean) ] or the functional operation [ F(X,Out) = X x (1 - Boolean) ] where [Boolean] equals [1] when the triggerCondition is verified as true, else equals [0], and [X] is the value of the object for which KnockCondition is defined as an attribute.">
  triggerCondition NewTriggerCondition (1..*) <"Specifies the criteria for determining whether the KnockCondition is activated or not.">
  knockEffectDuration Frequency (1..1) <"The duration of the existence or non-existence of the related Object once the Knock-In or Knock-Out has been activated e.g. 1T standing for 1 'Term' would indicate a 'one touch' effect that is to say if knocked once, this means once for all until trade is terminated, else 1D would indicate the effect exists for the knocking day only, then this coupled with a daily observation would correspond to daily knock being reset e.g. that would represent the same as bounded variance involved in corridor varswap as an example, etc.">
  cumulativeKnockCondition NewKnockCondition (0..*) <"Defines additional Knock Conditions which are cumulative in regards of the parent Knock Condition i.e. the KnockCondition is all in all verified if both the parent one and all the cumlative ones in series are verified as well. From a logical perspective, cumulativeKnockCondition has the meaning of an 'AND/AND' condition. As an indication, for the purpose of defining multiple Knock Conditions with logical meaning of an 'OR/OR' condition i.e. at least one being verified is sufficient for the KnockCondition to apply, one should define multiple KnockCondition at the same root level.">
    [metadata address]
  bespokeName NewBespokeName (0..1) <"Any bespoke name or description that may be specified.">
  calculatedValue DatedValue (0..1) <"The net results of the KnockConditions assessments may be recorded as datedValue series with only boolean values i.e. either 0 or 1 per each date. As an indication, if multiple triggerCondition exists, then resolving the net calculatedValue consists in calculating dated series as the sum of the multiple calculatedValue per observation date ; if one or several cumulativeKnockCondition exist, then resolving the net calculatedValue consists in compounding i.e. multiplying the multiple calculatedValue by each others, per each observation date.. ">
    [metadata reference]

  condition CalculationResult: <"The results of the KnockConditions assessments may be recorded as datedValue series with only boolean values i.e. either 0 or 1 per each date.">
    if calculatedValue exists
    then calculatedValue -> value = 0 or calculatedValue -> value = 1

type NewTriggerCondition: <"Specifies the criteria for determining whether the KnockCondition is activated or not, notably the trigger level, the related observable, as well as the trigger rule to define their relation.">

  triggerLevel NewBaseValue (1..1) <"The value of the trigger level.">
  triggerBaseRule TriggerTypeEnum (1..1) <"Specifies the criteria for determining whether the triggerLevel is deemed to have been knocked or not by the observable value.">
  triggerBasketRule NewTriggerTypeForBasketEnum (0..1) <"Specifies the conditions when multiple observable values shall be taken into account for determining whether the triggerLevel is deemed to have been knocked or not, for instance when the observable values are basket constituents.">
  observable Observable (0..1) <"The observable value to be assessed, in regards of the trigger level, in accordance with the trigger rules. Importantly, this attribute is optional, since the observable to be considered by default is the one attached at Payout level, that is to say there is no need to populate observable under TriggerCondition when it is the same as the one at Payout level.">
  observationTerms  ObservationTerms (0..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multiple observations. Importantly, this attribute is optional, since the observationTerms to be considered by default are the one defined at PayoutBase level ">
  cumulativeTriggerCondition NewTriggerCondition (0..*) <"Defines additional Trigger rules which are cumulative in regards of the root parent Trigger i.e. all such triggers must be met for the purpose of having an effect. From a logical perspective, the cumulativeTriggerRule has the meaning of an 'AND' condition (as an indication, for the purpose of defining additional Trigger with logical meaning of an 'OR' condition i.e. either is sufficient to have an effect, one should define multiple Trigger at the same root level).">
  calculatedValue DatedValue (0..1) <"The results of the KnockConditions assessments may be recorded as datedValue series with only boolean values i.e. either 0 or 1 per each date.">
    [metadata reference]

  condition CalculationResult:<"The results of the KnockConditions assessments may be recorded as datedValue series with only boolean values i.e. either 0 or 1 per each date.">
    if calculatedValue exists
    then calculatedValue -> value = 0 or calculatedValue -> value = 1

type NewCapFloorBarrier: <"Represents the functional operation [ F(X,Cap) = min(X,Cap) ] or the functional operation [ F(X,Floor) = max(X,Floor) ] where : [Cap] or [Floor] is the value of the barrierLevel for the given barrierType i.e. Cap or Floor and [X] is the value of the object for which CapFloor is defined as an attribute.">
  [metadata key]

  barrierType NewCapFloorEnum (1..1) <"The enumerated values to specify whether the barrier is a Cap or Floor.">
  barrierLevel NewBaseValue (1..1) <"The value of the Cap or Floor level.">
  knockCondition NewKnockCondition (0..1) <"Represents the funtional operation [ F(X,In) = X x (Boolean) ] or the functional operation [ F(X,Out) = X x (1 - Boolean) ] where : [In] or [Out] designates the knockType, [Boolean] equals [1] when the triggerCondition is verified as true, else equals [0], and [X] is the value of the object for which KnockCondition is defined as an attribute">
    [metadata reference]
  calculatedValue DatedValue (0..1) <"The numerical value or dated value which corresponds to the resolved value of the parent object for which this attribute is populated.">
    [metadata reference]
  bespokeName NewBespokeName (0..1) <"Any bespoke name or description that may be specified.">

type NewMultiplierDivisor: <"Represents the functional operation [ F(X) = X x M ] or the functional operation [ F(X) = X x 1/D ] where: [M] is the value of a Multiplier, [D] is the value of a Divisor and [X] is the value of the object for which Divisor is defined as an attribute. If any, multiple instances represent a straight concatenation of the same functional operation e.g. say Multiplier[M1], Multiplier[M2], ..., Multiplier[Mn] exist, also possiby with Divisor[D1], Divisor[D2], ..., Divisor[Dm] then this represents the functional operation [ F(X) = X x M1 x M2 x .... x Mn x 1/D1 x 1/D2 x .... x 1/Dm ].">
    [metadata key]

  multiplier NewMultiplier (0..*) <"Represents the functional operation [ F(X) = X x M ] where : [M] is the value of the Divisor and [X] is the value of the object for which Multiplier is defined as an attribute. If any, multiple instances represent a straight concatenation of the same functional operation e.g. say Multiplier[M1], Multiplier[M2], ..., Multiplier[Mn] exist, then this represents the functional operation [ F(X) = X x M1 x M2 x .... x Mn ].">
    [metadata reference]
  divisor NewMultiplier (0..*) <"Represents the functional operation [ F(X) = X x 1/D ] where : [D] is the value of the Divisor and [X] is the value of the object for which Divisor is defined as an attribute. If any, multiple instances represent a straight concatenation of the same functional operation e.g. say Divisor[D1], Divisor[D2], ..., Divisor[Dn] exist, then this represents the functional operation [ F(X) = X x 1/D1 x 1/D2 x .... x 1/Dn ].">
    [metadata reference]
  calculatedValue DatedValue (0..1) <"The numerical value which corresponds to the resolved value of the parent object for which this attribute is populated.">
    [metadata reference]
  bespokeName NewBespokeName (0..1) <"Any bespoke name or description that may be specified.">

type NewMultiplier extends NewBaseValue: <"Represents the functional operation [ F(X) = X x M ] where : [M] is the value of the Multiplier and [X] is the value of the object for which Multiplier is defined as an attribute.">
  [metadata key]

  observationCountValue NewObservationCount (0..1) <"Specifies when the multiplier value is an integer number of observations.">
  dayCountFractionValue cdm.base.datetime.daycount.DayCountFractionEnum (0..1) <"The multiplier value is the dayCountFraction value">
  applicableToNthRankValue NewRankingMethod (0..1) <"Specifies that the multiplier only applies to the corePayoutValue resolved in accordance with the referenced rankingMethod.">
    [metadata reference] 

  condition ObservationValueIsKnockCount: <"Any bespoke name or description that may be specified.">
  if observationCountValue-> observationValueType = NewObservationCountEnum -> KnockedObservations
  then observablePrice -> structuredTerms -> knockCondition exists


 



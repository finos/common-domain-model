namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.mapping.config.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.asset.*
import cdm.product.collateral.*
import cdm.product.common.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*

type TransferableProduct extends Asset: <"A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific EconomicTerms.">
    economicTerms EconomicTerms (1..1) <"The price forming features, including payouts and provisions.">

type EconomicTerms: <" This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, the effective and termination date and the date adjustment provisions when applying uniformily across the payout components. This class also includes the legal provisions which have valuation implications: cancelable provision, extendible provision, early termination provision and extraordinary events specification.">

    effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
        [docReference ICMA GMRA namingConvention "Purchase Date"
            provision "As defined in GMRA paragraph 2(mm) The date on which Purchased Securities are sold or are to be sold by Seller to Buyer."]
        [docReference ICMA ERCCBestPractice namingConvention "Purchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the value date of a repo."]
    terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
        [docReference ICMA GMRA namingConvention "Repurchase Date"
            provision "As defined in GMRA paragraph 2(qq) The date on which Buyer is to sell Equivalent Securities to Seller."]
        [docReference ICMA ERCCBestPractice namingConvention "Repurchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the maturity date of a repo."]
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day adjustment convention when it applies across all the payout components. This specification of the business day convention and financial business centers is used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
    payout Payout (1..*) <"The payout specifies the future cashflow computation methodology which characterizes a financial product.">
    terminationProvision TerminationProvision (0..1) <"Contains optional provisions pertaining to the termination characteristics of a contract.">
    calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
    nonStandardisedTerms boolean (0..1) <"Specifies, when boolean value is True, that additional economic terms exist that have not been included in the product representation.">
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">

    condition ReturnType_Total_Requires_Dividends: <"A total return implies both a price and a dividend return">
        if payout -> PerformancePayout -> returnTerms -> priceReturnTerms -> returnType all = ReturnTypeEnum -> Total
        then payout -> PerformancePayout -> returnTerms -> dividendReturnTerms exists

    condition LastRegularPaymentDate: <"FpML specifies that lastRegularPaymentDate must only be included if there is a final stub. As part of the CDM, this data rule has been adjusted to specify that it only applies to interest rate swaps, as the credit derivatives products can have a specified lastRegularPaymentDate while the stub is typically not applicable to those.">
        if payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and payout -> InterestRatePayout -> stubPeriod -> finalStub exists
        then payout -> InterestRatePayout count = 2

    condition PayRelativeTo: <"FpML specifies a required payRelativeTo element as part of the PaymentDates. As standardized CDS don't have such payRelativeTo provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
                and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> payRelativeTo exists

    condition PaymentDatesAdjustments: <"FpML specifies a required paymentDatesAdjustments element as part of the PaymentDates. As standardized CDS don't have such paymentDatesAdjustments provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
                and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> paymentDatesAdjustments exists

    condition PaymentFrequency: <"FpML specifies a required paymentFrequency element as part of the PaymentDates. As standardized CDS may not have such paymentFrequency provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
                and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> paymentFrequency exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        if payout -> OptionPayout exists
        then payout -> OptionPayout -> priceQuantity exists
                or payout -> OptionPayout -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2

    condition DayCountFraction: <"FpML specifies a required dayCountFraction element as part of the swapStream/calculationPeriodAmount/calculation. As standardized CDS don't have such specified day count fraction, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
        then payout -> InterestRatePayout -> dayCountFraction exists

    condition PaymentDates: <"FpML specifies a required paymentDates element as part of the swapStream. As standardized CDS may not have specified payment dates, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
        then payout -> InterestRatePayout -> dayCountFraction exists

    condition MarketPrice: <"FpML specifies that marketFixedRate and marketPrice only have meaning in a credit index trade">
        if payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
        then payout -> CreditDefaultPayout -> transactedPrice -> marketFixedRate is absent
                and payout -> CreditDefaultPayout -> transactedPrice -> marketPrice is absent

    condition NotionalResetOnPerformancePayout: <"Notional reset only applies to return swaps, and therefore can only exist on an performancePayout or interestRatePayouts that are associated with it.">
        payout -> CreditDefaultPayout -> priceQuantity -> reset is absent
            and payout -> AssetPayout -> priceQuantity -> reset is absent
            and payout -> CommodityPayout -> priceQuantity -> reset is absent
            and payout -> FixedPricePayout -> priceQuantity -> reset is absent
            and payout -> SettlementPayout -> priceQuantity -> reset is absent
            and payout -> OptionPayout -> priceQuantity -> reset is absent

    condition NotionalResetInterestRatePayoutExists: <"As the performancePayout->payoutQuantity->reset attribute applies to return swaps, the interestRatePayout needs to be present alongside it.">
        if payout -> PerformancePayout -> priceQuantity -> reset contains True
        then payout -> InterestRatePayout exists

    condition FpML_cd_26_28: <"FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate. This data rule tackles those two FpML validation rules at once, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute.">
        // Cashflow is no longer part of the product so this condition cannot be tested at the economic terms level.
        // Consider adding a generic validation at the trade state level that any cashflow must be between effective and termination dates.
        True

    condition FpML_cd_27: <"FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        // Cashflow is no longer part of the product so this condition cannot be tested at the economic terms level.
        // Consider adding a generic validation at the trade state level that any cashflow must be between effective and termination dates.
        True

    condition FpML_cd_30: <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        if payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and terminationDate exists
        then payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> unadjustedDate or payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> adjustedDate

    condition IndependentCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentIndependent

    condition AssetPayoutDividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then it should be a Term trade.">
        if payout -> AssetPayout -> dividendTerms exists
        then terminationDate exists

type OptionPayout extends PayoutBase: <" The option payout specification terms. The associated globalKey denotes the ability to associate a hash value to the respective OptionPayout instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    buyerSeller BuyerSeller (1..1)
    feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">
    observationTerms ObservationTerms (0..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. To be used for option contracts that reference a benchmark price.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    underlier Underlier (1..1) <"The financial product underlying the option, which can be of any type including an Asset, Basket, Index or a NonTransferableProduct.">
    optionType OptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
    exerciseTerms ExerciseTerms (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
    strike OptionStrike (0..1) <"Specifies the strike of the option">

    condition ClearedPhysicalSettlementExists:
        if settlementTerms -> physicalSettlementTerms exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2
        then settlementTerms -> physicalSettlementTerms -> clearedPhysicalSettlement exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

    condition OptionStylePresent: <"This condition ensures that an optionPayout contains the style of option within its exercise terms.">
        exerciseTerms -> style exists

    condition OptionTypePresent: <"This condition ensures that an option type is set when the underlier is not a non-transferable product.">
        if underlier -> Product -> NonTransferableProduct is absent
        then optionType exists

type ReturnTerms: <"Specifies the type of return of a performance payout.">

    priceReturnTerms PriceReturnTerms (0..1) <"Return terms based upon the underlier's observed price.">
    dividendReturnTerms DividendReturnTerms (0..1) <"Return terms based upon dividend payments associated to the underlier.">
    varianceReturnTerms VarianceReturnTerms (0..1) <"Return terms based upon the observed variance of the underlier's price.">
    volatilityReturnTerms VolatilityReturnTerms (0..1) <"Return terms based upon the observed volatility of the underlier's price.">
    correlationReturnTerms CorrelationReturnTerms (0..1) <"Return terms based upon the observed correlation between the components of the underlying basket.">

    condition ReturnTermsExists: <"Checks that the return type label matches the actual return terms structure of the product.">
        if priceReturnTerms -> returnType = ReturnTypeEnum -> Total
        then (priceReturnTerms, dividendReturnTerms) only exists
        else if priceReturnTerms -> returnType = ReturnTypeEnum -> Price
        then priceReturnTerms only exists
        else priceReturnTerms only exists
            or dividendReturnTerms only exists
            or varianceReturnTerms only exists
            or volatilityReturnTerms only exists
            or correlationReturnTerms only exists

type PerformancePayout extends PayoutBase: <"Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation products.">
    observationTerms ObservationTerms (0..1) <"Defines how and when a performance type option or performance type swap is to be observed.">
    valuationDates ValuationDates (1..1) <"Defines how and when a performance type option or performance type swap is to be valued, including both interim and final valuation.">
    paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
    underlier Underlier (0..1) <"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
    fxFeature FxFeature (0..*) <"Defines quanto or composite FX features that are included in the swap leg.">
    returnTerms ReturnTerms (0..1) <"Specifies the type of return of a performance payout.">
    portfolioReturnTerms PortfolioReturnTerms (0..*) <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level">
    initialValuationPrice PriceSchedule (0..*) <"Specifies the net initial valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the net initial valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"Specifies the net final valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

    condition Underlier: <"The underlier on a performance payout can only be an observable.">
        underlier -> Observable exists

    condition PortfolioOrStraightReturn:
        required choice returnTerms, portfolioReturnTerms

    condition PortfolioReturnIsMultipleReturns: <"No single portfolioReturnTerms instance shall exist because it would be a duplicate of straight returnTerms.">
        if portfolioReturnTerms exists
        then portfolioReturnTerms count > 1

    condition UnderlierOfPortfolioIsBasket: <"A portfolio made of multiple individual legs in portfolio, is a strategy that consider the Basket in transparency, thus having a Basket as an underlier of the PerformancePayout that is aggregation level and multiple individual legs in portfolio, each with an underlier to correspond to each Basket consituent. This is particular usage of portfolio attribute, hence the condition, being aknowledged that other usages would not require Basket to exist at this level, for instance a dispersion strategy where 'N+1' multiple portfolio return legs would exist, '1' with underlier->Basket, other 'N' ones with single underliers, where the Basket is at same level as the other legs (therefore no aggregation shall exist via Basket at PerformancePayout level.">
        if portfolioReturnTerms -> priceReturnTerms exists
        then underlier -> Observable -> Basket exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition NoSharePriceDividendAdjustmentIndex: <"If the underlier is an index, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> Observable -> Index exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition NoSharePriceDividendAdjustmentForeignExchange: <"If the underlier is an foreign exchange, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> Observable -> Index -> ForeignExchangeRateIndex exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition CorrelationUnderlierOnlyBasket: <"Correlation Return Terms can only have a basket as underlier, since it needs to compute the correlation between two or more products.">
        if returnTerms -> correlationReturnTerms exists
        then underlier -> Observable -> Basket exists

    condition EquitySpecificAttributes: <"Equity specific attributes cannot be present in non-equity products.">
        if Qualify_UnderlierObservable_Equity(underlier -> Observable) = False
        then returnTerms -> varianceReturnTerms -> dividendApplicability is absent
                and returnTerms -> varianceReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> dividendApplicability is absent
                and returnTerms -> volatilityReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> correlationReturnTerms -> dividendApplicability is absent
                and returnTerms -> correlationReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> correlationReturnTerms -> sharePriceDividendAdjustment is absent

type PortfolioReturnTerms extends ReturnTerms: <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level.">
    [metadata key]

    payerReceiver PayerReceiver (1..1) <"Canonical representation of the payer and receiver parties applicable to each individual return leg.">
    underlier Observable (1..1) <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    quantity NonNegativeQuantitySchedule (0..1) <"Specifies a quantity schedule for the underlier, which applies to each individual return leg.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    initialValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Final Price | Specifies the final valuation price of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

choice Payout: <"Represents the set of future cashflow methodologies in the form of specific payout data type(s) which result from the financial product.  Examples: a trade in a cash asset will use only a settlement payout; for derivatives, two interest rate payouts can be combined to specify an interest rate swap; one interest rate payout can be combined with a credit default payout to specify a credit default swap.">
    [metadata key]

    AssetPayout <"Defines the assets and movements in a security financing transaction.">
    CommodityPayout <"Defines the payout for the floating leg of a Commodity Swap.">
    CreditDefaultPayout <"The credit default payout, which provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms.">
    FixedPricePayout <"Defines a payout in which one or more payouts are defined as a fixed price.">
    InterestRatePayout <"All of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg).">
    OptionPayout <"The option payout.">
    PerformancePayout <"The performance payout, which encompasses the equity price returns, dividend returns, volatility return, variance return and correlation provisions.">
    SettlementPayout <"Represents a forward settling payout. The 'Underlier' attribute captures the underlying payout, which is settled according to the 'SettlementTerms' attribute. Both FX Spot and FX Forward should use this component.">

choice Underlier: <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, a product, or the cash settlement of an index rate.  Conditions are usually applied when used in a data type, such as a payout, to ensure this aligns with the use case.">
    Observable <"Specifies the object to be observed for a price, it could be an asset or a reference.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    Product <"Enables either a TransferableProduct or a NonTransferableProduct to be used in an underlier.">

choice Product: <"Enables either a TransferableProduct or a NonTransferableProduct to be used in an underlier.">
    TransferableProduct <"A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific EconomicTerms.">
    NonTransferableProduct <"The non-transferable product data type represents a product that can be traded (as part of a TradableProduct) but cannot be transferred to others.">

type NonTransferableProduct: <"A data type to specify the financial product's economic terms, alongside the product identification and product taxonomy. The non-transferable product data type represents a product that can be traded (as part of a TradableProduct) but cannot be transferred to others.  It is meant to be used across the pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
    [metadata key]
    identifier ProductIdentifier (0..*) <"Comprises a identifier and a source to uniquely identify the nonTransferableProduct. ">
    taxonomy ProductTaxonomy (0..*) <"Specifies the product taxonomy, which is composed of a taxonomy value and a taxonomy source.">
    economicTerms EconomicTerms (1..1) <"The price forming features, including payouts and provisions.">

    condition PrimaryAssetClass: <"Specifies that when nonStandardisedTerms are True that a primary asset class must be specified.">
        if economicTerms -> nonStandardisedTerms = True
        then taxonomy -> primaryAssetClass exists

type TradeLot: <"Specifies the price and quantity of a trade lot, where the same product could be traded multiple times with the same counterparty but in different lots (at a different date, in a different quantity and at a different price). One trade lot combined with a product definition specifies the entire economics of a trade. The lifecycle mechanics of each such trade lot (e.g. cashflow payments) is independent of the other lots.">
    lotIdentifier Identifier (0..*) <"Specifies one or more identifiers for the lot, if any.">
    priceQuantity PriceQuantity (1..*) <"Specifies the settlement characteristics of a trade lot: price, quantity, observable (optionally) and the settlement terms. This attribute has a multiple cardinality to allow to specify the price, quantity and observable of different legs in a single, composite product (e.g. a Swap).">

type TradableProduct: <"Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this product plus an (optional) mechanism for any potential future quantity adjustment.">

    product NonTransferableProduct (1..1) <"The underlying product to be included in a contract or execution.">
    tradeLot TradeLot (1..*) <"Specifies the price, quantity and effective date of each trade lot, when the same product may be traded multiple times in different lots with the same counterparty. In a trade increase, a new trade lot is added to the list, with the corresponding effective date. In a trade decrease, the existing trade lot(s) are decreased of the corresponding quantity (and an unwind fee may have to be settled). The multiple cardinality and the ability to increase existing trades is used for Equity Swaps in particular.">
    counterparty Counterparty (2..2) <"Specifies the parties which are the two counterparties to the transaction.  The product is agnostic to the actual parties to the transaction, with the party references abstracted away from the product definition and replaced by the counterparty enum (e.g. CounterpartyEnum values Party1 or Party2). The counterparty enum can then be positioned in the product (e.g. to specify which counterparty is the payer, receiver etc) and this counterparties attribute, which is positioned outside of the product definition, allows the counterparty enum to be associated with an actual party reference.">
        [docReference ICMA GMRA namingConvention "Party"
            provision "Parties entering into GMRA, as specified on page 1 of the GMRA and under 1. (a)."]
    ancillaryParty AncillaryParty (0..*) <"Specifies the parties with ancillary roles in the transaction. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and this AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">
    adjustment NotionalAdjustmentEnum (0..1) <"Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfolio rebalancing etc. It is typically used in the context of Equity Swaps.">

    condition PriceQuantityTriangulation: <"Check PriceQuantity triangulation for each TradeLot.">
        PriceQuantityTriangulation(tradeLot) = True

    condition NotionalAdjustment: <"As the adjustment attribute applies to return swaps, the equity payout needs to be present alongside it.">
        if adjustment exists
        then product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
                or product -> economicTerms -> payout -> PerformancePayout exists

    condition PerformancePayout_ExtraordinaryDividendsParty:
        if product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                    then product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists

    condition OptionPayout_PredeterminedClearingOrganizationParty:
        if product -> economicTerms -> payout -> OptionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition ForwardPayout_PredeterminedClearingOrganizationParty:
        if product -> economicTerms -> payout -> SettlementPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition PredeterminedClearingOrganizationParty:
        if ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty
        then product -> economicTerms -> payout -> SettlementPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
                or product -> economicTerms -> payout -> OptionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists

    condition ExerciseNoticeReceiverPartyManual:
        if product -> economicTerms -> payout -> OptionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                    then product -> economicTerms -> payout -> OptionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyOptionalEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyCancelableProvision:
        if product -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                    then product -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyExtendibleProvision:
        if product -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                    then product -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition CalculationAgentIndependent:
        if product -> economicTerms -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                    then product -> economicTerms -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentOptionalEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentMandatoryEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists

type ConstituentWeight: <"A class describing the weight of each of the underlier constituent within the basket, either in absolute or relative terms.">

    openUnits number (0..1) <"The number of units (index or securities) that constitute the underlier of the swap. In the case of a basket swap, this element is used to reference both the number of basket units, and the number of each asset components of the basket when these are expressed in absolute terms.">
    basketPercentage number (0..1) <"The relative weight of each respective basket constituent, expressed in percentage. A basket percentage of 5% would be represented as 0.05.">

    condition BasketPercentage: <"FpML specifies basketPercentage as a RestrictedPercentage type, meaning that the value needs to be comprised between 0 and 1.">
        if basketPercentage exists
        then basketPercentage >= 0.0 and basketPercentage <= 1.0

type SettlementPayout extends PayoutBase: <"Represents a forward settling payout. The underlier attribute captures the underlying payout, which is settled according to the settlementTerms attribute (which is part of PayoutBase). Both FX Spot and FX Forward should use this component.">
    underlier Underlier (1..1) <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, or the cash settlement of an index rate.">
    deliveryTerm string (0..1) <"Also called contract month or delivery month. However, it's not always a month. It is usually expressed using a code, e.g. Z23 would be the Dec 2023 contract, (Z = December). For crude oil, the corresponding contract might be called CLZ23.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Underlier: <"The underlier for a settlement payout cannot be a NonTransferableProduct.">
        underlier -> Product -> NonTransferableProduct is absent

    condition Basket: <"If the underlier is a basket, it must contain only transferable assets.">
        if underlier -> Observable -> Basket exists
        then (underlier -> Observable -> Basket -> basketConstituent
                extract Asset exists
                ) all = True

    condition Index: <"If the underlier is an Index, then it can only be cash settled.">
        if underlier -> Observable -> Index exists
        then settlementTerms -> cashSettlementTerms exists

    condition SettlementTerms: <"Settlement Terms should be defined except for cash.">
        if underlier -> Observable -> Asset -> Cash exists
        then settlementTerms exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

type CalculationSchedule: <"A class that allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    schedulePeriod SchedulePeriod (1..*) <"Defines a period of a calculation schedule structure.">

type SchedulePeriod: <"A class that defines the period of a schedule. The period contains a set of start and end dates, quantities, fixing, and pricing data.">
    calculationPeriod DateRange (1..1) <"Period for which the payment is generated.">
    paymentDate date (1..1) <"Adjusted payment date.">
    fixingPeriod DateRange (1..1) <"Period over which the underlying price is observed.">
    deliveryPeriod CalculationScheduleDeliveryPeriods (0..1) <"Period and time profile over which the delivery takes place.">

type FixedPricePayout extends PayoutBase: <"Represents a fixed price payout. There is no underlier associated with this payout type and is based on fixed pricing per a given unit (e.g. in commodities price per barrel)">
    paymentDates PaymentDates (1..1) <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
    fixedPrice FixedPrice (1..1) <"Specifies the fixed price on which fixed forward payments are based.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

type CancelableProvision extends BuyerSeller: <"A data defining:  the right of a party to cancel a swap transaction on the specified exercise dates. The provision is for 'walk-away' cancellation (i.e. the fair value of the swap is not paid). A fee payable on exercise can be specified. As a difference from the FpML construct, the canonical model extends the BuyerSeller class.">
    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    cancelableProvisionAdjustedDates CancelableProvisionAdjustedDates (0..1) <"The adjusted dates associated with a cancelable provision. These dates have been adjusted for any applicable business day convention.">
    finalCalculationPeriodDateAdjustment FinalCalculationPeriodDateAdjustment (0..*) <"Business date convention adjustment to final payment period per leg (swapStream) upon exercise event. The adjustments can be made in-line with leg level BDC's or they can be specified separately.">
    initialFee Transfer (0..1) <"An initial fee for the cancelable option.">
    callingParty CallingPartyEnum (0..1) <"The party with right to exercise a cancellation. Allows for buyer, seller or either.">
    earliestDate AdjustableOrRelativeDate (0..1) <"The first day when cancelation is permitted to take effect. A party may give notice prior to this date and taken together with the effective period would be necessary to cancel on this date.">
    expirationDate AdjustableOrRelativeDate (0..1) <"The last day within the term of the contract that cancelation is allowed.">
    effectiveDate AdjustableOrRelativeDates (0..1) <"The effective date if cancelation is invoked otherwise the cancellation period defines the cancellation date.">
    effectivePeriod Period (0..1) <"Effective period for cancelation when notice is given. This is the period after notice is given that cancellation becomes effecticve.">
    earliestCancellationTime BusinessCenterTime (0..1) <"The earliest time in a business day that notice of cancelation can be given.">
    latestCancelationTime BusinessCenterTime (0..1) <"The latest time at which notice of cancelation can be given.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the cancelable provision, including details such as exercise style, exercise fees, and any other relevant conditions or terms governing the cancellation of the swap transaction.">

    condition EffectiveDate: <"Must select one of predefined cancellation types of effectiveDate or effectivePeriod.">
        optional choice effectiveDate, effectivePeriod

    condition CancelableProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision

type CancelableProvisionAdjustedDates: <"A data to:  define the adjusted dates for a cancelable provision on a swap transaction.">

    cancellationEvent CancellationEvent (1..*) <"The adjusted dates for an individual cancellation date.">

type CancellationEvent: <"The adjusted dates for a specific cancellation date, including the adjusted exercise date and adjusted termination date.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">

type EarlyTerminationEvent: <"A data to:  define the adjusted dates associated with an early termination provision.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">
    adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_39: <"FpML validation rule ird-39 - AdjustedExerciseDate must be before or equal to adjustedEarlyTerminationDate.">
        adjustedExerciseDate <= adjustedEarlyTerminationDate

    condition FpML_ird_40: <"FpML validation rule ird-40 - AdjustedExerciseDate must be before or equal to adjustedCashSettlementValuationDate.">
        adjustedExerciseDate <= adjustedCashSettlementValuationDate

    condition FpML_ird_41: <"FpML validation rule ird-41 - AdjustedCashSettlementValuationDate must be before or equal to adjustedCashSettlementPaymentDate.">
        adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type EarlyTerminationProvision: <"A data defining:  an early termination provision for a swap. This early termination is at fair value, i.e. on termination the fair value of the product must be settled between the parties.">
    [metadata key]

    mandatoryEarlyTermination MandatoryEarlyTermination (0..1) <"A mandatory early termination provision to terminate the swap at fair value.">
    mandatoryEarlyTerminationDateTenor Period (0..1) <"Period after trade date of the mandatory early termination date.">
    optionalEarlyTermination OptionalEarlyTermination (0..1) <"An option for either or both parties to terminate the swap at fair value.">
    optionalEarlyTerminationParameters ExercisePeriod (0..1) <"Definition of the first early termination date and the frequency of the termination dates subsequent to that. American exercise is defined by having a frequency of one day.">

    condition MandatoryEarlyTermination: <"The FpML MandatoryEarlyTermination.model specifies a required choice node. The choice node associated with the FpML EarlyTerminationProvision is quite complex and using the data rule provides a more flexible approach than adding complexity to the condition grammar.">
        (mandatoryEarlyTermination exists or optionalEarlyTermination exists)
            or (mandatoryEarlyTermination exists and optionalEarlyTermination exists)

type ExercisePeriod: <"This defines the time interval to the start of the exercise period, i.e. the earliest exercise date, and the frequency of subsequent exercise dates (if any).">
    [metadata key]

    earliestExerciseDateTenor Period (1..1) <"The time interval to the first (and possibly only) exercise date in the exercise period.">
    exerciseFrequency Period (0..1) <"The frequency of subsequent exercise dates in the exercise period following the earliest exercise date. An interval of 1 day should be used to indicate an American style exercise period.">

type ExtendibleProvision extends BuyerSeller: <"A data defining:  an option to extend an existing swap transaction on the specified exercise dates for a term ending on the specified new termination date. As a difference from FpML, it extends the BuyerSeller class, which represents the BuyerSeller.model.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    extendibleProvisionAdjustedDates ExtendibleProvisionAdjustedDates (0..1) <"The adjusted dates associated with an extendible provision. These dates have been adjusted for any applicable business day convention.">
    callingParty CallingPartyEnum (0..1)
    singlePartyOption PartyRole (0..1) <"If the ability to extend the contract is not available to both parties then this component specifies the buyer and seller of the option.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before a contract is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionTerm RelativeDateOffset (0..1) <"The length of each extension period relative to the effective date of the preceding contract.">
    extensionPeriod AdjustableRelativeOrPeriodicDates (0..1) <"The period within which notice can be given that the contract will be extended.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the extendible provision, including details such as exercise style, exercise fees, and any other relevant conditions or terms governing the extension of the swap transaction.">

    condition ExtendibleProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision

type ExtendibleProvisionAdjustedDates: <"A data defining:  the adjusted dates associated with a provision to extend a swap.">

    extensionEvent ExtensionEvent (1..*) <"The adjusted dates associated with a single extendible exercise date.">

type ExtensionEvent: <"A data to:  define the adjusted dates associated with an individual extension event.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedExtendedTerminationDate date (1..1) <"The termination date if an extendible provision is exercised. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_42: <"FpML validation rule ird-42 - adjustedExerciseDate must be before adjustedExtendedTerminationDate.">
        adjustedExerciseDate < adjustedExtendedTerminationDate

type MandatoryEarlyTermination: <"A data to:  define an early termination provision for which exercise is mandatory.">
    [metadata key]

    mandatoryEarlyTerminationDate AdjustableDate (1..1) <"The early termination date associated with a mandatory early termination of a swap.">
    calculationAgent CalculationAgent (1..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (1..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    mandatoryEarlyTerminationAdjustedDates MandatoryEarlyTerminationAdjustedDates (0..1) <"The adjusted dates associated with a mandatory early termination provision. These dates have been adjusted for any applicable business day convention.">

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination

type MandatoryEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with a mandatory early termination provision.">

    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">

    condition FpML_ird_44: <"FpML validation rule ird-44 - AdjustedEarlyTerminationDate must be before or equal to adjustedCashSettlementValuationDate must be before or the same as adjustedCashSettlementPaymentDate">
        adjustedEarlyTerminationDate <= adjustedCashSettlementValuationDate and adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type OptionalEarlyTermination: <"A data defining:  an early termination provision where either or both parties have the right to exercise.">

    singlePartyOption BuyerSeller (0..1) <"If optional early termination is not available to both parties then this component specifies the buyer and seller of the option. In FpML, this attribute is of type SinglePsrtyOption, which actually consists of the BuyerSeller.model.">
    mutualEarlyTermination boolean (0..1) <"Used for specifying whether the Mutual Early Termination Right that is detailed in the Master Confirmation will apply.">
    exerciseNotice ExerciseNotice (0..*) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    calculationAgent CalculationAgent (0..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (0..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    optionalEarlyTerminationAdjustedDates OptionalEarlyTerminationAdjustedDates (0..1) <"An early termination provision to terminate the trade at fair value where one or both parties have the right to decide on termination.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the optional early termination, including details such as exercise style, exercise fees, and any other relevant conditions or terms.">

    condition OptionalEarlyTerminationExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination

type OptionalEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with an optional early termination provision.">

    earlyTerminationEvent EarlyTerminationEvent (1..*) <"The adjusted dates associated with an individual early termination date.">

type Asian: <"As per ISDA 2002 Definitions.">

    averagingInOut AveragingInOutEnum (1..1)
    strikeFactor number (0..1) <"The factor of strike.">
    averagingPeriodIn AveragingPeriod (0..1) <"The averaging in period.">
    averagingPeriodOut AveragingPeriod (0..1) <"The averaging out period.">

type AveragingCalculation: <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    averagingMethod AveragingCalculationMethod (1..1) <"Specifies enumerations for the type of averaging calculation.">
    precision Rounding (1..1) <"Rounding applied to the average calculation. ">

type AveragingStrikeFeature: <"Defines the terms required to calculate the average observations associated with an averaging strike.">
    averagingCalculation AveragingCalculation (1..1) <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    observationTerms ObservationTerms (1..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. ">

type Barrier: <"As per ISDA 2002 Definitions.">
    barrierCap TriggerEvent (0..*) <"A trigger level approached from beneath.">
    barrierFloor TriggerEvent (0..*) <"A trigger level approached from above.">

type CalendarSpread: <"A type for defining a calendar spread feature.">

    expirationDateTwo AdjustableOrRelativeDate (1..1)

type Composite: <"Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.">

    determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which an amount or a date is determined.">
    relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type FxFeature: <"A type for defining FX Features.">

    referenceCurrency string (1..1) <"Specifies the reference currency of the trade.">
        [metadata id]
        [metadata scheme]
    composite Composite (0..1) <"If 'Composite' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price  Strike Price) / (Strike Price  Settlement Price) x Multiplier provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    quanto Quanto (0..1) <"If 'Quanto' is specified as the Settlement Type in the relevant Transaction Supplement, an amount, as determined by the Calculation Agent in accordance with the Section 8.2 of the Equity Definitions.">
    crossCurrency Composite (0..1) <"If 'Cross-Currency' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price  Strike Price) / (Strike Price  Settlement Price) x Multiplier x one unit of the Reference Currency converted into an amount in the Settlement Currency using the rate of exchange of the Settlement Currency as quoted on the Reference Price Source on the Valuation Date, provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    condition FxFeatureChoice: <" Choice rule to represent an FpML choice construct.">
        required choice composite, quanto, crossCurrency

type Knock: <"Knock In means option to exercise comes into existence. Knock Out means option to exercise goes out of existence.">
    knockIn TriggerEvent (0..*) <"The knock in.">
    knockOut TriggerEvent (0..*) <"The knock out.">

type OptionFeature: <"Defines additional optional features that can be included in an option contract.">
    fxFeature FxFeature (0..*) <"Describes a quanto or composite FX feature.">
    strategyFeature StrategyFeature (0..1) <"Defines a simple strategy feature.">
    averagingFeature AveragingCalculation (0..1) <"Defines an option feature in which an average market observation price is determined on valuation and compared to the strike to determine a settlement amount.">
    barrier Barrier (0..1) <"Specifies a barrier feature.">
    knock Knock (0..1) <"Specifies a knock in or knock out feature.">
    passThrough PassThrough (0..1) <"Specifies the rules for pass-through payments from the underlier, such as dividends.">

type TerminationProvision: <"A class for defining option provisions.">
    cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">
    earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">
    extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">

    condition TerminationProvisionChoice:
        required choice cancelableProvision, extendibleProvision, evergreenProvision, earlyTerminationProvision

type OptionStrike: <"Defines the strike price of an option.">

    strikePrice Price (0..1) <"Defines the strike of an option in the form of a price that could be a cash price, interestRate, or other types.">
    strikeReference FixedRateSpecification (0..1) <"Defines the strike of an option in reference to the spread of the underlying swap (typical practice in the case of an option on a credit single name swaps).">
        [metadata reference]
    referenceSwapCurve ReferenceSwapCurve (0..1) <"Defines the strike of an option when expressed by reference to a swap curve (Typically the case for a convertible bond option).">
    averagingStrikeFeature AveragingStrikeFeature (0..1) <"Defines an  option strike that is calculated from an average of observed market prices.">

    condition:
        one-of

type PassThrough: <"Type which contains pass through payments.">

    passThroughItem PassThroughItem (1..*) <"One to many pass through payment items.">

type PassThroughItem: <"Class to represent a single pass through payment.">

    payerReceiver PayerReceiver (1..1) <"This attribute doesn't exists in the FpML construct, which makes use of the PayerReceiver.model group.">
    passThroughPercentage number (1..1) <"Percentage of payments from the underlier which are passed through.">

type Quanto: <"Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a currency that is different from the currency denomination of the underlier.">

    fxRate FxRate (0..*) <"Specifies a currency conversion rate.">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type StrategyFeature: <"A class for defining option strategy features.">

    strikeSpread StrikeSpread (0..1) <"Definition of the upper strike in a strike spread.">
    calendarSpread CalendarSpread (0..1) <"Definition of the later expiration date in a calendar spread.">

type StrikeSpread: <"A class for defining a strike spread feature.">

    upperStrike OptionStrike (1..1) <"Upper strike in a strike spread.">
    upperStrikeNumberOfOptions number (1..1) <"Number of options at the upper strike price in a strike spread.">

type ExerciseTerms: <"A class defining the exercise period for an option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
    [metadata key]

    style OptionExerciseStyleEnum (0..1) <"Whether the option has a single exercise (european), multiple exercise dates (bermuda), or a continuous range of exercise (american).">
    commencementDate AdjustableOrRelativeDate (0..1) <"The first day of the exercise period for an American style option.">
    exerciseDates AdjustableOrRelativeDates (0..1) <"The dates that define the Bermuda option exercise dates and the expiration date. The last specified date is assumed to be the expiration date. The dates can either be specified as a series of explicit dates and associated adjustments or as a series of dates defined relative to another schedule of dates, for example, the calculation period start dates. Where a relative series of dates are defined the first and last possible exercise dates can be separately specified.">
    expirationDate AdjustableOrRelativeDate (0..*) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
    relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.'">
    earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) to, and including, the expiration date.">
    latestExerciseTime BusinessCenterTime (0..1) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
    expirationTime BusinessCenterTime (0..1) <"The latest time for exercise on expirationDate. It is made mandatory given that for all option styles, this field is required.">
    expirationTimeType ExpirationTimeTypeEnum (1..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
    multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
    exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">
    exerciseProcedure ExerciseProcedure (0..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">
    exerciseFee ExerciseFee (0..1) <"A fee to be paid on exercise. This could be represented as an amount or a rate and notional reference on which to apply the rate.">
    partialExercise PartialExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.3. Partial Exercise, the buyer of the option has the right to exercise all or less than all the notional amount of the underlying swap on the expiration date, but may not exercise less than the minimum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">

    condition ExerciseDateExpirationDateChoice: <"Required choice rule between exercise dates and expiration date. The exerciseDates field can be used to extract the expiration date of a bermuda option, while the expirationDate field refers to the expiration date of an american or european option.">
        required choice exerciseDates, expirationDate

    condition CommencementAndExpirationDate: <"Condition to check that expiration date is present when commencement date is present.">
        if commencementDate exists then expirationDate exists

    condition AmericanExercise: <"Condition to check that only fields expected for an american option are present.">
        if style = OptionExerciseStyleEnum -> American
        then commencementDate exists
                and exerciseFee is absent
                and partialExercise is absent
                and expirationDate count = 1

    condition EuropeanExercise: <"Condition to check that only fields expected for a european option are present.">
        if style = OptionExerciseStyleEnum -> European
        then expirationDate exists
                and exerciseFeeSchedule is absent
                and multipleExercise is absent
                and latestExerciseTime is absent
                and commencementDate is absent

    condition BermudaExercise: <"Condition to check that only fields expected for a bermuda option are present.">
        if style = OptionExerciseStyleEnum -> Bermuda
        then exerciseDates exists
                and earliestExerciseTime exists
                and partialExercise is absent
                and exerciseFee is absent

    condition ExpirationTimeChoice: <"Condition to validate the correlation between expirationTime and expirationTimeType">
        (if expirationTime exists
        then expirationTimeType = ExpirationTimeTypeEnum -> SpecificTime
                and if expirationTimeType = ExpirationTimeTypeEnum -> SpecificTime
                    then expirationTime exists)

type AutomaticExercise: <"A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more than the threshold amount on the exercise date.">

    thresholdRate number (0..1) <"A threshold rate. The threshold of 0.10% would be represented as 0.001">
    isApplicable boolean (0..1) <"Boolean that indicates if it has an automaticExercise">

type ExerciseFee extends PayerReceiver: <"A class defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmount number (0..1) <"The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.">
    feeRate number (0..1) <"A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmount, feeRate

type ExerciseFeeSchedule extends PayerReceiver: <"A class to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmountSchedule AmountSchedule (0..1) <"The exercise fee amount schedule. The fees are expressed as currency amounts. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feeRateSchedule Schedule (0..1) <"The exercise free rate schedule. The fees are expressed as percentage rates of the notional being exercised. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeScheduleChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmountSchedule, feeRateSchedule

type ExerciseNotice: <"Defines to whom and where notice of execution should be given. The exerciseNoticeGiver refers to one or both of the principal parties of the trade. If present the exerciseNoticeReceiver refers to a party, other than the principal party, to whom notice should be given.">

    exerciseNoticeGiver ExerciseNoticeGiverEnum (1..1) <"Specifies the principal party of the trade that has the right to exercise.">
    exerciseNoticeReceiver AncillaryRoleEnum (0..1) <"Specifies the party to which notice of exercise should be given, e.g. by the buyer of the option. Although in many cases it is the buyer of the option who sends the exercise notice to the seller of the option, this component is reused, e.g. in case of OptionEarlyTermination, either or both parties have the right to exercise.">
    businessCenter BusinessCenterEnum (1..1) <"Specifies the location where the exercise must be reported, e.g. where the exercise notice receiver is based.">
        [metadata scheme]

type ExerciseProcedure: <"A class describing how notice of exercise should be given. This can be either manual or automatic.">

    manualExercise ManualExercise (0..1) <"Specifies that the notice of exercise must be given by the buyer to the seller or seller's agent.">
    automaticExercise AutomaticExercise (0..1) <"If automatic is specified, then the notional amount of the underlying swap not previously exercised under the swaption will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    limitedRightToConfirm boolean (0..1) <"Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Confirm Exercise. If present, (i) the Seller may request the Buyer to confirm its intent if not done on or before the expiration time on the Expiration date (ii) specific rules will apply in relation to the settlement mode.">
    splitTicket boolean (0..1) <"Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the party required to deliver the bonds will divide those to be delivered as notifying party desires to facilitate delivery obligations.">

    condition ExerciseProcedureChoice: <"Choice rule to represent an FpML choice construct.">
        required choice manualExercise, automaticExercise

type ManualExercise: <"A class defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    fallbackExercise boolean (0..1) <"If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the swaption, will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than one tenth of a percentage point (0.10% or 0.001). The term in-the-money is assumed to have the meaning defined in the 2000 ISDA Definitions, Section 17.4. In-the-money.">

    condition ManualExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual

type MultipleExercise extends PartialExercise: <"A class defining multiple exercises. As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more than the maximum notional amount, and if an integral multiple amount is specified, the notional exercised must be equal to or, be an integral multiple of, the integral multiple amount. In FpML, MultipleExercise is built upon the PartialExercise.model.">

    maximumNotionalAmount number (0..1) <"The maximum notional amount that can be exercised on a given exercise date.">
    maximumNumberOfOptions int (0..1) <"The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it means that the maximum number of options corresponds to the remaining unexercised options.">

    condition MaximumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice maximumNotionalAmount, maximumNumberOfOptions

    condition MaximumNumberOfOptions: <"FpML MultipleExercise construct specifies the maximumNumberOfOptions as a positive integer.">
        if maximumNumberOfOptions exists
        then maximumNotionalAmount >= 0

    condition MinimumNumberOfOptions: <"FpML MultipleExercise construct specifies the minimumNumberOfOptions as a positive integer.">
        if minimumNumberOfOptions exists
        then minimumNumberOfOptions >= 0

type PartialExercise: <"A class defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all or less than all the notional amount of the underlying swap but may not be less than the minimum notional amount (if specified) and must be an integral multiple of the integral multiple amount if specified.">

    notionaReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.">
        [metadata reference]
    integralMultipleAmount number (0..1) <"A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.">
    minimumNotionalAmount number (0..1) <"The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.">
    minimumNumberOfOptions int (0..1) <"The minimum number of options that can be exercised on a given exercise date.">

    condition MinimumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice minimumNotionalAmount, minimumNumberOfOptions

type Strike: <"A class describing a single cap or floor rate.">
    [metadata key]

    strikeRate number (1..1) <"The rate for a cap or floor.">
        [synonym FIX_5_0_SP2 value "StrikePrice" tag 202]
    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type StrikeSchedule extends RateSchedule: <"A class describing a schedule of cap or floor rates.">

    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type AssetPayout extends PayoutBase: <"Security finance payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction. Plus additional description for ICMA.">
    assetLeg AssetLeg (1..*) <"Defines each asset movement as a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    underlier Asset (1..1) <"Specifies the Purchased Asset, usually a Security.">
    // [metadata address "pointsTo"=PriceQuantity->observable->Asset->Instrument->Security]
    minimumFee Money (0..1) <"A contractual minimum amount which the borrower will pay, regardless of the duration of the loan. A mechanism for making sure that a trade generates enough income.">
    dividendTerms DividendTerms (0..1) <"Specifies the terms under which dividends received by the borrower are passed through to the lender.">
    tradeType AssetPayoutTradeTypeEnum (0..1) <"The trade type, eg repurchase transaction or buy/sell-back.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition UnderlierNotCash: <"The purchased asset in an assetPayout should not be cash.">
        underlier -> Cash is absent

type DividendTerms: <"Information related to dividends and payments.">
    manufacturedIncomeRequirement DividendPayoutRatio (1..1) <"Specifies the proportion of the value of the dividend on the borrowed shares that the borrower is legally obligated to return to the lender.">
    dividendEntitlement DividendEntitlementEnum (0..1) <"Defines the date on which the receiver of the equity return is entitled to the dividend.">
    minimumBillingAmount Money (0..1) <"daily fee increments accrue until a threshold is crossed, at which point payment becomes due)">

type AssetLeg: <"Defines each asset movement of an asset payout.">
    settlementDate AdjustableOrRelativeDate (1..1) <"Specifies the settlement date of securities.  In a repo transaction the purchase date would always be the effective date as specified under Economic Terms, the repurchase date would always be the termination date as specified under Economic Terms.">
    deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

type EvergreenProvision: <"Specifies a transaction which automatically extends for a specified timeframe until the exercise of an embedded option.">
    singlePartyOption PartyRole (0..1) <"If evergreen termination is not available to both parties then this component specifies the buyer and seller of the option.">
    noticePeriod RelativeDateOffset (1..1) <"The length of each evergreen extension period relative to the effective date of the preceding contract.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before an evergreen is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionFrequency AdjustableRelativeOrPeriodicDates (1..1) <"The frequency with which the evergreen contract will be extended if notice is not given.">
    finalPeriodFeeAdjustment Price (0..1) <"An optional adjustment to the rate for the last period of the evergreen i.e. the period from when notice is given to stop rolling the contract through to the termination date.">

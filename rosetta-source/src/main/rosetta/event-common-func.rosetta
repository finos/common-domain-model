namespace cdm.event.common: <"Business event concepts: primitives, contract state and associated state transition function specifications.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.template.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*

import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.master.*

import cdm.event.workflow.*
import cdm.event.position.*

func QuantityIncreased:
	inputs:
		before TradeState (1..1)
		after TradeState (0..*)
    output:
        result boolean (1..1)

    set result: <"Check each after (list item) is greater than before (func input).">
		after
            extract [ CompareTradeLot(
                    item -> trade -> tradableProduct -> tradeLot only-element,
                    CompareOp -> GreaterThan,
                    before -> trade -> tradableProduct -> tradeLot only-element ) = True ]
		    all = True

func QuantityDecreased:
	inputs:
		before TradeState (1..1)
		after TradeState (0..*)
	output:
	    result boolean (1..1)

    set result:
		after
            extract [
                // check each after (item) is less than before (input)
                CompareTradeLot(
                    item -> trade -> tradableProduct -> tradeLot only-element,
                    CompareOp -> LessThan,
                    before -> trade -> tradableProduct -> tradeLot only-element ) = True
                and
                // check each after (item) is greater than zero
                CompareTradeLotToAmount(
                    item -> trade -> tradableProduct -> tradeLot only-element,
                    CompareOp -> GreaterThan,
                    0.0 ) = True
            ]
		    all = True

func QuantityDecreasedToZero:
	inputs:
		before TradeState (0..*)
		after TradeState (0..*)
	output:
	    result boolean (1..1)

    set result:
	    CompareTradeLotToAmount( before -> trade -> tradableProduct -> tradeLot only-element, CompareOp -> GreaterThanOrEquals, 0.0 ) = True
	    and CompareTradeStatesToAmount( after, CompareOp -> Equals, 0.0 ) = True

func CompareTradeStatesToAmount: <"For each TradeState, compare the Quantity amounts in each TradeState to the given amount (regardless of unit of amount), based on the CompareOp enum.">
	inputs:
		tradeStates TradeState (0..*) <"List of TradeState to be compared.">
		op CompareOp (1..1) <"Comparison operation to use.">
		amount number (1..1) <"Quantity amount to use.">
	output:
		result boolean (1..1)

	set result:
        tradeStates
            extract [ CompareTradeLotToAmount( item -> trade -> tradableProduct -> tradeLot only-element, op, amount ) ]
            all = True


func TransfersForDate:
	inputs: 
		transfers Transfer (0..*)
		date date (1..1)
	output:
		transfersForDate Transfer (0..*)

	add transfersForDate:
	    transfers
	        filter [ item -> settlementDate -> adjustedDate = date ]

func FilterCashTransfers:
	inputs:
	    transfers Transfer (0..*)
	output:
	    cashTransfers Transfer (0..*)

    add cashTransfers:
        transfers
            filter [ item -> quantity -> unit -> currency exists ]

func FilterSecurityTransfers:
	inputs:
	    transfers Transfer (0..*)
	output:
	    securityTransfers Transfer (0..*)

    add securityTransfers:
        transfers
            filter [ item -> observable -> productIdentifier exists ]

func ResolveInterestRateObservationIdentifiers: <"Defines which attributes on the InterestRatePayout should be used to locate and resolve the underlier's price, for example for the reset process.">
	inputs:
		payout InterestRatePayout (1..1)
		date date (1..1)
	output:
		identifiers ObservationIdentifier (1..1)

	set identifiers -> observable -> rateOption:
		payout -> rateSpecification -> floatingRate -> rateOption
	set identifiers -> observationDate:
		date

// ResolveInterestRateReset is similar to ResolveEquityReset as they both only support the basic use cases for reset. Once support is added for stub periods and thus rate interpolation, the formula to derive the reset value will start to look different between the functions.

func ResolveInterestRateReset: <"Defines how to resolve the reset value for an InterestRatePayout.">
	inputs:
		payouts InterestRatePayout (1..*)
		observation Observation (1..1)
		resetDate date (1..1)
		rateRecordDate date (0..1)
	output:
		reset Reset (1..1)

	set reset -> resetValue: <"Assigns the observed value to the reset value.">
		observation -> observedValue
	set reset -> resetDate:
		resetDate
	set reset -> rateRecordDate:
		rateRecordDate
	add reset -> observations: <"Assigns the observation required to compute the rest value as audit.">
		observation

func InterestCashSettlementAmount: <"Defines the performance calculations relevent for a fixed or floating rate payout.">
	inputs:
		tradeState TradeState (1..1)
		interestRatePayout InterestRatePayout (1..1)
		resets Reset (1..*)
		date date (1..1)
	output:
		interestCashSettlementAmount Transfer (1..1)

	alias performance:
		if interestRatePayout -> rateSpecification -> fixedRate exists
		then FixedAmount(
			interestRatePayout,
            interestRatePayout -> priceQuantity -> quantitySchedule -> value,
			date,
			empty)
		else if interestRatePayout -> rateSpecification -> floatingRate exists
		then FloatingAmount(
			interestRatePayout,
			resets only-element -> resetValue -> value,
			interestRatePayout -> priceQuantity -> quantitySchedule -> value,
			date,
			empty)
	alias payer:
		ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, interestRatePayout -> payerReceiver -> payer ) -> partyReference
	alias receiver:
		ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, interestRatePayout -> payerReceiver -> receiver ) -> partyReference
	set interestCashSettlementAmount -> quantity -> value:
		performance
	set interestCashSettlementAmount -> quantity -> unit -> currency:
		interestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency
	set interestCashSettlementAmount -> payerReceiver -> payerPartyReference:
	    if performance >= 0 then payer else receiver
	set interestCashSettlementAmount -> payerReceiver -> receiverPartyReference:
	    if performance >= 0 then receiver else payer

	set interestCashSettlementAmount -> settlementDate -> adjustedDate:
		date

	set interestCashSettlementAmount -> settlementOrigin -> interestRatePayout:
		interestRatePayout as-key

func ResolveReset: <"Defines the interface for adopters to resolve a reset, given a trade state and a date.">
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)
	output:
		reset Reset (1..1)

func ResolvePerformanceObservationIdentifiers: <"Defines which attributes on the PerformancePayout should be used to locate and resolve the underlier's price, for example for the reset process.">
	inputs:
		payout PerformancePayout (1..1)
		adjustedDate date (1..1)
	output:
		identifiers ObservationIdentifier (1..1)

    alias adjustedFinalValuationDate:
        ResolveAdjustableDate( payout -> valuationDates -> valuationDatesFinal -> valuationDate )
    alias valuationDates: <"Determine which valuation date to get valuation time and type from.">
        if adjustedDate < adjustedFinalValuationDate then
            payout -> valuationDates -> valuationDatesInterim
        else
            payout -> valuationDates -> valuationDatesFinal
	add identifiers -> observable -> productIdentifier: <"Represents the identifer for the equity underlier.">
		payout -> underlier -> security -> productIdentifier
	set identifiers -> observationDate: <"Specifies the date for which to retrieve the market data value(s). Selects the most recent valuation date.">
		AdjustedValuationDates( payout -> valuationDates )
		    filter [ item <= adjustedDate ]
		    last
	set identifiers -> observationTime: <"Specifies the time for which to retrieve the market data value(s).">
		ResolvePerformanceValuationTime(valuationDates -> valuationTime,
		    valuationDates -> valuationTimeType,
		    identifiers -> observable -> productIdentifier only-element,
		    valuationDates -> determinationMethod )
	set identifiers -> determinationMethodology -> determinationMethod: <"Identifies a more specific price should multiple prices for the underlier be available at the given date time, for example bid or ask prices.">
		valuationDates -> determinationMethod

func AdjustedValuationDates:
    inputs: valuationDates ValuationDates (1..1)
    output: adjustedValuationDates date (0..*)
    set adjustedValuationDates: <"Build sorted list of adjusted valuation dates.">
        [ ResolveAdjustableDates( valuationDates -> valuationDatesInterim -> valuationDates ),
            ResolveAdjustableDate( valuationDates -> valuationDatesFinal -> valuationDate ) ]
        sort

func ResolvePerformanceValuationTime: <"Defines how to resolve the observation time from those specified in the Performance Valuation type.">
	inputs:
		valuationTime BusinessCenterTime (0..1) <"Represents the Equity Valuation terms from the Equity product definition.">
		valuationTimeType TimeTypeEnum (0..1) <"The time of day at which the calculation agent values the underlying, for example the official closing time of the exchange.">
		productIdentifier ProductIdentifier (1..1) <"Specifies the product identifier, along with the source, which should be used to determine the correct valuation time i.e. close times are different across exchanges.">
		determinationMethod DeterminationMethodEnum (1..1) <"Specifies the method according to which an amount or a date is determined.">
	output:
		time TimeZone (1..1)
	set time:
		if valuationTime exists then TimeZoneFromBusinessCenterTime(valuationTime)
	set time:
		if valuationTimeType exists then ResolveTimeZoneFromTimeType(productIdentifier, valuationTimeType, determinationMethod)

func ResolvePerformanceReset: <"Defines how to resolve the reset value for a performance payout.">
	inputs:
		performancePayout PerformancePayout (1..1) <"Represents the PerformancePayout to which the reset will apply.">
		observation Observation (1..1) <"Represents the observation that will be used to compute the reset value.">
		date date (1..1) <"Specifies the date of the reset.">
	output:
		reset Reset (1..1)
	set reset -> resetValue: <"Assigns the observed value to the reset value.">
		observation -> observedValue
	set reset -> resetDate:
		date
	add reset -> observations: <"Assigns the observation required to compute the rest value as audit.">
		observation

func EquityCashSettlementAmount: <"Represents Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) * Equity Notional Amount.">
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)
	output:
		equityCashSettlementAmount Transfer (1..1)

	alias equityPerformancePayout:
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element
	alias equityPerformance:
	    EquityPerformance( tradeState -> trade, tradeState -> resetHistory only-element -> resetValue, date )
	alias payer:
		ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, equityPerformancePayout -> payerReceiver -> payer ) -> partyReference
	alias receiver:
		ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, equityPerformancePayout -> payerReceiver -> receiver ) -> partyReference

	set equityCashSettlementAmount -> quantity -> value: <"Equity Cash Settlement Amount is defined here as Abs( Equity Performance ). Per the ISDA Definitions: Equity Performance = (Rate Of Return)  Equity Notional Amount and Equity Cash Settlement Amount = ABS(Rate Of Return)  Equity Notional Amount; so the calculation for Equity Cash Settlement Amount in the CDM is mathematically equivalent, with the added benefit that Rate of Return does not need to be recomputed, since it was already computed in the Reset Event.">
	 	Abs(equityPerformance)
	set equityCashSettlementAmount -> quantity -> unit-> currency: <"Does not handle the cross currency case. Only works in the case of a single trade lot.">
        ResolveEquityInitialPrice(
            tradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> price
        ) -> unit -> currency
	set equityCashSettlementAmount -> payerReceiver -> payerPartyReference:
	    if equityPerformance >= 0 then payer else receiver
	set equityCashSettlementAmount -> payerReceiver -> receiverPartyReference:
	    if equityPerformance >= 0 then receiver else payer
    set equityCashSettlementAmount -> settlementDate -> adjustedDate:
        ResolveCashSettlementDate(tradeState)
	set equityCashSettlementAmount -> settlementOrigin -> performancePayout:
		equityPerformancePayout as-key

func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return)  Equity Notional Amount.">
	inputs:
		trade Trade (1..1)
		observation Price (1..1)
		date date (1..1)
	output:
		equityPerformance number (1..1)

	alias performancePayout:
		trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element
	alias periodStartPrice: <"Only works in the case of a single trade lot.">
		ResolvePerformancePeriodStartPrice(
				performancePayout,
				trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> price,
				trade -> tradableProduct -> tradeLot -> priceQuantity -> observable only-element,
				date)
	alias periodEndPrice:
		observation
	alias numberOfSecurities:
		performancePayout -> priceQuantity -> quantitySchedule -> value / periodStartPrice -> value
	alias rateOfReturn:
		RateOfReturn(periodStartPrice, periodEndPrice)
	alias notionalAmount:
		EquityNotionalAmount(numberOfSecurities, periodEndPrice)

	condition PriceReturnTermsExists:
	    trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> returnTerms -> priceReturnTerms exists

	set equityPerformance:
		rateOfReturn * notionalAmount

func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
	inputs:
		initialPrice PriceSchedule (1..1)
		finalPrice PriceSchedule (1..1)
	output:
		rateOfReturn number (1..1)

	alias initialPriceValue:
		initialPrice->value
	alias finalPriceValue:
		finalPrice->value
	set rateOfReturn:
	    if finalPriceValue exists and initialPriceValue exists and initialPriceValue > 0 then
		    (finalPriceValue - initialPriceValue) / initialPriceValue

func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
	inputs:
		numberOfSecurities number (1..1)
		price Price (1..1)
	output:
		equityNotionalAmount number (1..1)
	alias priceValue:
		price->value
	set equityNotionalAmount:
		numberOfSecurities * priceValue

func Create_StockSplit: <"Function specification to create the fully-formed business event which represents the impact of a stock split (or a reverse stock split) on an Equity Derivatives contract on a certain date.">
	inputs:
		stockSplitInstruction StockSplitInstruction (1..1)
		before TradeState (1..1)
    output:
		after TradeState (1..1)

	alias preSplitNumberOfShares: <"Only works in the case of a single trade lot.">
		FilterQuantityByFinancialUnit( before -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> quantity, FinancialUnitEnum -> Share ) only-element -> value
	alias postSplitNumberOfShares: <"The adjustment ratio is be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.">
		Create_NonNegativeQuantitySchedule( preSplitNumberOfShares * stockSplitInstruction -> adjustmentRatio, Create_UnitType( empty, FinancialUnitEnum -> Share ))
	alias preSplitPrice:
		before -> trade -> tradableProduct -> tradeLot -> priceQuantity -> price
		    filter [ item -> perUnitOf -> financialUnit = FinancialUnitEnum -> Share ]
		    only-element
	alias postSplitPrice: <"The pre-split price is divided by the adjustment ratio to determine the post-split price.">
		Create_Price( preSplitPrice -> value / stockSplitInstruction -> adjustmentRatio, preSplitPrice -> unit, preSplitPrice -> perUnitOf, preSplitPrice -> priceExpression )
	alias postSplitPriceQuantity:
		Create_PriceQuantity( [postSplitPrice],[postSplitNumberOfShares], empty )
    alias quantityChangeInstruction:
        Create_QuantityChangeInstruction( [postSplitPriceQuantity], QuantityChangeDirectionEnum -> Replace, empty )
    alias primitiveInstruction:
        Create_PrimitiveInstruction( empty, empty, empty, empty, quantityChangeInstruction, empty, empty, empty, empty, empty, empty, empty)
    set after:
        Create_TradeState( primitiveInstruction, before )

func Create_ExecutionInstruction:
    inputs:
        product Product (1..1) <"Defines the financial product to be executed and contract formed.">
        priceQuantity PriceQuantity (1..*) <"Specifies the price, quantity, and optionally the observable and settlement terms for use in a trade or other purposes.">
        counterparty Counterparty (2..2) <"Maps two defined parties to counterparty enums for the transacted product.">
        ancillaryParty AncillaryParty (0..*) <"Maps any ancillary parties, e.g. parties involved in the transaction that are not one of the two principal parties.">
        parties Party (2..*) <"Defines all parties to that execution, including agents and brokers.">
        partyRoles PartyRole (0..*) <"Defines the role(s) that party(ies) may have in relation to the execution.">
        executionDetails ExecutionDetails (0..1) <"Specifies the type of execution, e.g. via voice or electronically.">
        tradeDate date (1..1) <"Denotes the trade/execution date.">
        tradeIdentifier Identifier (1..*) <"Denotes one or more identifiers associated with the transaction.">
    output:
        instruction ExecutionInstruction (1..1)

    set instruction -> product: <"Assign the product input to the tradable product of the execution object.">
		product
	add instruction -> priceQuantity: <"Assign the prices and quantities input to the tradable product of the execution object.">
		priceQuantity
	add instruction -> counterparty: <"Assign the counterparty input to the tradable product of the execution object.">
		counterparty
	add instruction -> ancillaryParty: <"Assign the ancillaryRole input to the tradable product of the execution object.">
		ancillaryParty
	add instruction -> parties: <"Assign the parties input to the execution object.">
		parties
	add instruction -> partyRoles: <"Assign the party roles input to the execution object.">
 		partyRoles
	set instruction -> executionDetails: <"Assign the settlement terms input to the execution object.">
		executionDetails
	set instruction -> tradeDate: <"Assign the tradeDate input to the execution object.">
		tradeDate
	add instruction -> tradeIdentifier: <"Assign the identifier input to the execution object.">
		tradeIdentifier

func Create_Execution: <"Specifies the function to compose an execution based on a minimum required set of inputs: product, quantity, parties, etc.">
	inputs:
	    instruction ExecutionInstruction (1..1) <"Instructions to be used as an input to the function">
	output:
		execution TradeState (1..1) <"Execution primitive event with absent before state and an after state containing the tradable product, parties, associated party roles and the known settlement terms.">

	set execution -> trade -> tradableProduct -> product: <"Assign the product input to the tradable product of the execution object.">
		instruction -> product
	add execution -> trade -> tradableProduct -> tradeLot -> priceQuantity: <"Assign the prices and quantities input to the tradable product of the execution object.">
		instruction -> priceQuantity
	add execution -> trade -> tradableProduct -> counterparty: <"Assign the counterparty input to the tradable product of the execution object.">
		instruction -> counterparty
	add execution -> trade -> tradableProduct -> ancillaryParty: <"Assign the ancillaryRole input to the tradable product of the execution object.">
		instruction -> ancillaryParty
	add execution -> trade -> party: <"Assign the parties input to the execution object.">
		instruction -> parties
	add execution -> trade -> partyRole: <"Assign the party roles input to the execution object.">
 		instruction -> partyRoles
	set execution -> trade -> executionDetails: <"Assign the settlement terms input to the execution object.">
		instruction -> executionDetails
	set execution-> trade -> tradeDate: <"Assign the tradeDate input to the execution object.">
		instruction -> tradeDate
	add execution-> trade -> tradeIdentifier: <"Assign the identifier input to the execution object.">
		instruction -> tradeIdentifier
	set execution -> state -> positionState: <"Assign the position status to executed.">
	    PositionStatusEnum -> Executed
	set execution -> trade -> collateral: <"Assign the anticpated collateral details to the tradable product of the excution object.">
		instruction ->collateral


func Create_ContractFormationInstruction:
    inputs:
        legalAgreement LegalAgreement (0..*)
    output:
        instruction ContractFormationInstruction (1..1)
	condition ExecutedAgreement:<"The full formation of a contract can only be completed with executed legal agreements if any.">
				if legalAgreement exists then legalAgreement-> agreementDate exists

    add instruction -> legalAgreement:
        legalAgreement

func Create_ContractFormation: <"Function specification that represents an executed trade for a contractual product that has been affirmed (or confirmed) by the two parties. The formed contract can reference a legal agreement for instance a master agreement, by using the optional legalAgreement input.">
	inputs:
		instruction ContractFormationInstruction (1..1) <"Instructions to be used as an input to the function">
        execution TradeState (1..1)
	output:
		contractFormation TradeState (1..1) <"Primitive event containing the execution as its before state and the contract as the after state.">

	set contractFormation :
		execution
	add contractFormation -> trade -> contractDetails -> documentation: <"Append any legal agreements from the instructions.">
        instruction -> legalAgreement
	set contractFormation -> state -> positionState: <"Assign the position status to formed.">
        PositionStatusEnum -> Formed

func Create_Exercise: <"Defines the process of putting into effect the rights specified in an options contract, such as to buy or sell a security.  Once exercised the option contract is terminated.">

	inputs:
		exerciseInstruction ExerciseInstruction (1..1) <"Instruction containing the terms of the option exercise.">
		originalTrade TradeState (1..1) <"The original trade to be split, which must be of single cardinality.">
	output:
		exercise TradeState (1..*)

	alias tradableProduct: <"Extracts the originally traded product.">
 		originalTrade -> trade -> tradableProduct

	alias optionPayout: <"Extracts the optionPayout from exerciseInstruction if provided or from the original trade if absent">
		if exerciseInstruction -> exerciseOption exists then exerciseInstruction -> exerciseOption
			else tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element

	alias underlier: <"Extracts the underlying financial product, upon which the option decision is contingent. Requires that the original contract contains an option payout.">
 		optionPayout -> underlier

  	alias execution: <"Creates the execution primitive describing the exchange of the underlying product, either as a cash transfer or as the formation of a new contractual product between parties.">
 		Create_Execution(
 		    Create_ExecutionInstruction(
                underlier,
                tradableProduct -> tradeLot only-element -> priceQuantity,
                tradableProduct -> counterparty,
                tradableProduct -> ancillaryParty,
                originalTrade -> trade -> party,
                originalTrade -> trade -> partyRole,
                empty,
                originalTrade -> trade -> tradeDate,
                exerciseInstruction -> replacementTradeIdentifier
            )
        ) 

	condition OptionPayoutExists: <"Requires that the original contract contains an option payout.">
 		optionPayout exists

	add exercise: <"Reduces notional / quantity of option by the amount exercised.">
		Create_TradeState( exerciseInstruction->exerciseQuantity, originalTrade )

	add exercise: <"Adds the replacement trade">
		execution

func Create_Reset: <"Defines how a Reset should be constructed.">
	inputs:
		instruction ResetInstruction (1..1) <"Specifies the reset instructions.">
		tradeState TradeState (1..1) <"Specifies the trade that is resetting.">
	output:
		reset TradeState (1..1)

	alias payout: <"Specifies the payout that is resetting.">
		instruction -> payout

	alias observationDate: <"If the rateRecordDate is provided in the instructions, it should used as the observation date when determining the fixing rate for an interest rate payout.">
		if instruction -> rateRecordDate exists
		then instruction -> rateRecordDate
		else instruction -> resetDate

	alias observationIdentifiers: <"Resolves the ObservationIdentifier to be used to derive the single observation to be used in the reset calculation. Resolving the ObservationIdentifier is dependent on the type of payout in use.">
		if payout -> performancePayout count = 1 then ResolvePerformanceObservationIdentifiers(payout -> performancePayout only-element, instruction -> resetDate)
		else if payout -> interestRatePayout exists then ResolveInterestRateObservationIdentifiers(payout -> interestRatePayout only-element, observationDate)

	alias observation: <"Represents the single observation that will be used to compute the reset value.">
		ResolveObservation([observationIdentifiers], empty)

	set reset:
		tradeState

	add reset -> resetHistory: <"To handle the various ways Contracts can change over time, ">
    	if payout -> performancePayout count = 1 then ResolvePerformanceReset(payout -> performancePayout only-element, observation, instruction -> resetDate)
		else if payout -> interestRatePayout exists then ResolveInterestRateReset(payout -> interestRatePayout, observation, instruction -> resetDate, instruction -> rateRecordDate)

func CalculateTransfer: <"Function specification to calculate a transfer, e.g. following a reset on a contract">
	inputs:
		instruction CalculateTransferInstruction (1..1)
	output:
		transfer Transfer (0..*)

	add transfer: <"Assigns the result of the Create_Transfer function to the transferHistory attribute.">
		if instruction -> payout -> interestRatePayout exists or instruction -> payout -> performancePayout exists or instruction -> payout -> securityFinancePayout exists then
			Create_CashTransfer( instruction )

	add transfer: <"Assigns the result of the Create_SecurityTransfer function to the transferHistory attribute.">
        if instruction -> payout -> securityPayout exists then
            Create_SecurityTransfer( instruction -> tradeState, instruction -> date, instruction->quantity )

    add transfer: <"Assigns the result of the Create_SecurityFinanceTransfer function to the transferHistory attribute.">
        if instruction -> payout -> securityFinancePayout exists then
            Create_SecurityFinanceTransfer( instruction )
			
func Create_Transfer: <"Defines how a transfer should be constructed, when representing the exchange of cash between parties.">
	inputs:
		instruction TransferInstruction (1..1)
		tradeState TradeState (1..1) <"Represents the trade and associated state on which to construct the Transfer data type.">
	output:
		transfer TradeState (1..1)

	set transfer : tradeState

	add transfer -> transferHistory: <"Assigns the transfer contained in the transfer instruction to the transferHistory attribute.">
		instruction -> transferState

func Create_CashTransfer: <"Defines how Transfer that represents an exchange of cash, should be constructed.">
	inputs:
		instruction CalculateTransferInstruction (1..1)
	output:
		transfer Transfer (1..1)

	set transfer: <"Resolves the cashflow due to be transferred from the trade and associated state.">
		ResolveTransfer( instruction )

func Create_SecurityTransfer: <"Defines the creation of a Transfer, given a Trade State and date.">
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)
		quantity Quantity (0..1) <"Specifies quantity amount returned if not the full amount from the TradeState, e.g. partial return">
	output:
		transfer Transfer (1..1)

	post-condition UnitsAndObservable:
		if tradeState -> trade -> tradableProduct -> product -> security exists
			and tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> settlementTerms -> transferSettlementType only-element = TransferSettlementEnum -> DeliveryVersusPayment
		then transfer -> quantity -> unit -> currency only exists
			and transfer -> observable -> productIdentifier exists

func Create_SecurityFinanceTransfer: <"Defines how Transfer that represents an exchange of security based on a security finance payout, should be constructed.">
	inputs:
		instruction CalculateTransferInstruction (1..1)
	output:
		transfer Transfer (1..1)

	alias securityFinancePayout:
		instruction -> tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout only-element

	alias tradeQuantity: <"Security quantity obtained by filtering on the trade quantity">
		FilterQuantityByFinancialUnit(instruction -> tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity, FinancialUnitEnum -> Share) only-element

	alias securityQuantity:
		if instruction -> quantity exists
		then instruction -> quantity
        else Create_NonNegativeQuantity( tradeQuantity -> value, tradeQuantity -> unit )

    alias securityPrice:
        FilterPrice(instruction -> tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> price, PriceTypeEnum -> AssetPrice, empty, empty, empty, empty, empty, empty)

	condition ShareUnits:
		if instruction -> quantity exists
		then instruction -> quantity -> unit -> financialUnit = FinancialUnitEnum -> Share

	set transfer -> quantity:
		Create_NonNegativeQuantity( securityQuantity -> value, securityQuantity -> unit )

	add transfer -> observable -> productIdentifier:
    	securityFinancePayout -> securityInformation -> security -> productIdentifier

	set transfer -> payerReceiver -> payerPartyReference:
		if instruction -> payerReceiver -> payer exists then
		    ExtractCounterpartyByRole( instruction -> tradeState -> trade -> tradableProduct -> counterparty, instruction -> payerReceiver -> payer ) -> partyReference
		else if securityFinancePayout -> payerReceiver -> payer exists then
		    ExtractCounterpartyByRole( instruction -> tradeState -> trade -> tradableProduct -> counterparty, securityFinancePayout -> payerReceiver -> payer ) -> partyReference

	set transfer -> payerReceiver -> receiverPartyReference:
		if instruction -> payerReceiver -> payer exists then
		    ExtractCounterpartyByRole( instruction -> tradeState -> trade -> tradableProduct -> counterparty, instruction -> payerReceiver -> receiver ) -> partyReference
		else if securityFinancePayout -> payerReceiver -> receiver exists then
		    ExtractCounterpartyByRole( instruction -> tradeState -> trade -> tradableProduct -> counterparty, securityFinancePayout -> payerReceiver -> receiver ) -> partyReference

	set transfer -> settlementDate -> adjustedDate:
        instruction -> date

    set transfer -> settlementOrigin -> securityFinancePayout:
		if instruction -> tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout exists
		then instruction -> tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout only-element
		as-key

func ResolveTransfer: <"Defines how to calculate the amount due to be transferred after a Reset Event.">
	inputs:
		instruction CalculateTransferInstruction (1..1)
	output:
		transfer Transfer (1..1)
	alias payout:
		instruction -> payout
	set transfer:
	    if payout -> securityFinancePayout exists
            then SecurityFinanceCashSettlementAmount(instruction -> tradeState, instruction -> date, instruction -> quantity, instruction -> payerReceiver)
		else if payout -> performancePayout exists
			then EquityCashSettlementAmount(instruction -> tradeState, instruction -> date)
		else if payout -> interestRatePayout -> rateSpecification -> floatingRate exists
				or payout -> interestRatePayout -> rateSpecification -> fixedRate exists
			then InterestCashSettlementAmount(instruction -> tradeState, payout -> interestRatePayout only-element, instruction -> resets, instruction -> date)
    set transfer -> settlementDate -> adjustedDate:
        instruction -> date

func ResolveCashSettlementDate: <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: tradeState TradeState (1..1)
	output: date date (1..1)

func SecurityFinanceCashSettlementAmount:
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)
		quantity Quantity (0..1) <"Specifies quantity amount returned if not the full amount from the TradeState, e.g. partial return">
		payerReceiver PayerReceiver (0..1)

	output:
		securityFinanceCashSettlementAmount Transfer (1..1)

	alias securityFinancePayout:
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout only-element

	alias securityQuantity: <"Specifies the number of securities.">
		if quantity exists
		then quantity
        else FilterQuantityByFinancialUnit( tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity, FinancialUnitEnum -> Share)

    alias securityPrice: <"Specifies the price per security.">
        FilterPrice( tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> price, PriceTypeEnum -> AssetPrice, empty, empty, empty, empty, empty, empty)

	alias marginRatio:
		if securityFinancePayout -> collateralProvisions -> marginPercentage -> haircutPercentage exists
			then 1/(1.0-securityFinancePayout -> collateralProvisions -> marginPercentage -> haircutPercentage)
		else if securityFinancePayout -> collateralProvisions -> marginPercentage -> marginPercentage exists
			then securityFinancePayout -> collateralProvisions -> marginPercentage -> marginPercentage
		else 1.0

	condition ShareUnitExists:
		if quantity exists
		then quantity -> unit -> financialUnit = FinancialUnitEnum -> Share

    condition ProductIdentifiersMatch:
        tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> observable -> productIdentifier = securityFinancePayout -> securityInformation -> security -> productIdentifier

	set securityFinanceCashSettlementAmount -> quantity -> value:
        securityPrice -> value * securityQuantity -> value * marginRatio

	set securityFinanceCashSettlementAmount -> quantity -> unit -> currency:
         securityPrice -> unit -> currency

	set securityFinanceCashSettlementAmount -> payerReceiver -> payerPartyReference:
		if payerReceiver exists then
		    ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, payerReceiver -> receiver ) -> partyReference
		else if securityFinancePayout -> payerReceiver -> receiver exists then
		    ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, securityFinancePayout -> payerReceiver -> receiver ) -> partyReference

	set securityFinanceCashSettlementAmount -> payerReceiver -> receiverPartyReference:
		if payerReceiver exists then
		    ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, payerReceiver -> payer ) -> partyReference
		else if securityFinancePayout -> payerReceiver -> payer exists then
		    ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, securityFinancePayout -> payerReceiver -> payer ) -> partyReference

    set securityFinanceCashSettlementAmount -> settlementDate -> adjustedDate:
        date

	set securityFinanceCashSettlementAmount -> settlementOrigin -> securityFinancePayout:
		securityFinancePayout as-key

func Create_Split: <"Defines the logic for splitting a trade into separate copies. The split instruction contains a breakdown into N set of primitive instructions. Each set contains the primitive instructions to be applied to each post-split trade, eventually producing N trades. The split function underpins a number of business events such as clearing or allocation.">
	inputs:
		breakdown PrimitiveInstruction (1..*) <"Each primitive instruction contains the set of instructions to be applied to each post-split trade.">
		originalTrade TradeState (1..1) <"The original trade to be split, which must be of single cardinality.">
	output:
		splitTrade TradeState (1..*)

	add splitTrade: <"Iterate over each breakdown and apply the set of primitive instructions to each copy of the original trade.">
		breakdown
			extract [ Create_TradeState( item, originalTrade ) ]

func Create_PartyChange: <"Defines the logic for changing one of the counterparties on a trade. A new trade identifier must be specified as a change of party results in a new trade. An ancillary party can also be specified, for instance to refer to the original executing party on the new trade.">
	inputs:
		counterparty Counterparty (1..1) <"The counterparty to change and the role it plays in the transaction.">
		ancillaryParty AncillaryParty (0..1) <"Optional ancillary party, which can be used to keep a reference to the original executing party, for instance.">
		partyRole PartyRole (0..1)
        tradeId Identifier (1..*) <"A mandatory trade identifier must be specified, as the chnage of party results in a new trade.">
		originalTrade TradeState (1..1) <"The original trade on which to update the counterparty. The original trade will be terminated.">
	output:
		newTrade TradeState (1..1)

	alias counterparty1:
		if counterparty -> role = CounterpartyRoleEnum -> Party1
		then Create_Counterparty( counterparty -> partyReference, counterparty -> role )
		else ExtractCounterpartyByRole( originalTrade -> trade -> tradableProduct -> counterparty, CounterpartyRoleEnum -> Party1 )
	alias counterparty2:
		if counterparty -> role = CounterpartyRoleEnum -> Party2
		then Create_Counterparty( counterparty -> partyReference, counterparty -> role)
		else ExtractCounterpartyByRole( originalTrade -> trade -> tradableProduct -> counterparty, CounterpartyRoleEnum -> Party2 )
	alias partyToRemove:
        ExtractCounterpartyByRole( originalTrade -> trade -> tradableProduct -> counterparty, counterparty -> role ) -> partyReference

	set newTrade: <"Copy the original trade.">
		originalTrade
	set newTrade -> trade -> tradableProduct -> counterparty: <"Assigns the new counterparties.">
		[counterparty1, counterparty2]
	set newTrade -> trade -> party: <"Removes the existing party, and adds the new party.">
		ReplaceParty( originalTrade -> trade -> party,
		    partyToRemove,
		    counterparty -> partyReference )
	set newTrade -> trade -> tradeIdentifier: <"Replaces the existing trade identifier with the new trade identifier"> 
		tradeId
	add newTrade -> trade -> party: <"Add ancillary party as an additional party">
		ancillaryParty -> partyReference
	add newTrade -> trade -> tradableProduct -> ancillaryParty: <"Add ancillary party role">
		ancillaryParty
	add newTrade -> trade -> party: <"Add party role party reference as an additional party">
        partyRole -> partyReference
    add newTrade -> trade -> partyRole: <"Add party role">
        partyRole
    set newTrade -> transferHistory: <"Clear transfer history.">
        EmptyTransferHistory()

func EmptyTransferHistory:
    output: emptyTransferHistory TransferState (0..*)

func Create_QuantityChangeInstruction:
    inputs:
        change PriceQuantity (1..*)
        direction QuantityChangeDirectionEnum (1..1)
        lotIdentifier Identifier (0..*)
    output:
        instruction QuantityChangeInstruction (1..1)

    add instruction -> change: change
    set instruction -> direction: direction
    add instruction -> lotIdentifier: lotIdentifier

func Create_QuantityChange: <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	inputs:
	    instruction QuantityChangeInstruction (1..1)
		tradeState TradeState (1..1)
	output:
		quantityChange TradeState (1..1)

    alias tradableProduct: <"TradableProduct from the input TradeState">
        tradeState -> trade -> tradableProduct

    alias tradeLot: <"For direction Decrease or Replace, get the TradeLot to update.">
        if instruction -> direction <> QuantityChangeDirectionEnum -> Increase
        then if instruction -> lotIdentifier exists
            then FilterTradeLot( tradableProduct -> tradeLot, instruction -> lotIdentifier ) only-element
            else tradableProduct -> tradeLot only-element

    alias newPriceQuantity: <"Update PriceQuantity based on change and direction inputs. For an Increase, the change PriceQuantity will be added to the list of TradeLots. For a Decrease or Replace, apply the changes to the existing PriceQuantity.">
        if instruction -> direction = QuantityChangeDirectionEnum -> Increase
        then instruction -> change
        else UpdateAmountForEachMatchingQuantity( tradeLot -> priceQuantity, instruction -> change, instruction -> direction )

    alias newTradeLots: <"Add or merge updated TradeLot.">
        if instruction -> direction = QuantityChangeDirectionEnum -> Increase
        then AddTradeLot( tradableProduct, Create_TradeLot( instruction -> lotIdentifier, newPriceQuantity ) ) -> tradeLot
        else MergeTradeLot( tradableProduct -> tradeLot, Create_TradeLot( instruction -> lotIdentifier, newPriceQuantity ) )

	condition CashPriceOnly: <"Only termination where the termination price is specified as a cash price is supported for now.">
		if instruction -> direction = QuantityChangeDirectionEnum -> Decrease and instruction -> change -> price exists
		then instruction -> change -> price -> priceExpression -> priceType all = PriceTypeEnum -> CashPrice

	set quantityChange : tradeState

	set quantityChange -> trade -> tradableProduct: <"Update trade with new TradableProduct.">
		Create_TradableProduct(
			tradableProduct -> product,
			newTradeLots,
			tradableProduct -> counterparty,
			tradableProduct -> ancillaryParty,
			tradableProduct -> adjustment )

    set quantityChange -> state -> positionState:
        if newTradeLots-> priceQuantity -> quantity -> value all = 0
			then PositionStatusEnum -> Closed

func Create_TermsChange: <"A specification of the inputs, outputs and constraints when calculating the after tradeState based Terms Change Primitive Instruction.">
	inputs:
		termsChange TermsChangeInstruction (1..1) <"Instructions to be used as an input to the function">
		before TradeState (1..1) <"current trade to be ammended">

	output:
		tradeState TradeState (1..1)

	alias newProduct:
		if termsChange -> product exists then termsChange -> product
		else before -> trade -> tradableProduct -> product

	alias newAncillaryParty:
		if termsChange -> ancillaryParty exists then termsChange -> ancillaryParty
		else before -> trade -> tradableProduct -> ancillaryParty

	alias newAdjustment:
		if termsChange -> adjustment exists then termsChange -> adjustment
		else before -> trade -> tradableProduct -> adjustment

	set tradeState: before

	set tradeState -> trade -> tradableProduct: <"Contract to be updated based on the new terms change inputs.">
		Create_TradableProduct(
			newProduct,
			tradeState -> trade -> tradableProduct -> tradeLot,
			tradeState -> trade -> tradableProduct -> counterparty,
			newAncillaryParty,
			newAdjustment )

func FilterOpenTradeStates: <"Filter to only 'open' TradeState - where both the closedState and positionState are not set.">
	inputs:
		tradeStates TradeState (0..*)
	output:
		openTradeStates TradeState (0..*)

	add openTradeStates:
	    tradeStates
	        filter [ item -> state -> closedState is absent ]

func FilterClosedTradeStates: <"Filter to only 'closed' TradeState - where either the closedState or positionState are set.">
	inputs:
		tradeStates TradeState (0..*)
	output:
		closedTradeStates TradeState (0..*)

	add closedTradeStates:
	    tradeStates
	        filter [ item -> state -> closedState exists ]

func NewEquitySwapProduct: <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement. The inputs represent the minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">
	inputs:
		security Security (1..1) <"The underlying Equity asset for the swap.">
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1) <"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">
	//	performancePayout PerformancePayout (1..1)
	output:
		product Product (1..1)

	alias payout:
		product -> contractualProduct -> economicTerms -> payout

//	condition PriceReturnTermsOnlyExists:  performancePayout -> returnTerms -> priceReturnTerms only exists

	condition EquitySecurityType: <"Security must be equity (single name).">
		security -> securityType = SecurityTypeEnum -> Equity

	add product -> contractualProduct -> economicTerms -> payout -> performancePayout:
		NewSingleNameEquityPerformancePayout(security, masterConfirmation)
	add product -> contractualProduct -> economicTerms -> payout -> interestRatePayout: <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications">
		if masterConfirmation exists then NewFloatingPayout(masterConfirmation)

	post-condition PayoutType: <"Other payout types must be absent.">
		if masterConfirmation is absent then payout -> interestRatePayout is absent
			and payout -> cashflow is absent
			and payout -> creditDefaultPayout is absent
			and payout -> forwardPayout is absent
			and payout -> fixedPricePayout is absent
			and payout -> optionPayout is absent

	post-condition ContractualProductOnlyExists: <"Non-contractual product types must be absent.">
		product -> contractualProduct only exists

func NewSingleNameEquityPerformancePayout: <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
    inputs:
		security Security (1..1)
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output:
		performancePayout PerformancePayout (1..1)

	condition EquitySecurityType: <"Security must be equity (single name).">
		security -> securityType = SecurityTypeEnum->Equity

	set performancePayout -> returnTerms -> priceReturnTerms -> returnType: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		
		//if masterConfirmation -> typeOfSwapElection -> Price exists
		//or masterConfirmation -> typeOfSwapElection -> Total exists then
		masterConfirmation -> typeOfSwapElection

	set performancePayout -> valuationDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> valuationDates
	set performancePayout -> paymentDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> equityCashSettlementDates
	set performancePayout -> settlementTerms: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> settlementTerms

func NewFloatingPayout: <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs: masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output: interestRatePayout InterestRatePayout (1..1)

	post-condition InterestRatePayoutTerms: <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">
		if masterConfirmation exists then 
		//interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod and 
		interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates

func Create_IndexTransitionTermsChange: <"Function specification to create a terms change that contains changes to the floating rate indexes and adds an adjustment spread to any existing spread.">
	inputs:
		instruction IndexTransitionInstruction (1..1) <"Specifies the instructions containing the floating rate index, spread adjustment for each leg to be updated, and the effective date.">
		tradeState TradeState (1..1) <"Specifies the trade to be updated.">
	output:
		termsChange TradeState (1..1) <"Specifies the resulting term change.">

	set termsChange : <"Updates the trade based on each instruction priceQuantity (e.g. one for each floating rate leg).">
		UpdateSpreadAdjustmentAndRateOptions( tradeState, instruction -> priceQuantity )

func Create_Observation: <"Function specification to create an observation that incorporates an observation event into the observation history of a given trade state.">
inputs:
instruction ObservationInstruction (1..1)
before TradeState (1..1) <"Specifies the trade to be updated.">

output:
after TradeState (1..1) <"Specifies the resulting trade state incorporating the observation event in the observation history.">

set after : before
add after -> observationHistory  : instruction -> observationEvent

func UpdateSpreadAdjustmentAndRateOptions: <"For each of the trade state's price quantity, find a matching price quantity instruction, and call the update function.">
	inputs:
		tradeState TradeState (1..1) <"Specifies the trade to be updated.">
		instructions PriceQuantity (1..*) <"List of PriceQuantity from the IndexTransitionInstruction (e.g. one for each floating rate leg).">
	output:
		updatedTradeState TradeState (1..1) <"Specifies the updated trade.">

    set updatedTradeState: tradeState

    set updatedTradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity:
        tradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity
            extract [ UpdateIndexTransitionPriceAndRateOption( item, FindMatchingIndexTransitionInstruction( instructions, item ) ) ]

func UpdateIndexTransitionPriceAndRateOption:
    inputs:
        priceQuantity PriceQuantity (1..1)
        instruction PriceQuantity (0..1)
    output:
        updatedPriceQuantity PriceQuantity (1..1)

    set updatedPriceQuantity: priceQuantity

    set updatedPriceQuantity -> price -> value: <"If instruction exists, sum the existing and instruction spread adjustments.">
        if instruction exists then
            priceQuantity -> price only-element -> value + instruction -> price only-element -> value
        else
            priceQuantity -> price only-element -> value

    set updatedPriceQuantity -> observable -> rateOption: <"If instruction exists, update the rate option.">
        if instruction exists then
            instruction -> observable -> rateOption
        else
            priceQuantity -> observable -> rateOption

func FindMatchingIndexTransitionInstruction:
    inputs:
        instructions PriceQuantity (1..*)
        priceQuantity PriceQuantity (1..1)
    output:
        matchingInstruction PriceQuantity (0..1)

    set matchingInstruction:
        instructions
            filter [
                // indexTenor period matches
                item -> observable -> rateOption -> indexTenor -> period = priceQuantity -> observable -> rateOption -> indexTenor -> period
                // indexTenor periodMultiplier matches
                and item -> observable -> rateOption -> indexTenor -> periodMultiplier = priceQuantity -> observable -> rateOption -> indexTenor -> periodMultiplier
                // quantity currency or price currency matches
                and (
                    item -> quantity -> unit -> currency = priceQuantity -> quantity -> unit -> currency
                    or item -> price -> unit -> currency = priceQuantity -> price -> unit -> currency
                )
            ] first

func Create_SecurityLendingInvoice: <"Defines the process of calculating and creating a Security Lending Invoice.">
	inputs:
		instruction BillingInstruction (1..1) <"Specifies the instructions for creation of a Security Lending billing invoice.">

	output:
		invoice SecurityLendingInvoice (1..1) <"Produces the Security Lending Invoice">

	set invoice -> sendingParty:
		instruction -> sendingParty

	set invoice -> receivingParty:
		instruction -> receivingParty

	set invoice -> billingStartDate:
		instruction -> billingStartDate

	set invoice -> billingEndDate:
		instruction -> billingEndDate

	add invoice -> billingRecord:
		Create_BillingRecords( instruction -> billingRecordInstruction )

	add invoice -> billingSummary:
		Create_BillingSummary( invoice -> billingRecord )

func Create_BillingRecords: <"Creates for each billing instruction an individual billing record to be included in a Security Lending Billing Invoice">
	inputs:
		billingInstruction BillingRecordInstruction (1..*) <"Instruction for creating the billing records contained within the invoice">
	output:
		billingRecord BillingRecord (1..*)

    add billingRecord:
        billingInstruction
            extract [ Create_BillingRecord( item ) ]

func Create_BillingRecord: <"Creates an individual billing record to be included in a Security Lending Billing Invoice">
	inputs:
		billingInstruction BillingRecordInstruction (1..1) <"Instruction for creating the billing records contained within the invoice">
	output:
		billingRecord BillingRecord (1..1) <"The billing record">

	alias tradeState: <"Creates a trade state with observations attached.">
		Create_SecurityFinanceTradeStateWithObservations (billingInstruction)

	alias billingAmount: <"Resolves the billing amount for the individual trade record.">
		ResolveSecurityFinanceBillingAmount (tradeState, tradeState -> resetHistory only-element, billingInstruction -> recordStartDate, billingInstruction -> recordEndDate, billingInstruction -> settlementDate)

	set billingRecord -> recordStartDate:
		billingInstruction -> recordStartDate

	set billingRecord -> recordEndDate:
		billingInstruction -> recordEndDate

	set billingRecord -> tradeState:
		tradeState

	set billingRecord -> recordTransfer:
		billingAmount

func ResolveSecurityFinanceBillingAmount: <"Calculates the billing amount for a Security Finance transaction.">
	inputs:
		tradeState TradeState (1..1)
		reset Reset (1..1)
		recordStartDate date (1..1)
		recordEndDate date (1..1)
		transferDate date (1..1)

	output:
		transfer Transfer (1..1)

	alias securityQuantity: <"Specifies the number of securities.">
		FilterQuantityByFinancialUnit( tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity, FinancialUnitEnum -> Share)

	alias interestRatePayout: <"The interest payout that represents the lending fee.">
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout only-element

	alias securityFinancePayout: <"The security finance payout that represents the securities lent.">
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout only-element

    alias haircutPercentage:
        (1.0-securityFinancePayout -> collateralProvisions -> marginPercentage -> haircutPercentage)

	alias valuationPercentage:
		(1/haircutPercentage)

	alias marginRatio:
		if securityFinancePayout -> collateralProvisions -> marginPercentage -> haircutPercentage exists
			then valuationPercentage
		else if securityFinancePayout -> collateralProvisions -> marginPercentage -> marginPercentage exists
			then securityFinancePayout -> collateralProvisions -> marginPercentage -> marginPercentage
		else 1.0

	alias billingQuantity:
		reset -> resetValue -> value * securityQuantity -> value * marginRatio

	alias calculationPeriodRange: CalculationPeriodRange(recordStartDate, recordEndDate, empty)

	alias performance:
		if interestRatePayout -> rateSpecification -> fixedRate exists
		then FixedAmount(
			interestRatePayout,
			billingQuantity,
			recordEndDate,
			calculationPeriodRange)
		else if interestRatePayout -> rateSpecification -> floatingRate exists
		then FloatingAmount(
			interestRatePayout,
			reset -> resetValue -> value,
            billingQuantity,
			recordEndDate,
			calculationPeriodRange)

    alias payerPartyReference:
        ExtractCounterpartyByRole(
            tradeState -> trade -> tradableProduct -> counterparty,
            interestRatePayout -> payerReceiver -> payer ) -> partyReference

    alias receiverPartyReference:
        ExtractCounterpartyByRole(
            tradeState -> trade -> tradableProduct -> counterparty,
            interestRatePayout -> payerReceiver -> receiver ) -> partyReference

	set transfer -> quantity -> value:
		performance

	set transfer -> quantity -> unit -> currency:
        interestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency

	set transfer -> payerReceiver -> payerPartyReference:
	    if performance >= 0 then payerPartyReference else receiverPartyReference

	set transfer -> payerReceiver -> receiverPartyReference:
	    if performance >= 0 then receiverPartyReference else payerPartyReference

	set transfer -> settlementDate -> adjustedDate:
		transferDate

func ToMoney:
	inputs:
		quantity Quantity (1..1)
	output:
		money Money (1..1)

	assign-output money -> value: quantity -> value
    assign-output money -> unit -> currency: quantity -> unit -> currency

func Create_BillingSummary: <"Creates a billing summary to be included in a Security Lending Billing Invoice.">

	inputs:
		billingRecord BillingRecord (1..*)

	output:
		billingSummary BillingSummary (1..1)

//sums all billing records and assigns value to billing summary
//sets enum to ParentTotal

func Create_Return: <"Defines the process of partially or fully returning a Security Lending Transaction.">
 	[creation BusinessEvent]

 	inputs:
 		tradeState TradeState (1..1) <"Specifies a previously formed contractual product with a Security Finance payout. It is required that the description of the contractual product be contained within the previous business event, i.e. its lineage must contain the formation of a contractual product.">
 		returnInstruction ReturnInstruction (1..1) <"Specifies the information required to fully return the Stock Loan in accordance with the economic terms of the contractual product.">
		returnDate date (1..1) <"Specifies the date of the full return.">

  	output:
 		returnEvent BusinessEvent (1..1) <"Produces the business event composed of primitive events describing the transfer and termination, as a result of the input return instruction.">

	alias tradableProduct:
			tradeState -> trade -> tradableProduct

	alias quantitySchedule:
		returnInstruction -> quantity
			extract [ Create_NonNegativeQuantitySchedule( item -> value, item -> unit ) ]

	alias changePriceQuantity:
	    Create_PriceQuantity( empty, quantitySchedule, empty )

	add returnEvent -> after: <"Creates a new contract within the quantity change primitive's after state equivalent to the new notional on the partially returned original contract, assuming there's a single security finance transaction in the original financial contract that is part returned.">
 		Create_QuantityChange( Create_QuantityChangeInstruction( [ changePriceQuantity ], QuantityChangeDirectionEnum -> Decrease, empty ), tradeState )

	set returnEvent -> eventDate:
		returnDate


func Create_BusinessEvent: <"Creates a business event from instructions containing primitive instructions and optionally a trade state.">
    [creation BusinessEvent]
	inputs:
		instruction Instruction (1..*)
		intent EventIntentEnum (0..1)
		eventDate date (1..1)
        effectiveDate date (1..1)
	output:
		businessEvent BusinessEvent (1..1)

	add businessEvent -> instruction:
	    instruction

	set businessEvent -> intent:
	    intent

	set businessEvent -> eventDate:
	    eventDate

    set businessEvent -> effectiveDate:
	    effectiveDate

	add businessEvent -> after:
	    instruction
	        extract [
	            if item -> primitiveInstruction -> split exists then
                    Create_Split( item -> primitiveInstruction -> split -> breakdown, item -> before )
				else if item -> primitiveInstruction -> exercise exists then
					Create_Exercise( item -> primitiveInstruction ->exercise, item -> before )

                else
                    [ Create_TradeState( item -> primitiveInstruction , item -> before ) ]
	        ] flatten

	// TODO: we should have a condition to ensure that no trade is 'lost' between the before(s) and the after(s).
	// This can be implemented by looking at the trade identifier attribute on the before state, and making sure it exists in the after state.
	// So for instance where there is a party change (which results in a different trade with a different trade id), the original trade should be split first, and one of the copies should 'close' the trade.

func Create_TradeState: <"Creates a single trade state by applying primitive instructions to an existing trade state (optional in case an execution instruction is included).
    The primitive instructions are applied in the following order:
        Always first:
            - execution, if it exists, otherwise a before state must be provided
        The following 3 can be executed in any order, because they touch separate components of the trade:
            - quantity change
            - terms change
            - party change
        Always last:
            - contract formation, otherwise the contract could be invalid.">
	inputs:
		primitiveInstruction PrimitiveInstruction (0..1) <"The set of primitive instructions to apply to the trade.">
		before TradeState (0..1) <"The original trade on which the primitive instructions are applied">

	output:
		after TradeState (1..1) <"The returned trade state must be of single cardinality. Where a different trade is created and the original trade must be persisted (for instance showing as 'closed'), it should be preceded by a split instruction.">

	alias execution: <"Create execution if no before exists.">
		if before exists then before
		else Create_Execution( primitiveInstruction -> execution )

	alias quantityChange: <"Apply quantity change if instructions exist.">
		if primitiveInstruction -> quantityChange is absent then execution
		else Create_QuantityChange( primitiveInstruction -> quantityChange, execution)

	alias termsChange: <"Apply terms change if instructions exist.">
		if primitiveInstruction -> termsChange is absent then quantityChange
		else Create_TermsChange( primitiveInstruction -> termsChange, quantityChange)

	alias partyChange: <"Apply party change if instructions exist.">
		if primitiveInstruction -> partyChange is absent then termsChange
		else Create_PartyChange(
			primitiveInstruction -> partyChange -> counterparty,
			primitiveInstruction -> partyChange -> ancillaryParty,
			primitiveInstruction -> partyChange -> partyRole,
            primitiveInstruction -> partyChange -> tradeId,
			termsChange /*after*/
        )

	alias contractFormation: <"Create contract formation if instructions exist.">
		if primitiveInstruction exists and primitiveInstruction -> contractFormation is absent then partyChange
		else Create_ContractFormation( primitiveInstruction -> contractFormation, partyChange)

	alias transfer:
		if primitiveInstruction -> transfer is absent then contractFormation
		else Create_Transfer( primitiveInstruction -> transfer, contractFormation) 
	
	alias reset:
		if primitiveInstruction -> reset is absent then transfer
		else Create_Reset( primitiveInstruction -> reset, transfer )

    alias indexTransition:
        if primitiveInstruction -> indexTransition is absent then reset
        else Create_IndexTransitionTermsChange( primitiveInstruction -> indexTransition, reset )

	alias observation:
		if primitiveInstruction -> observation is absent then indexTransition
		else Create_Observation ( primitiveInstruction -> observation, indexTransition)

    alias stockSplit:
       if primitiveInstruction -> stockSplit is absent then observation
       else Create_StockSplit( primitiveInstruction -> stockSplit, observation )

	condition NoSplit: <"The primitive instruction cannot contain a split, as this function is designed to return a single trade state.">
		primitiveInstruction -> split is absent

	set after: <"Initiate applying primitive instructions.">
		stockSplit

	set after -> state -> closedState:
		if contractFormation -> state -> positionState = PositionStatusEnum -> Closed then
		    Create_ClosedState( ClosedStateEnum -> Terminated, empty, empty, empty )

func Create_ClosedState:
    inputs:
        state ClosedStateEnum (1..1)
        activityDate date (0..1)
        effectiveDate date (0..1)
        lastPaymentDate date (0..1)
    output:
        closedState ClosedState (1..1)

    set closedState -> state: state
    set closedState -> activityDate: activityDate
    set closedState -> effectiveDate: effectiveDate
    set closedState -> lastPaymentDate: lastPaymentDate

func Create_PrimitiveInstruction:
    inputs:
        contractFormation ContractFormationInstruction (0..1)
        execution ExecutionInstruction (0..1)
        exercise ExerciseInstruction (0..1)
        partyChange PartyChangeInstruction (0..1)
        quantityChange QuantityChangeInstruction (0..1)
        reset ResetInstruction (0..1)
        split SplitInstruction (0..1)
        termsChange TermsChangeInstruction (0..1)
        transfer TransferInstruction (0..1)
        indexTransition IndexTransitionInstruction (0..1)
		observation ObservationInstruction (0..1)
        stockSplit StockSplitInstruction (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (1..1)

    set primitiveInstruction -> contractFormation: contractFormation
    set primitiveInstruction -> execution: execution
    set primitiveInstruction -> exercise: exercise
    set primitiveInstruction -> partyChange: partyChange
    set primitiveInstruction -> quantityChange: quantityChange
    set primitiveInstruction -> reset: reset
    set primitiveInstruction -> split: split
    set primitiveInstruction -> termsChange: termsChange
    set primitiveInstruction -> transfer: transfer
    set primitiveInstruction -> indexTransition: indexTransition
	set primitiveInstruction -> observation : observation
    set primitiveInstruction -> stockSplit: stockSplit

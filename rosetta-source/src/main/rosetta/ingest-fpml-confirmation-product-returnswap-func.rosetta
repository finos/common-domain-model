namespace cdm.ingest.fpml.confirmation.product.returnswap: <"FpML ReturnSwap product mapping functions.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.party.*
import cdm.ingest.fpml.confirmation.common.*
import cdm.ingest.fpml.confirmation.datetime.*
import cdm.ingest.fpml.confirmation.other.*
import cdm.ingest.fpml.confirmation.party.*
import cdm.ingest.fpml.confirmation.pricequantity.*
import cdm.ingest.fpml.confirmation.product.swap.*
import cdm.ingest.fpml.confirmation.settlement.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.template.*

import fpml.consolidated.* as fpml
import fpml.consolidated.* as fpml
import fpml.consolidated.accumulator.* as fpml
import fpml.consolidated.asset.* as fpml
import fpml.consolidated.bond.option.* as fpml
import fpml.consolidated.business.events.* as fpml
import fpml.consolidated.business.events.* as fpml
import fpml.consolidated.cd.* as fpml
import fpml.consolidated.clearing.processes.* as fpml
import fpml.consolidated.com.* as fpml
import fpml.consolidated.confirmation.processes.* as fpml
import fpml.consolidated.correlation.swaps.* as fpml
import fpml.consolidated.credit.event.notification.* as fpml
import fpml.consolidated.dividend.swaps.* as fpml
import fpml.consolidated.doc.* as fpml
import fpml.consolidated.eq.shared.* as fpml
import fpml.consolidated.eqd.* as fpml
import fpml.consolidated.fpmlenum.* as fpml
import fpml.consolidated.fpmlenum.* as fpml
import fpml.consolidated.fpmlreturn.swaps.* as fpml
import fpml.consolidated.fpmlstandard.* as fpml
import fpml.consolidated.fx.* as fpml
import fpml.consolidated.fx.accruals.* as fpml
import fpml.consolidated.fx.targets.* as fpml
import fpml.consolidated.generic.* as fpml
import fpml.consolidated.ird.* as fpml
import fpml.consolidated.loan.* as fpml
import fpml.consolidated.main.* as fpml
import fpml.consolidated.mktenv.* as fpml
import fpml.consolidated.msg.* as fpml
import fpml.consolidated.option.shared.* as fpml
import fpml.consolidated.recordkeeping.processes.* as fpml
import fpml.consolidated.reg.fpmlreporting.product.* as fpml
import fpml.consolidated.reg.fpmlreporting.shared.* as fpml
import fpml.consolidated.repo.* as fpml
import fpml.consolidated.riskdef.* as fpml
import fpml.consolidated.sec.lending.* as fpml
import fpml.consolidated.shared.* as fpml
import fpml.consolidated.valuation.* as fpml
import fpml.consolidated.valuation.fpmlreporting.* as fpml
import fpml.consolidated.variance.swaps.* as fpml
import fpml.consolidated.volatility.swaps.* as fpml
import fpml.custom.*

func MapReturnSwapCounterpartyList:
    inputs:
        fpmlReturnSwap fpml.ReturnSwap (0..1)
    output:
        counterpartyList Counterparty (0..2)

    add counterpartyList:
        MapPayerReceiverModelToCounterpartyList(
                fpmlReturnSwap -> returnSwapLeg first -> payerReceiverModel
            )

func MapReturnSwapAncillaryPartyList:
    inputs:
        fpmlReturnSwap fpml.ReturnSwap (0..1)
    output:
        ancillaryPartyList AncillaryParty (0..*)

func MapReturnSwapNonTransferableProduct:
    inputs:
        fpmlReturnSwap fpml.ReturnSwap (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        nonTransferableProduct NonTransferableProduct (0..1)

    set nonTransferableProduct:
        NonTransferableProduct {
            identifier: MapProductIdentifierList(fpmlReturnSwap -> productModel),
            taxonomy: MapProductTaxonomyList(fpmlReturnSwap -> productModel),
            economicTerms: MapReturnSwapEconomicTerms(fpmlReturnSwap, cdmCounterpartyList)
        }

func MapReturnSwapEconomicTerms:
    inputs:
        fpmlReturnSwap fpml.ReturnSwap (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        economicTerms EconomicTerms (0..1)

    set economicTerms:
        EconomicTerms {
            effectiveDate: MapAdjustableOrRelativeDate(
                        fpmlReturnSwap -> returnSwapLeg -> effectiveDate first
                    ),
            terminationDate: MapAdjustableOrRelativeDate(
                        fpmlReturnSwap -> returnSwapLeg -> terminationDate first
                    ),
            payout: fpmlReturnSwap -> returnSwapLeg
                    extract MapReturnSwapLegToPayout(item, cdmCounterpartyList),
            ...
        }

func MapReturnSwapLegToPayout:
    inputs:
        fpmlDirectionalLeg fpml.DirectionalLeg (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payout Payout (0..1)

    set payout:
        fpmlDirectionalLeg switch
            fpml.InterestLeg then
                MapInterestLegToInterestRatePayout(item, cdmCounterpartyList),
            fpml.ReturnLeg then
                MapReturnLegToPerformancePayout(item, cdmCounterpartyList),
            default empty

func MapInterestLegToInterestRatePayout:
    inputs:
        fpmlInterestLeg fpml.InterestLeg (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payout Payout (0..1)

    alias fpmlFloatingRateCalculation:
        fpmlInterestLeg -> interestCalculation -> floatingRateCalculation

    set payout:
        Payout {
            InterestRatePayout:
                InterestRatePayout {
                    payerReceiver: MapPayerReceiver(
                                fpmlInterestLeg -> payerReceiverModel,
                                cdmCounterpartyList
                            ),
                    priceQuantity: MapResolvablePriceQuantity(
                                fpmlInterestLeg -> notional,
                                empty,
                                fpmlInterestLeg
                            ),
                    rateSpecification:
                        RateSpecification {
                            FixedRateSpecification:
                                FixedRateSpecification {
                                    rateSchedule:
                                        RateSchedule {
                                            price: MapFixedRateToPriceScheduleWithAddress(
                                                        fpmlInterestLeg -> interestCalculation -> fixedRate,
                                                        fpmlInterestLeg
                                                    )
                            }},
                            FloatingRateSpecification: if fpmlFloatingRateCalculation exists
                                    then MapFloatingRateSpecification(
                                            fpmlFloatingRateCalculation,
                                            fpmlInterestLeg
                                        ),
                            ...
                        },
                    dayCountFraction: MapDayCountFractionEnum(
                                fpmlInterestLeg -> interestCalculation -> dayCountFraction -> value
                            ),
                    calculationPeriodDates: MapInterestLegCalculationPeriodDates(
                                fpmlInterestLeg -> interestLegCalculationPeriodDates
                            ),
                    compoundingMethod: fpmlInterestLeg -> interestCalculation -> compounding -> compoundingMethod to-enum CompoundingMethodEnum,
                    paymentDates: MapInterestLegPaymentDates(
                                fpmlInterestLeg -> interestLegCalculationPeriodDates -> interestLegPaymentDates
                            ),
                    stubPeriod: MapStubCalculationPeriodToStubPeriod(
                                fpmlInterestLeg -> stubCalculationPeriod
                            ),
                    resetDates: MapInterestLegResetDates(
                                fpmlInterestLeg -> interestLegCalculationPeriodDates -> interestLegResetDates
                            ),
                    ...
                },
            ...
        }

func MapResolvablePriceQuantity:
    inputs:
        fpmlReturnSwapNotional fpml.ReturnSwapNotional (0..1)
        fpmlReset boolean (0..1)
        fpmlLeg fpml.Leg (0..1)
    output:
        resolvablePriceQuantity ResolvablePriceQuantity (0..1)

    set resolvablePriceQuantity:
        ResolvablePriceQuantity {
            quantitySchedule: MapNotionalAmountToQuantityWithAddress(
                        fpmlReturnSwapNotional -> notionalAmount -> amount,
                        fpmlLeg
                    ),
            quantityReference: MapResolvablePriceQuantityReference(
                        fpmlReturnSwapNotional -> relativeNotionalAmount -> href
                    ),
            reset: fpmlReset,
            ...
        } with-meta {
            key: fpmlReturnSwapNotional -> notionalAmount -> id
        }

func MapInterestLegCalculationPeriodDates:
    inputs:
        fpmlInterestLegCalculationPeriodDates fpml.InterestLegCalculationPeriodDates (0..1)
    output:
        calculationPeriodDates CalculationPeriodDates (0..1)

    set calculationPeriodDates:
        CalculationPeriodDates {
            effectiveDate: MapAdjustableOrRelativeDate(
                        fpmlInterestLegCalculationPeriodDates -> effectiveDate
                    ),
            terminationDate: MapAdjustableOrRelativeDate(
                        fpmlInterestLegCalculationPeriodDates -> terminationDate
                    ),
            ...
        }
    set calculationPeriodDates -> key: fpmlInterestLegCalculationPeriodDates -> id

func MapStubCalculationPeriodToStubPeriod:
    inputs:
        fpmlStubCalculationPeriod fpml.StubCalculationPeriod (0..1)
    output:
        stubPeriod StubPeriod (0..1)

    set stubPeriod:
        StubPeriod {
            calculationPeriodDatesReference: empty,
            finalStub: MapStubValue(fpmlStubCalculationPeriod -> finalStub),
            initialStub: MapStubValue(
                        fpmlStubCalculationPeriod -> stubCalculationPeriodSequence -> initialStub
                    )
        }

func MapInterestLegPaymentDates:
    inputs:
        fpmlAdjustableRelativeOrPeriodicDates2 fpml.AdjustableRelativeOrPeriodicDates2 (0..1)
    output:
        paymentDates PaymentDates (0..1)

    set paymentDates:
        PaymentDates {
            paymentDateSchedule:
                PaymentDateSchedule {
                    interimPaymentDates: MapAdjustableRelativeOrPeriodicDates2(
                                fpmlAdjustableRelativeOrPeriodicDates2
                            ),
                    ...
                },
            ...
        } with-meta {
            key: fpmlAdjustableRelativeOrPeriodicDates2 -> id
        }

func MapInterestLegResetDates:
    inputs:
        fpmlInterestLegResetDates fpml.InterestLegResetDates (0..1)
    output:
        resetDates ResetDates (0..1)

    set resetDates:
        ResetDates {
            resetRelativeTo: MapResetRelativeToEnum(
                        fpmlInterestLegResetDates -> resetRelativeTo to-string
                    ),
            initialFixingDate:
                InitialFixingDate {
                    relativeDateOffset: MapRelativeDateOffset(
                                fpmlInterestLegResetDates -> initialFixingDate
                            ),
                    ...
                },
            fixingDates: MapRelativeDateOffset(
                        fpmlInterestLegResetDates -> fixingDates -> relativeDate
                    ),
            resetFrequency: MapResetFrequency(fpmlInterestLegResetDates -> resetFrequency),
            ...
        }
    set resetDates -> calculationPeriodDatesReference -> reference:
        fpmlInterestLegResetDates -> calculationPeriodDatesReference -> href

func MapReturnLegToPerformancePayout:
    inputs:
        fpmlReturnLeg fpml.ReturnLeg (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        payout Payout (0..1)

    set payout:
        Payout {
            PerformancePayout:
                PerformancePayout {
                    payerReceiver: MapPayerReceiver(
                                fpmlReturnLeg -> payerReceiverModel,
                                cdmCounterpartyList
                            ),
                    paymentDates:
                        PaymentDates {
                            paymentDateSchedule: MapPaymentDateSchedule(
                                        fpmlReturnLeg -> rateOfReturn -> paymentDates
                                    ),
                            ...
                        },
                    valuationDates: MapReturnLegValuationToValuationDates(
                                fpmlReturnLeg -> rateOfReturn
                            ),
                    priceQuantity: MapResolvablePriceQuantity(
                                fpmlReturnLeg -> notional,
                                fpmlReturnLeg -> rateOfReturn -> notionalReset,
                                fpmlReturnLeg
                            ),
                    settlementTerms: MapOptionSettlementModelToSettlementTerms(
                                fpmlReturnLeg -> optionSettlementModel
                            ),
                    underlier:
                        Underlier {
                            Observable: MapUnderlyerToObservableWithAddress(
                                        fpmlReturnLeg -> underlyer
                                    ),
                            ...
                        },
                    fxFeature: fpmlReturnLeg -> fxFeature extract MapFxFeature,
                    returnTerms:
                        ReturnTerms {
                            priceReturnTerms:
                                PriceReturnTerms {
                                    returnType: MapReturnTypeEnum(
                                                fpmlReturnLeg -> return -> returnType to-string
                                            ),
                                    ...
                                },
                            dividendReturnTerms: MapReturnSwapDividendReturnTerms(
                                        fpmlReturnLeg -> underlyer -> singleUnderlyer -> dividendPayout,
                                        fpmlReturnLeg -> return -> dividendConditions,
                                        fpmlReturnLeg -> rateOfReturn -> valuationPriceFinal -> valuationRules
                                    ),
                            ...
                        },
                    ...
                },
            ...
        }

func MapPaymentDateSchedule:
    inputs:
        fpmlReturnSwapPaymentDates fpml.ReturnSwapPaymentDates (0..1)
    output:
        paymentDateSchedule PaymentDateSchedule (0..1)

    set paymentDateSchedule:
        PaymentDateSchedule {
            interimPaymentDates: MapAdjustableOrRelativeDatesToAdjustableRelativeOrPeriodicDates(
                        fpmlReturnSwapPaymentDates -> paymentDatesInterim
                    ),
            finalPaymentDate: MapAdjustableOrRelativeDate(
                        fpmlReturnSwapPaymentDates -> paymentDateFinal
                    )
        }

func MapReturnLegValuationToValuationDates:
    inputs:
        fpmlReturnLegValuation fpml.ReturnLegValuation (0..1)
    output:
        valuationDates ValuationDates (0..1)

    set valuationDates:
        ValuationDates {
            interimValuationDate: MapPerformanceValuationDates(
                        fpmlReturnLegValuation -> valuationPriceInterim -> priceSequence -> determinationMethod,
                        fpmlReturnLegValuation -> valuationPriceInterim -> valuationRules
                    ),
            finalValuationDate: MapPerformanceValuationDates(
                        fpmlReturnLegValuation -> valuationPriceFinal -> priceSequence -> determinationMethod,
                        fpmlReturnLegValuation -> valuationPriceFinal -> valuationRules
                    ),
            ...
        }

func MapReturnSwapDividendReturnTerms:
    inputs:
        fpmlDividendPayout fpml.DividendPayout (0..1)
        fpmlDividendConditions fpml.DividendConditions (0..1)
        fpmlEquityValuation fpml.EquityValuation (0..1)
    output:
        dividendReturnTerms DividendReturnTerms (0..1)

    set dividendReturnTerms:
        fpmlDividendConditions
            extract
                DividendReturnTerms {
                    dividendPayoutRatio:
                        DividendPayoutRatio {
                            totalRatio: fpmlDividendPayout -> dividendPayoutSequence -> dividendPayoutRatio,
                            ...
                        },
                    firstOrSecondPeriod: MapDividendPeriodEnum(dividendPeriod to-string),
                    dividendReinvestment: dividendReinvestment,
                    dividendEntitlement: MapDividendEntitlementEnum(
                                dividendEntitlement to-string
                            ),
                    excessDividendAmount: MapDividendAmountTypeEnum(
                                excessDividendAmount to-string
                            ),
                    dividendCurrency: MapDividendCurrency(
                                currencyAndDeterminationMethodModel
                            ),
                    dividendPeriod:
                        DividendPeriod {
                            startDate: MapDateReferenceToDividendPaymentDate(
                                        dividendConditionsSequence -> dividendPeriodEffectiveDate
                                    ),
                            endDate: MapDateReferenceToDividendPaymentDate(
                                        dividendConditionsSequence -> dividendPeriodEndDate
                                    ),
                            dividendPaymentDate: MapDividendPaymentDate(dividendPaymentDate),
                            dateAdjustments: empty,
                            ...
                        },
                    ...
                }

func MapDividendCurrency:
    inputs:
        fpmlCurrencyAndDeterminationMethodModel fpml.CurrencyAndDeterminationMethodModel (0..1)
    output:
        dividendCurrency DividendCurrency (0..1)

    set dividendCurrency:
        DividendCurrency {
            currency: MapCurrency(fpmlCurrencyAndDeterminationMethodModel -> currency),
            determinationMethod: fpmlCurrencyAndDeterminationMethodModel -> determinationMethod -> value to-enum DeterminationMethodEnum,
            currencyReference: MapCurrencyReference(
                        fpmlCurrencyAndDeterminationMethodModel -> currencyReference
                    )
        }

func MapReturnSwapPriceQuantityList:
    inputs:
        fpmlReturnSwap fpml.ReturnSwap (0..1)
    output:
        priceQuantityList PriceQuantity (0..*)

    alias returnLeg:
        (fpmlReturnSwap -> returnSwapLeg
            extract
                item switch
                    fpml.ReturnLeg then item,
                    default empty)
            then only-element

    add priceQuantityList:
        fpmlReturnSwap -> returnSwapLeg
            extract
                item switch
                    fpml.InterestLeg then
                        MapInterestLegToPriceQuantity(item, returnLeg),
                    fpml.ReturnLeg then MapReturnLegToPriceQuantity,
                    default empty

func MapInterestLegToPriceQuantity:
    inputs:
        fpmlInterestLeg fpml.InterestLeg (0..1)
        fpmlReturnLeg fpml.ReturnLeg (0..1)
    output:
        priceQuantity PriceQuantity (0..1)

    set priceQuantity:
        PriceQuantity {
            price: MapInterestCalculationToPriceListWithLocation(
                        fpmlInterestLeg -> interestCalculation,
                        fpmlInterestLeg -> notional -> notionalAmount -> currency default fpmlReturnLeg -> notional -> notionalAmount -> currency,
                        fpmlInterestLeg
                    ),
            quantity: MapNotionalAmountToQuantityWithLocation(
                        fpmlInterestLeg -> notional -> notionalAmount -> amount,
                        empty,
                        fpmlInterestLeg -> notional -> notionalAmount -> currency,
                        fpmlInterestLeg
                    ),
            observable: MapRateOptionToObservableWithLocation(
                        fpmlInterestLeg -> interestCalculation -> floatingRateCalculation,
                        fpmlInterestLeg
                    ),
            ...
        }

func MapInterestCalculationToPriceListWithLocation:
    inputs:
        fpmlInterestCalculation fpml.InterestCalculation (0..1)
        fpmlCurrency fpml.Currency (0..1)
        fpmlLeg fpml.Leg (0..1)
    output:
        priceSchedules PriceSchedule (0..*)
            [metadata location]

    alias fpmlRate: fpmlInterestCalculation -> floatingRateCalculation

    add priceSchedules:
        MapFixedRateToPriceScheduleWithLocation(
                fpmlInterestCalculation -> fixedRate,
                empty,
                fpmlCurrency,
                fpmlLeg
            )

    add priceSchedules:
        MapSpreadScheduleToPriceWithLocation(fpmlRate, fpmlCurrency, fpmlLeg)

func MapNotionalAmountToQuantityList:
    inputs:
        fpmlNotionalAmount fpml.NotionalAmount (0..1)
        fpmlLeg fpml.Leg (0..1)
    output:
        nonNegativeQuantitySchedules NonNegativeQuantitySchedule (0..*)
            [metadata location]

    add nonNegativeQuantitySchedules:
        MapNotionalAmountToQuantityWithLocation(
                fpmlNotionalAmount -> amount,
                empty,
                fpmlNotionalAmount -> currency,
                fpmlLeg
            )

func MapReturnLegToPriceQuantity:
    inputs:
        fpmlReturnLeg fpml.ReturnLeg (0..1)
    output:
        priceQuantity PriceQuantity (0..1)

    alias notionalAmount: fpmlReturnLeg -> notional -> notionalAmount

    set priceQuantity:
        PriceQuantity {
            price: MapNetPriceToPriceListWithLocation(
                        fpmlReturnLeg -> rateOfReturn -> initialPrice,
                        fpmlReturnLeg
                    ),
            quantity: [
                    MapNotionalAmountWithIdToQuantityWithLocation(
                            fpmlReturnLeg -> underlyer -> singleUnderlyer -> openUnits,
                            empty,
                            fpmlReturnLeg -> notional -> notionalAmount -> currency,
                            "openUnits",
                            fpmlReturnLeg
                        ),
                    MapNotionalAmountToQuantityWithLocation(
                            fpmlReturnLeg -> notional -> notionalAmount -> amount,
                            empty,
                            fpmlReturnLeg -> notional -> notionalAmount -> currency,
                            fpmlReturnLeg
                        )
                ],
            observable: MapUnderlyerToObservableWithLocation(fpmlReturnLeg -> underlyer),
            ...
        }

func MapReturnSwapAccountPartyReference:
    inputs:
        fpmlReturnSwap fpml.ReturnSwap (0..1)
        fpmlAccount fpml.Account (0..1)
    output:
        partyReference Party (0..1)
            [metadata reference]

    set partyReference:
        MapPayerReceiverToAccountPartyReference(
                fpmlAccount,
                fpmlReturnSwap -> returnSwapLeg -> payerReceiverModel
            )

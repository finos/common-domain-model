namespace cdm.ingest.fpml.confirmation.workflowstep: <"FpML type mapping functions.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.ingest.fpml.confirmation.common.*
import cdm.ingest.fpml.confirmation.datetime.*
import cdm.ingest.fpml.confirmation.header.*
import cdm.ingest.fpml.confirmation.legal.*
import cdm.ingest.fpml.confirmation.other.*
import cdm.ingest.fpml.confirmation.party.*
import cdm.ingest.fpml.confirmation.payment.*
import cdm.ingest.fpml.confirmation.pricequantity.*
import cdm.ingest.fpml.confirmation.tradestate.*
import cdm.observable.asset.*

import fpml.consolidated.* as fpml
import fpml.consolidated.business.events.* as fpml
import fpml.consolidated.doc.* as fpml
import fpml.consolidated.msg.* as fpml
import fpml.consolidated.shared.* as fpml

func MapWorkflowStep:
    inputs:
        messageId fpml.MessageId (0..1)
        messageHeaderModel fpml.MessageHeaderModel (0..1)
        action ActionEnum (0..1)
        fpmlTrade fpml.Trade (0..1)
        fpmlPartiesAndAccountsModel fpml.PartiesAndAccountsModel (0..1)
        intent EventIntentEnum (0..1)
        eventDate date (0..1)
        effectiveDate date (0..1)
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
        tradingEventsBaseModel fpml.TradingEventsBaseModel (0..1)
    output:
        workflowStep WorkflowStep (0..1)

    set workflowStep:
        WorkflowStep {
            proposedEvent:
                EventInstruction {
                    intent: intent,
                    eventDate: eventDate,
                    effectiveDate: effectiveDate,
                    instruction: [
                            Instruction {
                                primitiveInstruction: MapPrimitiveInstruction(
                                            fpmlTrade,
                                            fpmlPostTradeEventsBaseModel,
                                            tradingEventsBaseModel
                                        ),
                                before: MapTradeState(
                                            fpmlTrade,
                                            fpmlPartiesAndAccountsModel
                                        )
                            }
                        ],
                    ...
                },
            timestamp:
                EventTimestamp {
                    dateTime: messageHeaderModel -> creationTimestamp,
                    qualification: MapEventTimestampQualification(
                                messageHeaderModel,
                                fpmlTrade
                    ),
                },
            eventIdentifier:
                Identifier {
                    assignedIdentifier:
                        AssignedIdentifier {
                            identifier: messageId -> value,
                            ...
                        },
                    ...
                },
            messageInformation: MapMessageInformation(messageId, messageHeaderModel),
            action: action,
            ...
        }

func MapPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        fpmlTradeNotionalChange fpml.PostTradeEventsBaseModel (0..1)
        fpmlTradingEventsBaseModel fpml.TradingEventsBaseModel (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    set primitiveInstruction:
        if fpmlTradeNotionalChange -> novation exists
        then MapNovationToPrimitiveInstruction(fpmlTradeNotionalChange)
        else if fpmlTradeNotionalChange -> postTradeEventsBaseModelSequence -> termination exists
        then MapTerminationToPrimitiveInstruction(
                    fpmlTrade,
                    fpmlTradeNotionalChange -> postTradeEventsBaseModelSequence -> termination
                )
        else if fpmlTradeNotionalChange -> amendment exists
        then MapAmendmentToPrimitiveInstruction(
                    fpmlTrade,
                    fpmlTradeNotionalChange -> amendment
                )
        else if fpmlTradingEventsBaseModel exists
        then MapTradeToPrimitiveInstruction(
                    fpmlTradingEventsBaseModel -> tradingEventsBaseModelSequence -> trade
                )
        else if fpmlTrade exists
        then MapTradeToPrimitiveInstruction(fpmlTrade)

func MapTradeToPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    alias counterpartyList: MapCounterpartyList(fpmlTrade)

    set primitiveInstruction:
        PrimitiveInstruction {
            contractFormation:
                ContractFormationInstruction {
                    legalAgreement: MapLegalAgreementList(
                                fpmlTrade -> documentation,
                                counterpartyList
                            )
                },
            ...
        }

func MapAmendmentToPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        amendment fpml.TradeAmendmentContent (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    alias payment: amendment -> tradeAlterationPaymentModel -> payment distinct only-element
    alias feeType: MapFeeTypeEnum(payment -> id)

    set primitiveInstruction:
        PrimitiveInstruction {
            transfer: MapTransferInstruction(payment, feeType),
            ...
        }

func MapNovationToPrimitiveInstruction:
    inputs:
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    add primitiveInstruction -> split -> breakdown:
        fpmlPostTradeEventsBaseModel extract MapBreakdown

func MapBreakdown:
    inputs:
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
    output:
        breakdown PrimitiveInstruction (0..*)

    alias novatedAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmountsOldModel -> novationAmountsOldModelSequence0 -> novatedAmount
    alias changeInNotionalAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmount -> tradeLegNotionalChangeModel -> changeInNotionalAmount
    alias outstandingNotionalAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmount -> tradeLegNotionalChangeModel -> outstandingNotionalAmount
    alias remainingAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmountsOldModel -> novationAmountsOldModelSequence0 -> remainingAmount

    alias changeInstruction:
        if outstandingNotionalAmount exists or remainingAmount exists
        then QuantityChangeDirectionEnum -> Replace
        else Decrease
    alias changeAmount:
        if outstandingNotionalAmount exists
        then outstandingNotionalAmount
        else if remainingAmount exists
        then remainingAmount default novatedAmount

    add breakdown:
        if novatedAmount exists or changeInNotionalAmount exists
        then PrimitiveInstruction {
                quantityChange: MapQuantityChangeInstruction(
                            empty,
                            fpmlPostTradeEventsBaseModel,
                            Replace
                        ),
                partyChange: MapPartyChangeInstruction(fpmlPostTradeEventsBaseModel),
                transfer: MapTransferInstruction(
                            fpmlPostTradeEventsBaseModel -> novation -> payment,
                            Novation
                        ),
                ...
            }

    add breakdown:
        PrimitiveInstruction {
            quantityChange: MapQuantityChangeInstruction(
                        empty,
                        fpmlPostTradeEventsBaseModel,
                        changeInstruction
                    ),
            ...
        }

func MapPartyChangeInstruction:
    inputs:
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
    output:
        partyChange PartyChangeInstruction (0..1)

    alias counterpartyList:
        MapCounterpartyList(
                fpmlPostTradeEventsBaseModel -> novation -> tradeNovationContentSequence0 -> oldTradeModel -> oldTrade
            )

    set partyChange:
        PartyChangeInstruction {
            counterparty: MapPartyChangePayerReceiverModelToCounterparty(
                        fpmlPostTradeEventsBaseModel -> novation -> novationRolesModel -> transferee,
                        fpmlPostTradeEventsBaseModel -> novation -> novationRolesModel -> transferor,
                        counterpartyList
                    ),
            tradeId: fpmlPostTradeEventsBaseModel -> novation -> newTradeModel -> newTradeIdentifier
                    extract
                        MapTradeIdentifierSequenceToTradeIdentifier(tradeIdentifierSequence),
            ...
        }

func MapPartyChangePayerReceiverModelToCounterparty:
    inputs:
        transferee fpml.PartyReference (0..1)
        transferor fpml.PartyReference (0..1)
        counterpartyList Counterparty (0..2)
    output:
        counterparty Counterparty (0..1)

    alias transferorRole:
        counterpartyList
            then filter partyReference -> reference = transferor -> href
            then role only-element

    set counterparty: MapCounterparty(transferorRole, transferee)

func MapTerminationToPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        termination fpml.TradeNotionalChange (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    alias counterpartyList: MapCounterpartyList(fpmlTrade)
    alias terminationPayment: termination -> tradeAlterationPaymentModel -> payment

    set primitiveInstruction:
        PrimitiveInstruction {
            contractFormation:
                ContractFormationInstruction {
                    legalAgreement: MapLegalAgreementList(
                                fpmlTrade -> documentation,
                                counterpartyList
                            )
                },
            quantityChange: MapQuantityChangeInstruction(termination, empty, Replace),
            transfer: MapTransferInstruction(terminationPayment, Termination),
            ...
        }

func MapTransferInstruction:
    inputs:
        fpmlPaymentList fpml.Payment (0..*)
        cdmFeeType FeeTypeEnum (0..1)
    output:
        transferInstruction TransferInstruction (0..1)
    set transferInstruction:
        TransferInstruction {
            transferState: MapPaymentListToTransferStateList(fpmlPaymentList, cdmFeeType)
        }

func MapQuantityChangeInstruction:
    inputs:
        fpmlTradeNotionalChange fpml.TradeNotionalChange (0..1)
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
        quantityChangeDirection QuantityChangeDirectionEnum (0..1)
    output:
        quantityChange QuantityChangeInstruction (0..1)

    alias changeAmount:
        MapPriceQuantity(fpmlTradeNotionalChange, fpmlPostTradeEventsBaseModel)
    set quantityChange:
        QuantityChangeInstruction {
            change: changeAmount,
            direction: quantityChangeDirection,
            ...
        }

func MapPriceQuantity:
    inputs:
        fpmlTradeNotionalChange fpml.TradeNotionalChange (0..1)
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
    output:
        priceQuantityList PriceQuantity (0..*)

    alias outstandingTradeNotional:
        fpmlTradeNotionalChange -> tradeNotionalChangeModel -> tradeNotionalChangeModelSequence0 -> outstandingNotionalAmount
            extract MapNonNegativeMoneyNonNegativeQuantitySchedule

    alias outstandingSizeChange:
        fpmlTradeNotionalChange -> sizeChange -> tradeLegNotionalChangeModel -> outstandingNotionalAmount
            extract MapNonNegativeMoneyNonNegativeQuantitySchedule

    alias novatedAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmountsOldModel -> novationAmountsOldModelSequence0 -> novatedAmount
            extract MapMoneyToNonNegativeQuantitySchedule

    alias changeInNotionalAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmount -> tradeLegNotionalChangeModel -> changeInNotionalAmount
            extract MapNonNegativeMoneyNonNegativeQuantitySchedule

    alias outstandingNotionalAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmount -> tradeLegNotionalChangeModel -> outstandingNotionalAmount
            extract MapNonNegativeMoneyNonNegativeQuantitySchedule

    alias remainingAmount:
        fpmlPostTradeEventsBaseModel -> novation -> novationAmountsModel -> novationAmountsOldModel -> novationAmountsOldModelSequence0 -> remainingAmount
            extract MapMoneyToNonNegativeQuantitySchedule

    alias q:
        [outstandingTradeNotional, outstandingSizeChange, novatedAmount, changeInNotionalAmount, outstandingNotionalAmount, remainingAmount]
            extract CreateQuantityWithLocation(item, CreateQuantityKey(empty, empty))

    add priceQuantityList:
        PriceQuantity {
            quantity: q,
            ...
        }

func MapMoneyToNonNegativeQuantitySchedule:
    inputs:
        fpmlMoney fpml.Money (0..1)
    output:
        priceQuantity NonNegativeQuantitySchedule (0..1)

    set priceQuantity:
        NonNegativeQuantitySchedule {
            value: fpmlMoney -> amount,
            unit:
                UnitType {
                    currency: MapCurrency(fpmlMoney -> currency),
                    ...
                },
            ...
        }

func MapNonNegativeMoneyNonNegativeQuantitySchedule:
    inputs:
        f fpml.consolidated.shared.NonNegativeMoney (0..1)
    output:
        priceQuantityList NonNegativeQuantitySchedule (0..1)

    set priceQuantityList:
        NonNegativeQuantitySchedule {
            value: f -> amount,
            unit:
                UnitType {
                    currency: f -> currency -> value,
                    ...
                },
            ...
        }

func MapMessageInformation:
    inputs:
        messageId fpml.MessageId (0..1)
        messageHeaderModel fpml.MessageHeaderModel (0..1)
    output:
        messageInfo MessageInformation (0..1)
    set messageInfo:
        MessageInformation {
            messageId: MapStringWithScheme(messageId -> value, messageId -> messageIdScheme),
            sentBy: MapStringWithScheme(
                        messageHeaderModel -> sentBy -> value,
                        messageHeaderModel -> sentBy -> messageAddressScheme
                    ),
            sentTo: [
                    MapStringWithScheme(
                            messageHeaderModel -> sendTo only-element -> value,
                            messageHeaderModel -> sendTo only-element -> messageAddressScheme
                        )
                ],
            ...
        }

func GetIntent:
    inputs:
        fpmlNovation fpml.TradeNovationContent (0..1)
        fpmlAmendment fpml.TradeAmendmentContent (0..1)
        fpmlOriginatingEvent fpml.OriginatingEvent (0..1)
        fpmlTerminatingEvent fpml.TerminatingEvent (0..1)
        fpmlTrade fpml.Trade (0..1)
    output:
        intent EventIntentEnum (0..1)

    alias intentToAllocate:
        (fpmlTrade -> tradeHeader -> partyTradeInformation
            filter intentToAllocate = True
            )
            then exists
    alias intentToClear:
        (fpmlTrade -> tradeHeader -> partyTradeInformation
            filter intentToClear = True
            )
            then exists

    set intent:
        if intentToAllocate
        then Allocation
        else if intentToClear
        then Clearing
        else if fpmlNovation exists
        then Novation
        else if fpmlAmendment exists
        then ContractTermsAmendment
        else if MapOriginatingEventToIntent(fpmlOriginatingEvent) exists
        then MapOriginatingEventToIntent(fpmlOriginatingEvent)
        else if MapTerminatingEventToIntent(fpmlTerminatingEvent) exists
        then MapTerminatingEventToIntent(fpmlTerminatingEvent)
        else if fpmlTrade exists
        then ContractFormation

func MapOriginatingEventToIntent:
    inputs:
        fpmlOriginatingEvent fpml.OriginatingEvent (0..1)
    output:
        intent EventIntentEnum (0..1)

    alias originatingEventValue: fpmlOriginatingEvent -> value to-string

    set intent:
        originatingEventValue switch
            "Allocation" then Allocation,
            "Netting" then Compression,
            "PortfolioCompression" then Compression,
            "CreditEvent" then CreditEvent,
            "Novation" then Novation,
            "Exercise" then OptionExercise,
            "PortfolioRebalancing" then PortfolioRebalancing,
            "ForwardAgainstFixing" then ContractFormation,
            "Trade" then ContractFormation,
            default empty

func MapTerminatingEventToIntent:
    inputs:
        fpmlTerminatingEvent fpml.TerminatingEvent (0..1)
    output:
        intent EventIntentEnum (0..1)

    alias terminatingEventValue: fpmlTerminatingEvent -> value to-string

    set intent:
        terminatingEventValue switch
            "Allocation" then Allocation,
            "Netting" then Compression,
            "PortfolioCompression" then Compression,
            "PortfolioRebalancing" then PortfolioRebalancing,
            default empty

func GetEventDate:
    inputs:
        fpmlAmendment fpml.TradeAmendmentContent (0..1)
        fpmlTermination fpml.TradeNotionalChange (0..1)
        fpmlNovation fpml.TradeNovationContent (0..1)
        fpmlTrade fpml.Trade (0..1)
    output:
        eventDate date (0..1)

    set eventDate:
        if fpmlAmendment -> agreementAndEffectiveDatesModel -> agreementDate exists
        then MapZoneDateTimeToDate(
                    fpmlAmendment -> agreementAndEffectiveDatesModel -> agreementDate
                )
        else if fpmlTermination -> agreementAndEffectiveDatesModel -> agreementDate exists
        then MapZoneDateTimeToDate(
                    fpmlTermination -> agreementAndEffectiveDatesModel -> agreementDate
                )
        else if fpmlTrade -> tradeHeader -> partyTradeInformation -> executionDateTime -> value exists
        then MapZoneDateTimeToDate(
                    fpmlTrade -> tradeHeader -> partyTradeInformation -> executionDateTime -> value
                        filter exists
                        then only-element
                )
        else if fpmlNovation -> novationDatesModel -> novationDate exists
        then MapZoneDateTimeToDate(fpmlNovation -> novationDatesModel -> novationDate)

func GetEffectiveDate:
    inputs:
        fpmlAmendment fpml.TradeAmendmentContent (0..1)
        fpmlTermination fpml.TradeNotionalChange (0..1)
        fpmlNovation fpml.TradeNovationContent (0..1)
    output:
        effectiveDate date (0..1)

    set effectiveDate:
        if fpmlAmendment -> agreementAndEffectiveDatesModel -> effectiveDate exists
        then MapZoneDateTimeToDate(
                    fpmlAmendment -> agreementAndEffectiveDatesModel -> effectiveDate
                )
        else if fpmlTermination -> agreementAndEffectiveDatesModel -> effectiveDate exists
        then MapZoneDateTimeToDate(
                    fpmlTermination -> agreementAndEffectiveDatesModel -> effectiveDate
                )
        else if fpmlNovation -> novationDatesModel -> novationDate exists
        then MapZoneDateTimeToDate(fpmlNovation -> novationDatesModel -> novationDate)

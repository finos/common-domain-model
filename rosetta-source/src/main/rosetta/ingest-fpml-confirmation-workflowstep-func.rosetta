namespace cdm.ingest.fpml.confirmation.workflowstep: <"FpML type mapping functions.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.ingest.fpml.confirmation.common.*
import cdm.ingest.fpml.confirmation.datetime.*
import cdm.ingest.fpml.confirmation.legal.*
import cdm.ingest.fpml.confirmation.other.*
import cdm.ingest.fpml.confirmation.party.*
import cdm.ingest.fpml.confirmation.pricequantity.*
import cdm.ingest.fpml.confirmation.tradestate.*
import cdm.observable.asset.*
import cdm.ingest.fpml.confirmation.pricequantity.*
import cdm.ingest.fpml.confirmation.payment.*

import fpml.consolidated.business.events.* as fpml
import fpml.consolidated.* as fpml
import fpml.consolidated.* as fpml
import fpml.consolidated.accumulator.* as fpml
import fpml.consolidated.asset.* as fpml
import fpml.consolidated.bond.option.* as fpml
import fpml.consolidated.business.events.* as fpml
import fpml.consolidated.business.events.* as fpml
import fpml.consolidated.cd.* as fpml
import fpml.consolidated.clearing.processes.* as fpml
import fpml.consolidated.com.* as fpml
import fpml.consolidated.confirmation.processes.* as fpml
import fpml.consolidated.correlation.swaps.* as fpml
import fpml.consolidated.credit.event.notification.* as fpml
import fpml.consolidated.dividend.swaps.* as fpml
import fpml.consolidated.doc.* as fpml
import fpml.consolidated.eq.shared.* as fpml
import fpml.consolidated.eqd.* as fpml
import fpml.consolidated.fpmlenum.* as fpml
import fpml.consolidated.fpmlenum.* as fpml
import fpml.consolidated.fpmlreturn.swaps.* as fpml
import fpml.consolidated.fpmlstandard.* as fpml
import fpml.consolidated.fx.* as fpml
import fpml.consolidated.fx.accruals.* as fpml
import fpml.consolidated.fx.targets.* as fpml
import fpml.consolidated.generic.* as fpml
import fpml.consolidated.ird.* as fpml
import fpml.consolidated.loan.* as fpml
import fpml.consolidated.main.* as fpml
import fpml.consolidated.mktenv.* as fpml
import fpml.consolidated.msg.* as fpml
import fpml.consolidated.option.shared.* as fpml
import fpml.consolidated.recordkeeping.processes.* as fpml
import fpml.consolidated.reg.fpmlreporting.product.* as fpml
import fpml.consolidated.reg.fpmlreporting.shared.* as fpml
import fpml.consolidated.repo.* as fpml
import fpml.consolidated.riskdef.* as fpml
import fpml.consolidated.sec.lending.* as fpml
import fpml.consolidated.shared.* as fpml
import fpml.consolidated.valuation.* as fpml
import fpml.consolidated.valuation.fpmlreporting.* as fpml
import fpml.consolidated.variance.swaps.* as fpml
import fpml.consolidated.volatility.swaps.* as fpml
import fpml.custom.*
import fpml.custom.*

func MapWorkflowStep:
    inputs:
        messageId fpml.MessageId (0..1)
        messageHeaderModel fpml.MessageHeaderModel (0..1)
        action ActionEnum (0..1)
        fpmlTrade fpml.Trade (0..1)
        fpmlPartiesAndAccountsModel fpml.PartiesAndAccountsModel (0..1)
        intent EventIntentEnum (0..1)
        eventDate date (0..1)
        effectiveDate date (0..1)
        fpmlPostTradeEventsBaseModel fpml.PostTradeEventsBaseModel (0..1)
        tradingEventsBaseModel fpml.TradingEventsBaseModel (0..1)
    output:
        workflowStep WorkflowStep (0..1)

    set workflowStep:
        WorkflowStep {
            proposedEvent:
                EventInstruction {
                    intent: intent,
                    eventDate: eventDate,
                    effectiveDate: effectiveDate,
                    instruction: [
                            Instruction {
                                primitiveInstruction: MapPrimitiveInstruction(
                                            fpmlTrade,
                                            fpmlPostTradeEventsBaseModel,
                                            tradingEventsBaseModel
                                        ),
                                before: MapTradeState(
                                            fpmlTrade,
                                            fpmlPartiesAndAccountsModel
                                        )
                            }
                        ],
                    ...
                },
            timestamp:
                EventTimestamp {
                    dateTime: messageHeaderModel -> creationTimestamp,
                    qualification: MapEventTimestampQualification(
                                messageHeaderModel,
                                fpmlTrade
                    ),
                },
            eventIdentifier:
                Identifier {
                    assignedIdentifier:
                        AssignedIdentifier {
                            identifier: messageId -> value,
                            ...
                        },
                    ...
                },
            messageInformation: MapMessageInformation(messageId, messageHeaderModel),
            action: action,
            ...
        }

func MapPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        fpmlTradeNotionalChange fpml.PostTradeEventsBaseModel (0..1)
        fpmlTradingEventsBaseModel fpml.TradingEventsBaseModel (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    set primitiveInstruction:
        if fpmlTradeNotionalChange -> postTradeEventsBaseModelSequence -> termination exists
        then MapTerminationToPrimitiveInstruction(
                    fpmlTrade,
                    fpmlTradeNotionalChange -> postTradeEventsBaseModelSequence -> termination
                )
        else if fpmlTradeNotionalChange -> amendment exists
        then MapAmendmentToPrimitiveInstruction(
                    fpmlTrade,
                    fpmlTradeNotionalChange -> amendment
                )
        else if fpmlTradingEventsBaseModel exists
        then MapTradeToPrimitiveInstruction(
                    fpmlTradingEventsBaseModel -> tradingEventsBaseModelSequence -> trade
                )
        else if fpmlTrade exists
        then MapTradeToPrimitiveInstruction(fpmlTrade)

func MapTradeToPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    alias counterpartyList: MapCounterpartyList(fpmlTrade)

    set primitiveInstruction:
        PrimitiveInstruction {
            contractFormation:
                ContractFormationInstruction {
                    legalAgreement: MapLegalAgreementList(
                                fpmlTrade -> documentation,
                                counterpartyList
                            )
                },
            ...
        }

func MapAmendmentToPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        amendment fpml.TradeAmendmentContent (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    alias counterpartyList: MapCounterpartyList(fpmlTrade)
    alias payment: amendment -> tradeAlterationPaymentModel -> payment distinct only-element
    alias amendmentPayment:
        MapNonNegativeMoneyToQuantity(
                amendment -> tradeAlterationPaymentModel -> payment distinct only-element -> paymentAmount
            )

    set primitiveInstruction:
        PrimitiveInstruction {
            transfer:
                TransferInstruction {
                    transferState:
                        TransferState {
                            transfer:
                                Transfer {
                                    quantity:
                                        NonNegativeQuantity {
                                            value: amendmentPayment -> value,
                                            unit: amendmentPayment -> unit,
                                            ...
                                        },
                                    asset:
                                        Asset {
                                            Cash:
                                                Cash {
                                                    identifier: amendmentPayment -> unit -> currency
                                                            extract
                                                                AssetIdentifier {
                                                                    identifier: item,
                                                                    identifierType: if exists
                                                                            then CurrencyCode
                                                                },
                                                    ...
                                                },
                                            ...
                                        },
                                    settlementDate: MapAdjustableOrAdjustedDateToAdjustableOrAdjustedOrRelativeDate(
                                                payment -> paymentDate
                                            ),
                                    payerReceiver: payment -> payerReceiverModel
                                            extract
                                                PartyReferencePayerReceiver {
                                                    payerPartyReference: MapPartyReference(
                                                                payerModel -> payerPartyReference -> href
                                                            ),
                                                    receiverPartyReference: MapPartyReference(
                                                                receiverModel -> receiverPartyReference -> href
                                                            ),
                                                    ...
                                                },
                                    transferExpression: payment
                                            extract
                                                TransferExpression {
                                                    priceTransfer: if item -> id exists
                                                            then MapFeeTypeEnum(id)
                                                        else MapFeeTypeEnumWithScheme(
                                                                paymentType -> value to-string,
                                                                paymentType -> paymentTypeScheme
                                                            ),
                                                    ...
                                                },
                                    ...
                                },
                            ...
            },},
            ...
        }

func MapTerminationToPrimitiveInstruction:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        termination fpml.TradeNotionalChange (0..1)
    output:
        primitiveInstruction PrimitiveInstruction (0..1)

    alias counterpartyList: MapCounterpartyList(fpmlTrade)
    alias terminationPayment: termination -> tradeAlterationPaymentModel -> payment

    set primitiveInstruction:
        PrimitiveInstruction {
            contractFormation:
                ContractFormationInstruction {
                    legalAgreement: MapLegalAgreementList(
                                fpmlTrade -> documentation,
                                counterpartyList
                            )
                },
            quantityChange: MapQuantityChange(termination),
            transfer:
                TransferInstruction {
                    transferState: MapPaymentListToTransferStateList(
                                terminationPayment,
                                Termination
                    ),
                },
            ...
        }

func MapQuantityChange:
    inputs:
        fpmlTradeNotionalChange fpml.TradeNotionalChange (0..1)
    output:
        quantityChange QuantityChangeInstruction (0..1)

    set quantityChange:
        QuantityChangeInstruction {
            change: MapPriceQuantity(fpmlTradeNotionalChange),
            direction: if fpmlTradeNotionalChange exists then Replace,
            ...
        }

func MapPriceQuantity:
    inputs:
        fpmlTradeNotionalChange fpml.TradeNotionalChange (0..1)
    output:
        priceQuantityList PriceQuantity (0..*)

    alias outstandingTradeNotional:
        fpmlTradeNotionalChange -> tradeNotionalChangeModel -> tradeNotionalChangeModelSequence0 -> outstandingNotionalAmount
            extract MapNonNegativeMoneyNonNegativeQuantitySchedule

    alias outstandingSizeChange:
        fpmlTradeNotionalChange -> sizeChange -> tradeLegNotionalChangeModel -> outstandingNotionalAmount
            extract MapNonNegativeMoneyNonNegativeQuantitySchedule


    add priceQuantityList:
        PriceQuantity {
            quantity: outstandingTradeNotional
                    extract
                        CreateQuantityWithLocation(item, CreateQuantityKey(empty, empty)),
            ...
        }

    add priceQuantityList:
        PriceQuantity {
            quantity: outstandingSizeChange
                    extract
                        CreateQuantityWithLocation(item, CreateQuantityKey(empty, empty)),
            ...
        }

func MapNonNegativeMoneyNonNegativeQuantitySchedule:
    inputs:
        f fpml.consolidated.shared.NonNegativeMoney (0..1)
    output:
        priceQuantityList NonNegativeQuantitySchedule (0..1)

    set priceQuantityList:
        NonNegativeQuantitySchedule {
            value: f -> amount,
            unit:
                UnitType {
                    currency: f -> currency -> value,
                    ...
                },
            ...
        }

func MapMessageInformation:
    inputs:
        messageId fpml.MessageId (0..1)
        messageHeaderModel fpml.MessageHeaderModel (0..1)
    output:
        messageInfo MessageInformation (0..1)
    set messageInfo:
        MessageInformation {
            messageId: MapStringWithScheme(messageId -> value, messageId -> messageIdScheme),
            sentBy: MapStringWithScheme(
                        messageHeaderModel -> sentBy -> value,
                        messageHeaderModel -> sentBy -> messageAddressScheme
                    ),
            sentTo: [
                    MapStringWithScheme(
                            messageHeaderModel -> sendTo -> value,
                            messageHeaderModel -> sendTo -> messageAddressScheme
                        )
                ],
            ...
        }

func GetIntent:
    inputs:
        fpmlNovation fpml.TradeNovationContent (0..1)
        fpmlAmendment fpml.TradeAmendmentContent (0..1)
        fpmlOriginatingEvent fpml.OriginatingEvent (0..1)
        fpmlTerminatingEvent fpml.TerminatingEvent (0..1)
        fpmlTrade fpml.Trade (0..1)
    output:
        intent EventIntentEnum (0..1)

    alias intentToAllocate:
        (fpmlTrade -> tradeHeader -> partyTradeInformation
            filter intentToAllocate = True
            )
            then exists
    alias intentToClear:
        (fpmlTrade -> tradeHeader -> partyTradeInformation
            filter intentToClear = True
            )
            then exists

    set intent:
        if intentToAllocate
        then Allocation
        else if intentToClear
        then Clearing
        else if fpmlNovation exists
        then Novation
        else if fpmlAmendment exists
        then ContractTermsAmendment
        else if MapOriginatingEventToIntent(fpmlOriginatingEvent) exists
        then MapOriginatingEventToIntent(fpmlOriginatingEvent)
        else if MapTerminatingEventToIntent(fpmlTerminatingEvent) exists
        then MapTerminatingEventToIntent(fpmlTerminatingEvent)
        else if fpmlTrade exists
        then ContractFormation

func MapOriginatingEventToIntent:
    inputs:
        fpmlOriginatingEvent fpml.OriginatingEvent (0..1)
    output:
        intent EventIntentEnum (0..1)

    alias originatingEventValue: fpmlOriginatingEvent -> value to-string

    set intent:
        originatingEventValue switch
            "Allocation" then Allocation,
            "Netting" then Compression,
            "PortfolioCompression" then Compression,
            "CreditEvent" then CreditEvent,
            "Novation" then Novation,
            "Exercise" then OptionExercise,
            "PortfolioRebalancing" then PortfolioRebalancing,
            "ForwardAgainstFixing" then ContractFormation,
            "Trade" then ContractFormation,
            default empty

func MapTerminatingEventToIntent:
    inputs:
        fpmlTerminatingEvent fpml.TerminatingEvent (0..1)
    output:
        intent EventIntentEnum (0..1)

    alias terminatingEventValue: fpmlTerminatingEvent -> value to-string

    set intent:
        terminatingEventValue switch
            "Allocation" then Allocation,
            "Netting" then Compression,
            "PortfolioCompression" then Compression,
            "PortfolioRebalancing" then PortfolioRebalancing,
            default empty

func GetEventDate:
    inputs:
        fpmlAmendment fpml.TradeAmendmentContent (0..1)
        fpmlTermination fpml.TradeNotionalChange (0..1)
        fpmlNovation fpml.TradeNovationContent (0..1)
        fpmlTrade fpml.Trade (0..1)
    output:
        eventDate date (0..1)

    set eventDate:
        if fpmlAmendment -> agreementAndEffectiveDatesModel -> agreementDate exists
        then MapZoneDateTimeToDate(
                    fpmlAmendment -> agreementAndEffectiveDatesModel -> agreementDate
                )
        else if fpmlTermination -> agreementAndEffectiveDatesModel -> agreementDate exists
        then MapZoneDateTimeToDate(
                    fpmlTermination -> agreementAndEffectiveDatesModel -> agreementDate
                )
        else if fpmlTrade -> tradeHeader -> partyTradeInformation -> executionDateTime -> value exists
        then MapZoneDateTimeToDate(
                    fpmlTrade -> tradeHeader -> partyTradeInformation -> executionDateTime -> value
                        filter exists
                        then only-element
                )
        else if fpmlNovation -> novationDatesModel -> novationDate exists
        then MapZoneDateTimeToDate(fpmlNovation -> novationDatesModel -> novationDate)

func GetEffectiveDate:
    inputs:
        fpmlAmendment fpml.TradeAmendmentContent (0..1)
        fpmlTermination fpml.TradeNotionalChange (0..1)
        fpmlNovation fpml.TradeNovationContent (0..1)
    output:
        effectiveDate date (0..1)

    set effectiveDate:
        if fpmlAmendment -> agreementAndEffectiveDatesModel -> effectiveDate exists
        then MapZoneDateTimeToDate(
                    fpmlAmendment -> agreementAndEffectiveDatesModel -> effectiveDate
                )
        else if fpmlTermination -> agreementAndEffectiveDatesModel -> effectiveDate exists
        then MapZoneDateTimeToDate(
                    fpmlTermination -> agreementAndEffectiveDatesModel -> effectiveDate
                )
        else if fpmlNovation -> novationDatesModel -> novationDate exists
        then MapZoneDateTimeToDate(fpmlNovation -> novationDatesModel -> novationDate)

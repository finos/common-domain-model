namespace cdm.event.qualification
version "${project.version}"

import cdm.event.common.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.common.*
import cdm.base.math.*
import cdm.observable.asset.*

isEvent root BusinessEvent;

func Qualify_Allocation: <"The qualification of allocation event from the fact that (i) the only primitives are split and contract formation (ii) the number of split executions and the number of contract formations are equal.  Note that SplitPrimitive type has a condition to check that the post-split quantities sum to the pre-split quantity.  Also note that it is expected that an allocation can result in a single contract.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates( businessEvent -> after )
	alias openTradeStates: FilterOpenTradeStates( businessEvent -> after )
	set is_event:
		businessEvent -> intent = EventIntentEnum -> Allocation
		and closedTradeStates count = 1
		and openTradeStates count >= 1
		and businessEvent -> instruction -> primitiveInstruction -> split exists
		// before trade counterparties should match closed after trade counterparties
		and beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference = closedTradeStates only-element -> trade -> tradableProduct -> counterparty -> partyReference
		// before trade counterparties should not match open after trade counterparties
		and openTradeStates
			extract [ item -> trade -> tradableProduct -> counterparty -> partyReference <> beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference ]
			all = True
        

func Qualify_CashTransfer: <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias transferInstructions: businessEvent -> instruction -> primitiveInstruction -> transfer
	alias beforeTransfers: businessEvent -> instruction -> before -> transferHistory
	alias afterTransfers: businessEvent -> after -> transferHistory
	set is_event:
		businessEvent -> instruction -> primitiveInstruction -> transfer only exists
		and beforeTransfers count + transferInstructions count = afterTransfers count
		and transferInstructions -> transferState -> transfer -> quantity -> unit -> currency exists

func Qualify_CashAndSecurityTransfer: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias transfersForDate: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate )
	set is_event:
		transfersForDate -> quantity -> unit -> currency exists
		and transfersForDate -> quantity -> unit -> financialUnit exists
		and transfersForDate count = 2

        func Qualify_ClearedTrade:
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates( businessEvent -> after )
	alias openTradeStates: FilterOpenTradeStates( businessEvent -> after )
	set is_event:
        businessEvent -> intent = EventIntentEnum -> Clearing
        and closedTradeStates count = 1
        and openTradeStates count = 2
        and businessEvent -> instruction -> primitiveInstruction -> split exists
        and beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference = closedTradeStates only-element -> trade -> tradableProduct -> counterparty -> partyReference
        and openTradeStates
            extract [
                item -> trade -> tradableProduct -> counterparty -> partyReference <> beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference
                and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier
                and item -> trade -> partyRole -> role contains PartyRoleEnum -> ClearingOrganization
            ]
            all = True

func Qualify_OpenOfferClearedTrade:
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias beforeTradeState: businessEvent -> instruction -> before
    alias openTradeStates: FilterOpenTradeStates( businessEvent -> after )
	set is_event:
        businessEvent -> intent = EventIntentEnum -> Clearing
		and businessEvent -> instruction count = 2
        and openTradeStates count = 2
        and (businessEvent -> instruction -> primitiveInstruction -> execution, businessEvent -> instruction -> primitiveInstruction -> contractFormation) only exists
        and openTradeStates
            extract [
                item -> trade -> tradableProduct -> counterparty -> partyReference <> beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference
                and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier
                and item -> trade -> partyRole -> role contains PartyRoleEnum -> ClearingOrganization
            ]
            all = True

func Qualify_Compression: <"The qualification of a compression event from the fact that (i) the quantityChange primitive exists, and (ii) there are multiple contracts (or contract references) specified in the before state.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	set is_event:
		businessEvent -> instruction -> primitiveInstruction -> execution count = 1
        and businessEvent -> instruction -> primitiveInstruction -> quantityChange count > 1

func Qualify_Exercise: <"The qualification of an exercise event from the fact that (i) the only primitive is the exercise, and (ii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
	set is_event:
		businessEvent -> intent = EventIntentEnum -> OptionExercise
		and
		(
            (businessEvent -> instruction count = 1 and
            (businessEvent -> instruction -> primitiveInstruction -> quantityChange exists and businessEvent -> instruction -> primitiveInstruction -> transfer exists))
            or
            (businessEvent -> instruction count = 2 and
            (businessEvent -> instruction -> primitiveInstruction -> quantityChange exists and businessEvent -> instruction -> primitiveInstruction -> execution exists))
            or
            (businessEvent -> instruction count = 1 and
            businessEvent -> instruction -> primitiveInstruction -> exercise exists)
		)

func Qualify_Increase: <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
	alias transfer: TransfersForDate(businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate)
	set is_event:
		businessEvent -> intent is absent
        and
        (
            (primitiveInstruction -> quantityChange only exists
                or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
            and (QuantityIncreased(businessEvent -> instruction -> before only-element, businessEvent -> after) = True
                or businessEvent -> instruction -> before -> trade -> tradableProduct -> tradeLot count < businessEvent -> after -> trade -> tradableProduct -> tradeLot count)
        )

func Qualify_Novation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and a contract formation exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	[qualification BusinessEvent]
	inputs: businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates( businessEvent -> after )
	alias openTradeStates: FilterOpenTradeStates( businessEvent -> after )
	set is_event:
		businessEvent -> intent = EventIntentEnum -> Novation
		and closedTradeStates count = 1
		and openTradeStates count = 1
		and businessEvent -> instruction -> primitiveInstruction -> split exists
		and beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference = closedTradeStates only-element -> trade -> tradableProduct -> counterparty -> partyReference
		and beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference <> openTradeStates only-element -> trade -> tradableProduct -> counterparty -> partyReference
		and beforeTradeState -> trade -> tradeIdentifier <> openTradeStates -> trade -> tradeIdentifier
	

func Qualify_PartialNovation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and contractFormation exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	[qualification BusinessEvent]

	inputs: businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates( businessEvent -> after )
	alias openTradeStates: FilterOpenTradeStates( businessEvent -> after )
	set is_event:
	
		businessEvent -> intent = EventIntentEnum -> Novation
		and closedTradeStates count = 0
		and openTradeStates count = 2
		and businessEvent -> instruction -> primitiveInstruction -> split exists
		and openTradeStates
			extract [
				// before trade counterparties should not match open after trade counterparties, and neither should trade identifiers
				( item -> trade -> tradableProduct -> counterparty -> partyReference <> beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference
					and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier )
				or
				// before trade counterparties match open after trade counterparties, and match trade identifiers, but with decreased quantity
				( item -> trade -> tradableProduct -> counterparty -> partyReference = beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference
					and item -> trade -> tradeIdentifier = beforeTradeState -> trade -> tradeIdentifier
					and QuantityDecreased( beforeTradeState, [ item ] ) )
			]
			all = True
	


func Qualify_PartialTermination: <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
    alias transfers: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate )
	set is_event:
		businessEvent -> intent is absent
		and (primitiveInstruction -> quantityChange only exists
                or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
		and (QuantityDecreased(businessEvent -> instruction -> before only-element, businessEvent -> after) = True)
		and businessEvent -> after -> state -> closedState is absent

func Qualify_Renegotiation: <"The qualification of a renegotiation event from the fact that (i) the intent is Renegotiation when specified, and (ii) the associated primitives instructions are the TermsChange, QuantityChange and the cash transfer.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias transfers: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate )
	set is_event:
		(businessEvent -> intent is absent or businessEvent -> intent = EventIntentEnum -> ContractTermsAmendment)
		and (businessEvent -> instruction -> primitiveInstruction -> termsChange only exists or (businessEvent -> instruction -> primitiveInstruction -> termsChange,businessEvent -> instruction -> primitiveInstruction -> quantityChange) only exists)
		and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = False)
		and businessEvent -> after -> state -> closedState is absent

func Qualify_Reset: <"The qualification of a reset event from the fact that the only primitive is the reset.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeTradeState: businessEvent -> instruction -> before only-element
	alias afterTradeState: businessEvent -> after only-element
    set is_event:
        businessEvent -> after count = 1
        and beforeTradeState -> trade = afterTradeState -> trade
        and beforeTradeState -> resetHistory count + 1 = afterTradeState -> resetHistory count

func Qualify_SecurityTransfer: <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias transfer: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate ) only-element
	set is_event:
		transfer -> observable -> productIdentifier exists
		and transfer -> quantity -> unit -> financialUnit only exists

func Qualify_SecuritySettlement: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias transfers: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate )
	set is_event:
		transfers -> observable -> productIdentifier only exists
		and transfers -> quantity -> unit -> currency only exists
		and FilterCashTransfers( transfers ) only-element -> payerReceiver -> payerPartyReference =
			FilterSecurityTransfers( transfers ) only-element -> payerReceiver -> receiverPartyReference

func Qualify_Termination: <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
    alias transfer: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate ) only-element
	set is_event:
		businessEvent -> intent is absent
        and (primitiveInstruction -> quantityChange only exists
                or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
        and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = True)
		and (businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated)

func Qualify_Execution: <"The qualification of an execution event from the fact that the only component is an execution.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
	set is_event:
		(primitiveInstruction -> execution only exists
			or (primitiveInstruction -> execution, primitiveInstruction -> transfer) only exists)

func Qualify_ContractFormation: <"Qualifies a business event as a contract formation from the fact that the only component is a single Contract Formation Primitive.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
    set is_event:
		(primitiveInstruction -> contractFormation only exists
			or (primitiveInstruction -> execution, primitiveInstruction -> contractFormation) only exists)
			or (primitiveInstruction is absent and businessEvent -> intent = EventIntentEnum -> ContractFormation)
	// and businessEvent -> tradeWarehouseWorkflow is absent

func Qualify_StockSplit: <"The qualification of StockSplit business event based on (i) an unchanged before/after currency amount (ii) the same adjustment ratio applied to the before/after cash price and number of units.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

    alias beforeTradeState:
        businessEvent -> instruction -> before only-element

    alias afterTradeState:
        businessEvent -> after only-element

	alias beforeQuantities:
		beforeTradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> quantity
	
	alias beforeNoOfUnits:
		FilterQuantityByFinancialUnit( beforeQuantities, FinancialUnitEnum -> Share ) only-element -> value
	
	alias afterQuantities:
		afterTradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity
	
	alias afterNoOfUnits:
		FilterQuantityByFinancialUnit( afterQuantities, FinancialUnitEnum -> Share ) only-element -> value

	alias beforeCurrencyAmount:
		FilterQuantityByCurrencyExists( beforeQuantities ) -> value distinct only-element
	
	alias afterCurrencyAmount:
		FilterQuantityByCurrencyExists( afterQuantities ) -> value distinct only-element

	alias beforePrice: <"Only works in the case of a single trade lot and price.">
		beforeTradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> price
		    filter perUnitOf -> financialUnit = FinancialUnitEnum -> Share
		    then extract value
		    then only-element

	alias afterPrice: <"Only works in the case of a single trade lot and price.">
		afterTradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> price
		    filter perUnitOf -> financialUnit = FinancialUnitEnum -> Share
		    then extract value
		    then only-element

	alias currencyAmountUnchanged:
		if beforeCurrencyAmount exists and afterCurrencyAmount exists then
		    beforeCurrencyAmount = afterCurrencyAmount
		else False
	
	alias noOfUnitsChanged:
		if beforeNoOfUnits exists and afterNoOfUnits exists then
		    afterNoOfUnits <> beforeNoOfUnits
		else False
	
	alias cashPriceChanged:
		if beforePrice exists and afterPrice exists then
		    beforePrice <> afterPrice
		else False
	
	alias adjustmentRatioMatches:
		if beforeNoOfUnits exists and beforeNoOfUnits > 0 and afterNoOfUnits exists
                and beforePrice exists and afterPrice exists and afterPrice > 0 then
		    afterNoOfUnits / beforeNoOfUnits = beforePrice / afterPrice
		else False
	
	set is_event:
		currencyAmountUnchanged = True
		and noOfUnitsChanged = True
		and cashPriceChanged = True 
		and adjustmentRatioMatches = True

func Qualify_IndexTransition: <"The qualification of an index transition event based on (i) adjustment spread applied and (ii) floating rate index changed.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output:
		is_event boolean (1..1)

	alias after:
		businessEvent -> after only-element -> trade -> tradableProduct

	alias before:
		businessEvent -> instruction -> before -> trade -> tradableProduct

	alias floatingRateIndexChanged:
	    before -> tradeLot -> priceQuantity -> observable -> rateOption -> floatingRateIndex exists
	    and before -> tradeLot -> priceQuantity -> observable -> rateOption -> floatingRateIndex disjoint after -> tradeLot -> priceQuantity -> observable -> rateOption -> floatingRateIndex

	alias spread:
		FilterPrice(
            after -> tradeLot -> priceQuantity -> price,
            PriceTypeEnum -> InterestRate,
            [ ArithmeticOperationEnum -> Add, ArithmeticOperationEnum -> Subtract ]
            /*, empty, empty, empty, empty, empty, SpreadTypeEnum -> Spread*/
            )

	alias adjustmentSpreadAdded:
		if spread exists
		then spread -> value <> 0
		else True

	set is_event:
		businessEvent -> intent = EventIntentEnum -> IndexTransition
		and floatingRateIndexChanged = True
		and adjustmentSpreadAdded = True

func Qualify_FullReturn: <"The qualification of a full return event from the fact that (i) a quantityChange primitive and a transfer primitive exists, (ii) an assetPayout exists, (iii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	alias transfer: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate ) only-element
	set is_event:
		(businessEvent -> intent is absent)
		and businessEvent -> after -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> assetPayout exists
		and (businessEvent -> instruction count = 1
			and businessEvent -> instruction -> primitiveInstruction -> quantityChange exists
			or (businessEvent -> instruction -> primitiveInstruction -> quantityChange exists and transfer exists))
		and QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = True
		and businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated

func Qualify_Reallocation: <"The qualification of a reallocation event from the fact that (i) a quantity change primitive exists, (ii) a split primitive exists, and (iii) the intent is Reallocation.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates( businessEvent -> after )
    alias openTradeStates: FilterOpenTradeStates( businessEvent -> after )
	set is_event:
        businessEvent -> intent = EventIntentEnum -> Reallocation
        and closedTradeStates count = 0
        and openTradeStates count = 2
        and businessEvent -> instruction -> primitiveInstruction -> split exists
        and openTradeStates
            extract [
                // before trade counterparties should not match open after trade counterparties, and neither should trade identifiers
                ( item -> trade -> tradableProduct -> counterparty -> partyReference <> beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference
                    and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier )
                or
                // before trade counterparties match open after trade counterparties, and match trade identifiers, but with decreased quantity
                ( item -> trade -> tradableProduct -> counterparty -> partyReference = beforeTradeState -> trade -> tradableProduct -> counterparty -> partyReference
                    and item -> trade -> tradeIdentifier = beforeTradeState -> trade -> tradeIdentifier
                    and QuantityDecreased( beforeTradeState, [ item ] ) )
            ]
            all = True

func Qualify_CreditEventDetermined: <"The qualification of the ocurrence of a credit event determination from the fact that a credit event is present in either the observation or observation history structures.">
	[qualification BusinessEvent]
	inputs: businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	set is_event:
		businessEvent -> instruction -> primitiveInstruction -> observation -> observationEvent -> creditEvent exists
		or
		businessEvent -> instruction -> before -> observationHistory -> creditEvent exists
		or
		businessEvent -> after -> observationHistory -> creditEvent exists

func Qualify_CorporateActionDetermined: <"The qualification of the ocurrence of a corporate action form the fact that a corporate action is present in either the observation or the observation history structures.">
	[qualification BusinessEvent]
	inputs: businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	set is_event:
		businessEvent -> instruction -> primitiveInstruction -> observation -> observationEvent -> corporateAction exists
		or
		businessEvent -> instruction -> before -> observationHistory -> corporateAction exists
		or
		businessEvent -> after -> observationHistory -> corporateAction exists

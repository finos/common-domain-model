namespace cdm.ingest.fpml.confirmation.legal
version "${project.version}"

import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.master.*
import cdm.product.collateral.*

import fpml.confirmation.* as fpml

import cdm.ingest.fpml.confirmation.other.*

func MapContractDetails:
    inputs:
        fpmlTrade fpml.Trade (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        contractDetails ContractDetails (0..1)

    set contractDetails:
        ContractDetails {
            documentation: MapLegalAgreementList(
                    fpmlTrade -> documentation,
                    cdmCounterpartyList
                ),
            governingLaw: MapGoverningLaw(fpmlTrade -> governingLaw)
        }

func MapLegalAgreementList:
    inputs:
        fpmlDocumentation fpml.Documentation (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        legalAgreementList LegalAgreement (0..*)

    add legalAgreementList:
        if fpmlDocumentation -> masterAgreement exists
        then MapMasterAgreement(fpmlDocumentation -> masterAgreement, cdmCounterpartyList)
    add legalAgreementList:
        if fpmlDocumentation -> masterConfirmation exists
        then MapMasterConfirmation(
                    fpmlDocumentation -> masterConfirmation,
                    cdmCounterpartyList
                )
    add legalAgreementList:
        if fpmlDocumentation -> creditSupportAgreement exists
        then MapCreditSupportAgreement(
                    fpmlDocumentation -> creditSupportAgreement,
                    cdmCounterpartyList
                )
    add legalAgreementList:
        if fpmlDocumentation -> contractualDefinitions exists
                or fpmlDocumentation -> contractualMatrix exists
                or fpmlDocumentation -> contractualTermsSupplement exists
        then MapConfirmationLegalAgreement(fpmlDocumentation, cdmCounterpartyList)
    add legalAgreementList:
        if fpmlDocumentation -> otherAgreement exists
        then fpmlDocumentation -> otherAgreement
            extract MapOtherAgreements(item, cdmCounterpartyList)

func MapMasterAgreement:
    inputs:
        fpmlMasterAgreement fpml.MasterAgreement (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        legalAgreement LegalAgreement (0..1)

    alias cdmAgreementName:
        AgreementName {
            masterAgreementType: MapMasterAgreementTypeEnumWithScheme(
                    fpmlMasterAgreement -> masterAgreementType
                ),
            agreementType: MasterAgreement,
            ...
        }

    set legalAgreement:
        MapLegalAgreement(
                fpmlMasterAgreement -> masterAgreementDate -> date,
                cdmCounterpartyList,
                cdmAgreementName,
                fpmlMasterAgreement -> masterAgreementVersion -> value to-int
            )

func MapMasterAgreementTypeEnumWithScheme:
    inputs:
        fpmlMasterAgreementType fpml.MasterAgreementType (0..1)
    output:
        masterAgreementTypeEnum MasterAgreementTypeEnum (0..1)
            [metadata scheme]

    set masterAgreementTypeEnum:
        MapMasterAgreementTypeEnum(fpmlMasterAgreementType -> value)
    set masterAgreementTypeEnum -> scheme:
        fpmlMasterAgreementType -> masterAgreementTypeScheme

func MapMasterConfirmation:
    inputs:
        fpmlMasterConfirmation fpml.MasterConfirmation (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        legalAgreement LegalAgreement (0..1)

    alias cdmAgreementName:
        AgreementName {
            masterConfirmationType: MapMasterConfirmationTypeEnumWithScheme(
                    fpmlMasterConfirmation -> masterConfirmationType
                ),
            masterConfirmationAnnexType: MapMasterConfirmationAnnexTypeEnumWithScheme(
                    fpmlMasterConfirmation -> masterConfirmationAnnexType
                ),
            agreementType: MasterConfirmation,
            ...
        }

    set legalAgreement:
        MapLegalAgreement(
                fpmlMasterConfirmation -> masterConfirmationDate -> date,
                cdmCounterpartyList,
                cdmAgreementName,
                empty
            )

func MapMasterConfirmationTypeEnumWithScheme:
    inputs:
        fpmlMasterConfirmationType fpml.MasterConfirmationType (0..1)
    output:
        masterConfirmationTypeEnum MasterConfirmationTypeEnum (0..1)
            [metadata scheme]

    set masterConfirmationTypeEnum:
        MapMasterConfirmationTypeEnum(fpmlMasterConfirmationType -> value)
    set masterConfirmationTypeEnum -> scheme:
        fpmlMasterConfirmationType -> masterConfirmationTypeScheme

func MapMasterConfirmationAnnexTypeEnumWithScheme:
    inputs:
        fpmlMasterConfirmationAnnexType fpml.MasterConfirmationAnnexType (0..1)
    output:
        masterConfirmationAnnexType MasterConfirmationAnnexTypeEnum (0..1)
            [metadata scheme]

    set masterConfirmationAnnexType:
        MapMasterConfirmationAnnexTypeEnum(fpmlMasterConfirmationAnnexType -> value)
    set masterConfirmationAnnexType -> scheme:
        fpmlMasterConfirmationAnnexType -> masterConfirmationAnnexTypeScheme

func MapCreditSupportAgreement:
    inputs:
        fpmlCreditSupportAgreement fpml.CreditSupportAgreement (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        legalAgreement LegalAgreement (0..1)

    alias cdmAgreementName:
        AgreementName {
            creditSupportAgreementType: MapCreditSupportAgreementTypeEnumWithScheme(
                    fpmlCreditSupportAgreement -> ^type
                ),
            agreementType: CreditSupportAgreement,
            ...
        }

    set legalAgreement:
        MapLegalAgreement(
                fpmlCreditSupportAgreement -> date -> date,
                cdmCounterpartyList,
                cdmAgreementName,
                empty
            )

func MapCreditSupportAgreementTypeEnumWithScheme:
    inputs:
        fpmlCreditSupportAgreementType fpml.CreditSupportAgreementType (0..1)
    output:
        creditSupportAgreementTypeEnum CreditSupportAgreementTypeEnum (0..1)
            [metadata scheme]

    set creditSupportAgreementTypeEnum:
        MapCreditSupportAgreementTypeEnum(fpmlCreditSupportAgreementType -> value)
    set creditSupportAgreementTypeEnum -> scheme:
        fpmlCreditSupportAgreementType -> creditSupportAgreementTypeScheme

func MapConfirmationLegalAgreement:
    inputs:
        fpmlDocumentation fpml.Documentation (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        legalAgreement LegalAgreement (0..1)

    alias cdmAgreementName:
        AgreementName {
            contractualDefinitionsType: fpmlDocumentation -> contractualDefinitions
                extract MapContractualDefinitionsEnumWithScheme,
            contractualMatrix: fpmlDocumentation -> contractualMatrix
                extract
                    ContractualMatrix {
                        matrixType: MapMatrixTypeEnumWithScheme(matrixType),
                        matrixTerm: MapMatrixTermEnumWithScheme(matrixTerm)
                    },
            contractualTermsSupplement: fpmlDocumentation -> contractualTermsSupplement
                extract
                    ContractualTermsSupplement {
                        contractualTermsSupplementType: MapContractualSupplementTypeEnumWithScheme(
                                ^type
                            ),
                        publicationDate: publicationDate -> date
                    },
            agreementType: Confirmation,
            ...
        }

    set legalAgreement:
        MapLegalAgreement(empty, cdmCounterpartyList, cdmAgreementName, empty)

func MapContractualDefinitionsEnumWithScheme:
    inputs:
        fpmlContractualDefinitions fpml.ContractualDefinitions (0..1)
    output:
        contractualDefinitionsEnum ContractualDefinitionsEnum (0..1)
            [metadata scheme]

    set contractualDefinitionsEnum:
        MapContractualDefinitionsEnum(fpmlContractualDefinitions -> value)
    set contractualDefinitionsEnum -> scheme:
        fpmlContractualDefinitions -> contractualDefinitionsScheme

func MapMatrixTypeEnumWithScheme:
    inputs:
        fpmlMatrixType fpml.MatrixType (0..1)
    output:
        matrixTypeEnum MatrixTypeEnum (0..1)
            [metadata scheme]

    set matrixTypeEnum: MapMatrixTypeEnum(fpmlMatrixType -> value)
    set matrixTypeEnum -> scheme: fpmlMatrixType -> matrixTypeScheme

func MapMatrixTermEnumWithScheme:
    inputs:
        fpmlMatrixTerm fpml.MatrixTerm (0..1)
    output:
        matrixTermEnum MatrixTermEnum (0..1)
            [metadata scheme]

    set matrixTermEnum: MapMatrixTermEnum(fpmlMatrixTerm -> value)
    set matrixTermEnum -> scheme: fpmlMatrixTerm -> matrixTermScheme

func MapContractualSupplementTypeEnumWithScheme:
    inputs:
        fpmlContractualSupplement fpml.ContractualSupplement (0..1)
    output:
        contractualSupplementTypeEnum ContractualSupplementTypeEnum (0..1)
            [metadata scheme]

    set contractualSupplementTypeEnum:
        MapContractualSupplementTypeEnum(fpmlContractualSupplement -> value)
    set contractualSupplementTypeEnum -> scheme:
        fpmlContractualSupplement -> contractualSupplementScheme

func MapOtherAgreements:
    inputs:
        fpmlOtherAgreement fpml.OtherAgreement (0..1)
        cdmCounterpartyList Counterparty (0..2)
    output:
        legalAgreement LegalAgreement (0..1)

    alias agreementName:
        AgreementName {
            otherAgreement: fpmlOtherAgreement -> ^type -> value,
            agreementType: Other,
            ...
        }
    alias vintage: fpmlOtherAgreement -> version -> value to-int

    set legalAgreement:
        MapLegalAgreement(
                fpmlOtherAgreement -> date -> date,
                cdmCounterpartyList,
                agreementName,
                vintage
            )

func MapLegalAgreement:
    inputs:
        fpmlAgreementDate date (0..1)
        cdmCounterpartyList Counterparty (0..2)
        cdmAgreementName AgreementName (0..1)
        cdmVintage int (0..1)
    output:
        legalAgreement LegalAgreement (0..1)

    set legalAgreement:
        LegalAgreement {
            agreementDate: fpmlAgreementDate,
            contractualParty: MapContractualParty(cdmCounterpartyList),
            legalAgreementIdentification: LegalAgreementIdentification {
                governingLaw: empty,
                agreementName: cdmAgreementName,
                publisher: empty,
                vintage: cdmVintage,
            },
            ...
        }

func MapContractualParty:
    inputs:
        cdmCounterpartyList Counterparty (0..2)
    output:
        contractualPartyList Party (0..2)
            [metadata reference]

    add contractualPartyList: cdmCounterpartyList -> partyReference

func MapGoverningLaw:
    inputs:
        fpmlGoverningLaw fpml.GoverningLaw (0..1)
    output:
        governingLawEnum GoverningLawEnum (0..1)
            [metadata scheme]

    set governingLawEnum: fpmlGoverningLaw -> value to-enum GoverningLawEnum
/*
 * func MapAgreementTerms:
 *     inputs:
 *         fpmlTrade fpml.Trade (0..1)
 *         fpmlPartiesAndAccountsModel fpml.PartiesAndAccountsModel (0..1)
 *     output:
 *         agreementTerms AgreementTerms (0..1)
 *     set agreementTerms:
 *         AgreementTerms {
 *             agreement: MapAgreement(fpmlTrade, fpmlPartiesAndAccountsModel),
 *             clauseLibrary: empty,
 *             counterparty: MapCounterpartyList(fpmlTrade),
 *         }

 * func MapUmbrellaAgreement:
 *     inputs:
 *         fpmlTrade fpml.Trade (0..1)
 *         fpmlPartiesAndAccountsModel fpml.PartiesAndAccountsModel (0..1)
 *     output:
 *         umbrellaAgreement UmbrellaAgreement (0..1)
 *     set umbrellaAgreement:
 *         UmbrellaAgreement {
 *             isApplicable: empty,
 *             language: empty,
 *             parties: MapUmbrellaAgreementEntityList(fpmlTrade, fpmlPartiesAndAccountsModel),
 *         }
 */

namespace cdm.product.common.settlement : <"Common product settlement concepts: cash vs physical, non-deliverable, money and cashflow, delivery vs payment.">
version "${project.version}"

import cdm.base.math.*
import cdm.observable.asset.*

func UpdateAmountForEachQuantity: <"Updates all quantities on each price quantity with the new amount.">
    [codeImplementation]
    inputs:
        priceQuantity PriceQuantity (0..*) <"List of price quantities to update.">
        amount number (1..1) <"The new amount.">
    output:
        updatedPriceQuantity PriceQuantity (0..*) <"List of price quantities with all quantity amounts updated.">

func UpdateAmountForEachMatchingQuantity: <"Updates any price or quantity from the list of PriceQuantity if the unit of amount matches.">
    inputs:
        priceQuantity PriceQuantity (1..*) <"List of PriceQuantity to update.">
        change PriceQuantity (1..*) <"List of new PriceQuantity to use where the units match.">
        direction QuantityChangeDirectionEnum (1..1) <"Enum specifying how the updated amounts should be applied, e.g., add, subtract or replace.">
    output:
        updatedPriceQuantity PriceQuantity (1..*) <"List of PriceQuantity with the price and quantity amounts updated.">

    add updatedPriceQuantity: <"For each PriceQuantity, update the price and quantity amounts.">
        priceQuantity
            extract
                UpdatePriceQuantityAmountForEachMatchingQuantity(item, change, direction)

func UpdatePriceQuantityAmountForEachMatchingQuantity: <"Updates any price or quantity from the PriceQuantity if the unit of amount matches.">
    inputs:
        priceQuantity PriceQuantity (0..1) <"List of PriceQuantity to update.">
        change PriceQuantity (0..*) <"List of new PriceQuantity to use where the units match.">
        direction QuantityChangeDirectionEnum (1..1) <"Enum specifying how the updated amounts should be applied, e.g., add, subtract or replace.">
    output:
        updatedPriceQuantity PriceQuantity (0..1)
            [metadata location]

    alias filteredChange: <"Find the match change PriceQuantity.">
        FilterChangePriceQuantity(priceQuantity, change)
        
    set updatedPriceQuantity: <"Update the price and quantity with the change amounts.">
        PriceQuantity {
            price: priceQuantity -> price
                extract
                    UpdatePriceAmountForEachMatchingQuantity(
                            item,
                            filteredChange -> price,
                            direction
                        ),
            quantity: priceQuantity -> quantity
                extract
                    UpdateQuantityAmountForEachMatchingQuantity(
                            item,
                            filteredChange -> quantity,
                            direction
                        ),
            observable: priceQuantity -> observable,
            effectiveDate: priceQuantity -> effectiveDate
        }

func FilterChangePriceQuantity: <"Filter the change PriceQuantity list to match on Observable if present.">
    inputs:
        priceQuantity PriceQuantity (0..1) <"List of PriceQuantity to update.">
        change PriceQuantity (0..*) <"List of new PriceQuantity to use where the units match.">
    output:
        filteredChange PriceQuantity (0..*)

    //alias changeWithMatchingObservable: // TODO uncomment to support matching on PriceQuantity observable
        //  change
        //     filter
        //         // match on observable is absent
        //         (item -> observable is absent and priceQuantity -> observable is absent) 
        //         // or, match on observable
        //         or item -> observable = priceQuantity -> observable

    add filteredChange:
        //changeWithMatchingObservable default change
        change

func UpdatePriceAmountForEachMatchingQuantity: <"Updates any price from the PriceSchedule list if the unit of amount matches.">
    inputs:
        price PriceSchedule (0..1) <"List of PriceSchedule to update.">
            [metadata location]
        change PriceSchedule (0..*) <"List of new PriceSchedule to use where the units match.">
        direction QuantityChangeDirectionEnum (1..1) <"Enum specifying how the updated amounts should be applied, e.g., add, subtract or replace.">
    output:
        updatedPrice PriceSchedule (0..1)
            [metadata location]

    alias changedAmount:
        change
            filter PriceUnitEquals(item, price)
            then first
            then extract UpdateAmount(price -> value, value, direction)

    set updatedPrice: price
    set updatedPrice -> value: changedAmount default price -> value

func UpdateQuantityAmountForEachMatchingQuantity: <"Updates any quantity from the NonNegativeQuantitySchedule list if the unit of amount matches.">
    inputs:
        quantity NonNegativeQuantitySchedule (0..1) <"List of NonNegativeQuantitySchedule to update.">
            [metadata location]
        change NonNegativeQuantitySchedule (0..*) <"List of new NonNegativeQuantitySchedule to use where the units match.">
        direction QuantityChangeDirectionEnum (1..1) <"Enum specifying how the updated amounts should be applied, e.g., add, subtract or replace.">
    output:
        updatedQuantity NonNegativeQuantitySchedule (0..1)
            [metadata location]

    alias changedAmount:
        change
            filter UnitEquals(item -> unit, quantity -> unit)
            then first
            then extract UpdateAmount(quantity -> value, value, direction)

    set updatedQuantity: quantity
    set updatedQuantity -> value: changedAmount default quantity -> value

func UpdateAmount: <"Updates an amount based on the given QuantityChangeDirectionEnum.  If the direction is Increase, the old amount and change amount are summed, if the direction is Decrease, then the change amount is subtracted from the old amount, and if the direction is Replace then the change amount replaces the old amount.">
    inputs:
        oldAmount number (0..1)
        changeAmount number (0..1)
        direction QuantityChangeDirectionEnum (1..1)
    output:
        newAmount number (0..1)

    set newAmount:
        direction switch
        Increase then oldAmount + changeAmount,
        Decrease then oldAmount - changeAmount,
        Replace then changeAmount

func PriceUnitEquals: <"Compares two PriceSchedule to check if all attributes match, except for the amount.">
    inputs:
        p1 PriceSchedule (0..1)
        p2 PriceSchedule (0..1)
    output:
        result boolean (1..1)

    alias unitMatches: UnitEquals(p1 -> unit, p2 -> unit)
    alias perUnitOfMatches: UnitEquals(p1 -> perUnitOf, p2 -> perUnitOf)
    alias priceTypeMatches:
        (p1 -> priceType is absent and p2 -> priceType is absent)
            or p1 -> priceType = p2 -> priceType
    alias priceExpressionMatches:
        (p1 -> priceExpression is absent and p2 -> priceExpression is absent)
            or p1 -> priceExpression = p2 -> priceExpression
    alias arithmeticOperatorMatches:
        (p1 -> arithmeticOperator is absent and p2 -> arithmeticOperator is absent)
            or p1 -> arithmeticOperator = p2 -> arithmeticOperator

    set result:
        unitMatches and perUnitOfMatches and priceTypeMatches and priceExpressionMatches and arithmeticOperatorMatches

func UnitEquals: <"Compares two UnitType to check if all attributes match.">
    inputs:
        u1 UnitType (0..1)
        u2 UnitType (0..1)
    output:
        result boolean (1..1)

    set result:
        if u1 -> currency exists
        then StringEquals(u1 -> currency, u2 -> currency) // ignore scheme when comparing
        else u1 = u2

func StringEquals:
    inputs:
        s1 string (0..1)
        s2 string (0..1)
    output:
        result boolean (1..1)

    set result: s1 = s2

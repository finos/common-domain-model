namespace cdm.ingest.fpml.confirmation.datetime
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.codelist.*
import cdm.event.workflow.*
import cdm.ingest.fpml.confirmation.other.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*

import fpml.consolidated.* as fpml
import fpml.consolidated.asset.* as fpml
import fpml.consolidated.cd.* as fpml
import fpml.consolidated.com.* as fpml
import fpml.consolidated.doc.* as fpml
import fpml.consolidated.eq.shared.* as fpml
import fpml.consolidated.fpmlenum.* as fpml
import fpml.consolidated.ird.* as fpml
import fpml.consolidated.msg.* as fpml
import fpml.consolidated.shared.* as fpml

func MapAdjustableOrAdjustedDateToAdjustableOrAdjustedOrRelativeDate:
    inputs:
        fpmlAdjustableOrAdjustedDate fpml.AdjustableOrAdjustedDate (0..1)
    output:
        adjustableOrAdjustedOrRelativeDate AdjustableOrAdjustedOrRelativeDate (0..1)

    set adjustableOrAdjustedOrRelativeDate:
        AdjustableOrAdjustedOrRelativeDate {
            unadjustedDate: fpmlAdjustableOrAdjustedDate -> adjustableDateModel -> unadjustedDate -> value -> date,
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlAdjustableOrAdjustedDate -> adjustableDateModel -> dateAdjustments
                    ),
            adjustedDate: fpmlAdjustableOrAdjustedDate -> adjustedDate -> value -> date,
            relativeDate: empty
        }

func MapAdjustableOrAdjustedOrRelativeDate:
    inputs:
        fpmlUnadjustedDate date (0..1)
        fpmlAdjustableDate fpml.AdjustableDate (0..1)
        fpmlRelativeDate fpml.RelativeDateOffset (0..1)
    output:
        adjustableOrAdjustedOrRelativeDate AdjustableOrAdjustedOrRelativeDate (0..1)

    set adjustableOrAdjustedOrRelativeDate:
        AdjustableOrAdjustedOrRelativeDate {
            unadjustedDate: fpmlUnadjustedDate,
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlAdjustableDate -> dateAdjustments
                    ),
            adjustedDate: fpmlAdjustableDate -> adjustedDate -> value -> date,
            relativeDate: MapRelativeDateOffset(fpmlRelativeDate)
        }

func MapAdjustableOrRelativeDate:
    inputs:
        fpmlAdjustableOrRelativeDate fpml.AdjustableOrRelativeDate (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapAdjustableDate(
                        fpmlAdjustableOrRelativeDate -> adjustableDate
                    ),
            relativeDate: MapRelativeDateOffsetToAdjustedRelativeDateOffset(
                        fpmlAdjustableOrRelativeDate -> relativeDate
                    )
        }
    set adjustableOrRelativeDate -> key: fpmlAdjustableOrRelativeDate -> id

func MapAdjustedDateToAdjustableOrRelativeDate:
    inputs:
        adjustedDate date (0..1)
        id string (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapAdjustedDateToAdjustableDate(adjustedDate),
            ...
        }
    set adjustableOrRelativeDate -> key: id

func MapAdjustedDateToAdjustableDate:
    inputs:
        adjustedDate date (0..1)
    output:
        adjustableDate AdjustableDate (0..1)

    set adjustableDate:
        AdjustableDate {
            adjustedDate: adjustedDate,
            ...
        }

func MapAdjustableDate2ToAdjustableDate:
    inputs:
        fpmlAdjustableDate2 fpml.AdjustableDate2 (0..1)
    output:
        adjustableDate AdjustableDate (0..1)

    set adjustableDate:
        AdjustableDate {
            unadjustedDate: fpmlAdjustableDate2 -> unadjustedDate -> value -> date,
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlAdjustableDate2 -> dateAdjustments
                    ),
            dateAdjustmentsReference: MapBusinessDayAdjustmentsReference(
                        fpmlAdjustableDate2 -> dateAdjustmentsReference
                    ),
            adjustedDate: MapDateWithId(fpmlAdjustableDate2 -> adjustedDate),
        }

func MapAdjustableDate2ToAdjustableOrRelativeDate:
    inputs:
        fpmlAdjustableDate2 fpml.AdjustableDate2 (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapAdjustableDate2ToAdjustableDate(fpmlAdjustableDate2),
            ...
        }

func MapUnadjustedDateToAdjustableOrRelativeDate:
    inputs:
        unadjustedDate date (0..1)
        id string (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapUnadjustedDateToAdjustableDate(unadjustedDate),
            ...
        }
    set adjustableOrRelativeDate -> key: id

func MapUnadjustedDateToAdjustableDate:
    inputs:
        unadjustedDate date (0..1)
    output:
        adjustableDate AdjustableDate (0..1)

    set adjustableDate:
        AdjustableDate {
            unadjustedDate: unadjustedDate,
            ...
        }

func MapAdjustableDateOrAdjustedRelativeDate:
    inputs:
        fpmlAdjustableDate fpml.AdjustableDate (0..1)
        fpmlRelativeDate fpml.AdjustedRelativeDateOffset (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapAdjustableDate(fpmlAdjustableDate),
            relativeDate: MapAdjustedRelativeDateOffset(fpmlRelativeDate),
        }

func MapAdjustedRelativeDateReference:
    inputs:
        fpmlDateReference fpml.DateReference (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)
            [metadata reference]

    set adjustableOrRelativeDate:
        empty with-meta {
            reference: fpmlDateReference -> href
        }

func MapAdjustableDateOrRelativeDateSequenceToAdjustableOrAdjustedRelativeDate:
    inputs:
        fpmlAdjustableDate fpml.AdjustableDate (0..1)
        fpmlRelativeDateSequence fpml.RelativeDateSequence (0..1)
        fpmlId string (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapAdjustableDate(fpmlAdjustableDate),
            relativeDate: MapRelativeDateSequenceToAdjustedRelativeDateOffset(
                        fpmlRelativeDateSequence
            ),
        } with-meta {
            key: fpmlId
        }

func MapAdjustableDate:
    inputs:
        fpmlAdjustableDate fpml.AdjustableDate (0..1)
    output:
        adjustableDate AdjustableDate (0..1)
    set adjustableDate:
        AdjustableDate {
            unadjustedDate: fpmlAdjustableDate -> unadjustedDate -> value -> date,
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlAdjustableDate -> dateAdjustments
                    ),
            adjustedDate: fpmlAdjustableDate -> adjustedDate -> value -> date,
            ...
        }

func MapZoneDateTimeToDate:
    inputs:
        fpmlZoneDateTime zonedDateTime (0..1)
    output:
        date date (0..1)
    set date: fpmlZoneDateTime -> date

func MapAdjustableOrRelativeDates:
    inputs:
        fpmlAdjustableOrRelativeDates fpml.AdjustableOrRelativeDates (1..1)
    output:
        adjustableOrRelativeDates AdjustableOrRelativeDates (0..1)

    set adjustableOrRelativeDates:
        AdjustableOrRelativeDates {
            adjustableDates: fpmlAdjustableOrRelativeDates -> adjustableDates
                    then AdjustableDates {
                            unadjustedDate: unadjustedDate then item -> value -> date,
                            dateAdjustments: MapBusinessDayAdjustments(dateAdjustments),
                            ...
                        },
            relativeDates: MapRelativeDates(fpmlAdjustableOrRelativeDates -> relativeDates)
        }

func MapAdjustable2:
    inputs:
        fpmlAdjustableDate2 fpml.AdjustableDate2 (0..1)
    output:
        adjustableDate AdjustableDate (0..1)

    set adjustableDate:
        AdjustableDate {
            unadjustedDate: fpmlAdjustableDate2 -> unadjustedDate -> value -> date,
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlAdjustableDate2 -> dateAdjustments
                    ),
            adjustedDate: fpmlAdjustableDate2 -> adjustedDate -> value -> date,
            ...
        }

func MapAdjustableRelativeOrPeriodicDates:
    inputs:
        fpmlAdjustableRelativeOrPeriodicDates fpml.AdjustableRelativeOrPeriodicDates (0..1)
    output:
        adjustableRelativeOrPeriodicDates AdjustableRelativeOrPeriodicDates (0..1)

    set adjustableRelativeOrPeriodicDates:
        AdjustableRelativeOrPeriodicDates {
            adjustableDates: MapAdjustableDates(
                        fpmlAdjustableRelativeOrPeriodicDates -> adjustableDates
                    ),
            relativeDates: MapRelativeDateSequenceToRelativeDates(
                        fpmlAdjustableRelativeOrPeriodicDates -> relativeDateSequence
                    ),
            periodicDates: MapPeriodicDates(
                        fpmlAdjustableRelativeOrPeriodicDates -> periodicDates
            ),
        } with-meta {
            key: fpmlAdjustableRelativeOrPeriodicDates -> id
        }

func MapAdjustableRelativeOrPeriodicDates2:
    inputs:
        fpmlAdjustableRelativeOrPeriodicDates2 fpml.AdjustableRelativeOrPeriodicDates2 (0..1)
    output:
        adjustableRelativeOrPeriodicDates AdjustableRelativeOrPeriodicDates (0..1)

    set adjustableRelativeOrPeriodicDates:
        AdjustableRelativeOrPeriodicDates {
            adjustableDates: MapAdjustableDates(
                        fpmlAdjustableRelativeOrPeriodicDates2 -> adjustableDates
                    ),
            relativeDates: MapRelativeDates(
                        fpmlAdjustableRelativeOrPeriodicDates2 -> relativeDates
                    ),
            periodicDates: MapPeriodicDates(
                        fpmlAdjustableRelativeOrPeriodicDates2 -> periodicDates
                    )
        } with-meta {
            key: fpmlAdjustableRelativeOrPeriodicDates2 -> id
        }

func MapAdjustableOrRelativeDatesToAdjustableRelativeOrPeriodicDates:
    inputs:
        fpmlAdjustableOrRelativeDates fpml.AdjustableOrRelativeDates (0..1)
    output:
        adjustableRelativeOrPeriodicDates AdjustableRelativeOrPeriodicDates (0..1)

    set adjustableRelativeOrPeriodicDates:
        AdjustableRelativeOrPeriodicDates {
            adjustableDates: MapAdjustableDates(
                        fpmlAdjustableOrRelativeDates -> adjustableDates
                    ),
            relativeDates: MapRelativeDates(fpmlAdjustableOrRelativeDates -> relativeDates),
            ...
        } with-meta {
            key: fpmlAdjustableOrRelativeDates -> id
        }

func MapAdjustableDates:
    inputs:
        fpmlAdjustableDates fpml.AdjustableDates (0..1)
    output:
        adjustableDates AdjustableDates (0..1)

    set adjustableDates:
        AdjustableDates {
            unadjustedDate: fpmlAdjustableDates -> unadjustedDate -> value -> date,
            dateAdjustments: MapBusinessDayAdjustments(
                        fpmlAdjustableDates -> dateAdjustments
                    ),
            adjustedDate: fpmlAdjustableDates -> adjustedDate extract MapDateWithId
        }

func MapDateWithId:
    inputs:
        fpmlIdentifiedDate fpml.IdentifiedDate (0..1)
    output:
        date date (0..1)
            [metadata id]

    set date:
        fpmlIdentifiedDate -> value -> date with-meta {
            id: fpmlIdentifiedDate -> id
        }

func MapDateListToAdjustableOrRelativeDates:
    inputs:
        fpmlDateList date (0..*)
    output:
        adjustableOrRelativeDates AdjustableOrRelativeDates (0..1)

    set adjustableOrRelativeDates:
        AdjustableOrRelativeDates {
            adjustableDates: MapDateListToAdjustableDates(fpmlDateList),
            ...
        }

func MapDateListToAdjustableDates:
    inputs:
        fpmlDateList date (0..*)
    output:
        adjustableDates AdjustableDates (0..1)

    set adjustableDates:
        AdjustableDates {
            adjustedDate: fpmlDateList,
            ...
        }

func MapDateToAdjustableOrRelativeDate:
    inputs:
        fpmlDateList date (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    set adjustableOrRelativeDate:
        AdjustableOrRelativeDate {
            adjustableDate: MapDateToAdjustableDate(fpmlDateList),
            ...
        }

func MapDateToAdjustableDate:
    inputs:
        fpmlDateList date (0..1)
    output:
        adjustableDate AdjustableDate (0..1)

    set adjustableDate:
        AdjustableDate {
            adjustedDate: fpmlDateList,
            ...
        }

func MapOffset:
    inputs:
        fpmlOffset fpml.Offset (0..1)
    output:
        offset Offset (0..1)

    set offset:
        Offset {
            periodMultiplier: fpmlOffset -> periodMultiplier,
            period: fpmlOffset -> period to-enum PeriodEnum,
            dayType: fpmlOffset -> dayType to-enum DayTypeEnum,
        }

func MapAdjustedRelativeDateOffset:
    inputs:
        fpmlRelativeDate fpml.AdjustedRelativeDateOffset (0..1)
    output:
        adjustedRelativeDateOffset AdjustedRelativeDateOffset (0..1)

    set adjustedRelativeDateOffset:
        MapRelativeDateOffsetToAdjustedRelativeDateOffset(fpmlRelativeDate)

    set adjustedRelativeDateOffset -> relativeDateAdjustments:
        MapBusinessDayAdjustments(fpmlRelativeDate -> relativeDateAdjustments)

func MapRelativeDateSequenceToAdjustedRelativeDateOffset:
    inputs:
        fpmlRelativeDateSequence fpml.RelativeDateSequence (0..1)
    output:
        adjustedRelativeDateOffset AdjustedRelativeDateOffset (0..1)

    alias firstDateOffset: fpmlRelativeDateSequence -> dateOffset first

    set adjustedRelativeDateOffset:
        AdjustedRelativeDateOffset {
            periodMultiplier: firstDateOffset -> periodMultiplier,
            period: firstDateOffset -> period to-enum PeriodEnum,
            dayType: firstDateOffset -> dayType to-enum DayTypeEnum,
            businessDayConvention: firstDateOffset -> businessDayConvention to-enum BusinessDayConventionEnum,
            businessCenters: MapBusinessCenters(
                        fpmlRelativeDateSequence -> businessCentersOrReferenceModel -> businessCenters
                    ),
            businessCentersReference: MapBusinessCenterReference(
                        fpmlRelativeDateSequence -> businessCentersOrReferenceModel -> businessCentersReference
                    ),
            dateRelativeTo: MapDateReference(fpmlRelativeDateSequence -> dateRelativeTo),
            ...
        }

func MapRelativeDateOffsetToAdjustedRelativeDateOffset:
    inputs:
        fpmlRelativeDateOffset fpml.RelativeDateOffset (0..1)
    output:
        adjustedRelativeDateOffset AdjustedRelativeDateOffset (0..1)

    set adjustedRelativeDateOffset:
        AdjustedRelativeDateOffset {
            periodMultiplier: fpmlRelativeDateOffset -> periodMultiplier,
            period: fpmlRelativeDateOffset -> period to-enum PeriodEnum,
            dayType: fpmlRelativeDateOffset -> dayType to-enum DayTypeEnum,
            businessDayConvention: fpmlRelativeDateOffset -> businessDayConvention to-enum BusinessDayConventionEnum,
            businessCenters: MapBusinessCenters(
                        fpmlRelativeDateOffset -> businessCentersOrReferenceModel -> businessCenters
                    ),
            businessCentersReference: MapBusinessCenterReference(
                        fpmlRelativeDateOffset -> businessCentersOrReferenceModel -> businessCentersReference
                    ),
            dateRelativeTo: MapDateReference(fpmlRelativeDateOffset -> dateRelativeTo),
            adjustedDate: fpmlRelativeDateOffset -> adjustedDate -> value -> date,
            ...
        }

func MapRelativeDateOffset:
    inputs:
        fpmlRelativeDateOffset fpml.RelativeDateOffset (0..1)
    output:
        relativeDateOffset RelativeDateOffset (0..1)

    set relativeDateOffset:
        RelativeDateOffset {
            periodMultiplier: fpmlRelativeDateOffset -> periodMultiplier,
            period: fpmlRelativeDateOffset -> period to-enum PeriodEnum,
            dayType: fpmlRelativeDateOffset -> dayType to-enum DayTypeEnum,
            businessDayConvention: fpmlRelativeDateOffset -> businessDayConvention to-enum BusinessDayConventionEnum,
            businessCenters: MapBusinessCenters(
                        fpmlRelativeDateOffset -> businessCentersOrReferenceModel -> businessCenters
                    ),
            businessCentersReference: MapBusinessCenterReference(
                        fpmlRelativeDateOffset -> businessCentersOrReferenceModel -> businessCentersReference
                    ),
            dateRelativeTo: MapDateReference(fpmlRelativeDateOffset -> dateRelativeTo),
            adjustedDate: fpmlRelativeDateOffset -> adjustedDate -> value -> date
        }

func MapDateOffsetToRelativeDateOffset:
    inputs:
        fpmlRelativeDateOffset fpml.DateOffset (0..1)
    output:
        relativeDateOffset RelativeDateOffset (0..1)

    set relativeDateOffset:
        RelativeDateOffset {
            periodMultiplier: fpmlRelativeDateOffset -> periodMultiplier,
            period: fpmlRelativeDateOffset -> period to-enum PeriodEnum,
            dayType: fpmlRelativeDateOffset -> dayType to-enum DayTypeEnum,
            businessDayConvention: fpmlRelativeDateOffset -> businessDayConvention to-enum BusinessDayConventionEnum,
            ...
        }

func MapRelativeDates:
    inputs:
        fpmlRelativeDates fpml.RelativeDates (0..1)
    output:
        relativeDates RelativeDates (0..1)

    set relativeDates:
        RelativeDates {
            periodMultiplier: fpmlRelativeDates -> periodMultiplier,
            period: fpmlRelativeDates -> period to-enum PeriodEnum,
            dayType: fpmlRelativeDates -> dayType to-enum DayTypeEnum,
            businessDayConvention: fpmlRelativeDates -> businessDayConvention to-enum BusinessDayConventionEnum,
            businessCenters: MapBusinessCenters(
                        fpmlRelativeDates -> businessCentersOrReferenceModel -> businessCenters
                    ),
            businessCentersReference: MapBusinessCenterReference(
                        fpmlRelativeDates -> businessCentersOrReferenceModel -> businessCentersReference
                    ),
            dateRelativeTo: MapDateReference(fpmlRelativeDates -> dateRelativeTo),
            adjustedDate: fpmlRelativeDates -> adjustedDate -> value -> date,
            ...
        }

func MapRelativeDateSequenceToRelativeDates:
    inputs:
        fpmlRelativeDateSequence fpml.RelativeDateSequence (0..1)
    output:
        relativeDates RelativeDates (0..1)

    alias firstDateOffset: fpmlRelativeDateSequence -> dateOffset first

    set relativeDates:
        RelativeDates {
            periodMultiplier: firstDateOffset -> periodMultiplier,
            period: firstDateOffset -> period to-enum PeriodEnum,
            dayType: firstDateOffset -> dayType to-enum DayTypeEnum,
            businessDayConvention: firstDateOffset -> businessDayConvention to-enum BusinessDayConventionEnum,
            businessCenters: MapBusinessCenters(
                        fpmlRelativeDateSequence -> businessCentersOrReferenceModel -> businessCenters
                    ),
            businessCentersReference: MapBusinessCenterReference(
                        fpmlRelativeDateSequence -> businessCentersOrReferenceModel -> businessCentersReference
                    ),
            dateRelativeTo: MapDateReference(fpmlRelativeDateSequence -> dateRelativeTo),
            ...
        }

func MapPeriodicDates:
    inputs:
        fpmlPeriodicDates fpml.PeriodicDates (0..1)
    output:
        periodicDates PeriodicDates (0..1)

    set periodicDates:
        PeriodicDates {
            startDate: MapAdjustableOrRelativeDate(
                        fpmlPeriodicDates -> calculationStartDate
                    ),
            endDate: MapAdjustableOrRelativeDate(fpmlPeriodicDates -> calculationEndDate),
            periodFrequency: MapCalculationPeriodFrequency(
                        fpmlPeriodicDates -> calculationPeriodFrequency
                    ),
            periodDatesAdjustments: MapBusinessDayAdjustments(
                        fpmlPeriodicDates -> calculationPeriodDatesAdjustments
                    ),
            ...
        }

func MapCalculationPeriodFrequency:
    inputs:
        fpmlCalculationPeriodFrequency fpml.CalculationPeriodFrequency (0..1)
    output:
        calculationPeriodFrequency CalculationPeriodFrequency (0..1)

    set calculationPeriodFrequency:
        CalculationPeriodFrequency {
            periodMultiplier: fpmlCalculationPeriodFrequency -> periodMultiplier,
            period: MapPeriodExtendedEnum(
                        fpmlCalculationPeriodFrequency -> period to-string
                    ),
            rollConvention: fpmlCalculationPeriodFrequency -> rollConvention to-enum RollConventionEnum,
            ...
        }

func MapFxFixingDate:
    inputs:
        fpmlFxFixingDate fpml.FxFixingDate (0..1)
        paymentDates fpml.PaymentDates (0..1)
    output:
        fxFixingDate FxFixingDate (0..1)

    set fxFixingDate:
        FxFixingDate {
            period: fpmlFxFixingDate -> period to-enum PeriodEnum,
            periodMultiplier: fpmlFxFixingDate -> periodMultiplier,
            dayType: fpmlFxFixingDate -> dayType to-enum DayTypeEnum,
            businessDayConvention: fpmlFxFixingDate -> businessDayConvention to-enum BusinessDayConventionEnum,
            businessCenters: MapBusinessCenters(
                        fpmlFxFixingDate -> businessCentersOrReferenceModel -> businessCenters
                    ),
            businessCentersReference: MapBusinessCenterReference(
                        fpmlFxFixingDate -> businessCentersOrReferenceModel -> businessCentersReference
                    ),
            dateRelativeToPaymentDates:
                DateRelativeToPaymentDates {
                    paymentDatesReference: MapPaymentDatesReference(paymentDates)
                },
            ...
        }

func MapPaymentDatesReference:
    inputs:
        fpmlPaymentDates fpml.PaymentDates (0..1)
    output:
        paymentDatesReference PaymentDates (0..1)
            [metadata reference]

    set paymentDatesReference:
        empty with-meta {
            reference: fpmlPaymentDates -> id
        }

func MapIdentifiedDate:
    inputs:
        fpmlIdentifiedDate fpml.IdentifiedDate (0..1)
    output:
        dateWithId date (0..1)
            [metadata id]

    set dateWithId:
        fpmlIdentifiedDate -> value -> date with-meta {
            id: fpmlIdentifiedDate -> id
        }

func MapDateReference:
    inputs:
        fpmlDateReference fpml.DateReference (0..1)
    output:
        dateReference date (0..1)
            [metadata reference]

    set dateReference:
        empty with-meta {
            reference: fpmlDateReference -> href
        }

func MapBusinessDayAdjustments:
    inputs:
        fpmlBusinessDateAdjustments fpml.BusinessDayAdjustments (0..1)
    output:
        businessDayAdjustments BusinessDayAdjustments (0..1)
    set businessDayAdjustments:
        BusinessDayAdjustments {
            businessDayConvention: MapBusinessDayConventionEnum(
                        fpmlBusinessDateAdjustments -> businessDayConvention to-string
                    ),
            businessCenters: MapBusinessCenterOrBusinessCenterReference(
                        fpmlBusinessDateAdjustments -> businessCentersOrReferenceModel
            ),
        }

func MapBusinessDayAdjustmentsReference:
    inputs:
        fpmlBusinessDateAdjustments fpml.BusinessDayAdjustmentsReference (0..1)
    output:
        businessDayAdjustments BusinessDayAdjustments (0..1)
            [metadata reference]

    set businessDayAdjustments:
        empty with-meta {
            reference: fpmlBusinessDateAdjustments -> href
        }

func MapBusinessCenters:
    inputs:
        fpmlBusinessCenters fpml.BusinessCenters (0..1)
    output:
        businessCenters BusinessCenters (0..1)
    set businessCenters:
        BusinessCenters {
            businessCenter: fpmlBusinessCenters -> businessCenter extract MapBusinessCenter,
            ...
        } with-meta {
            key: fpmlBusinessCenters -> id
        }

func MapBusinessCenter:
    inputs:
        fpmlBusinessCenter fpml.BusinessCenter (0..1)
    output:
        businessCenter BusinessCenter (0..1)
            [metadata scheme]

    set businessCenter:
        MapBusinessCenterEnum(fpmlBusinessCenter -> value) with-meta {
            scheme: fpmlBusinessCenter -> businessCenterScheme
        }

func MapBusinessCenterOrBusinessCenterReference:
    inputs:
        fpmlBusinessCentersOrReferenceModel fpml.BusinessCentersOrReferenceModel (0..1)
    output:
        businessCenters BusinessCenters (0..1)
    set businessCenters:
        BusinessCenters {
            businessCenter: fpmlBusinessCentersOrReferenceModel -> businessCenters -> businessCenter
                    extract MapBusinessCenter,
            businessCentersReference: MapBusinessCenterReference(
                        fpmlBusinessCentersOrReferenceModel -> businessCentersReference
                    ),
            ...
        } with-meta {
            key: fpmlBusinessCentersOrReferenceModel -> businessCenters -> id
        }

func MapBusinessCenterReference:
    inputs:
        fpmlBusinessCentersReference fpml.BusinessCentersReference (0..1)
    output:
        businessCentersReference BusinessCenters (0..1)
            [metadata reference]

    set businessCentersReference:
        empty with-meta {
            reference: fpmlBusinessCentersReference -> href
        }

func MapBusinessCenterTime:
    inputs:
        fpmlBusinessCenterTime fpml.BusinessCenterTime (0..1)
    output:
        businessCenterTime BusinessCenterTime (0..1)

    set businessCenterTime:
        BusinessCenterTime {
            hourMinuteTime: fpmlBusinessCenterTime -> hourMinuteTime,
            businessCenter: fpmlBusinessCenterTime -> businessCenter -> value
        }
    set businessCenterTime -> businessCenter -> scheme:
        fpmlBusinessCenterTime -> businessCenter -> businessCenterScheme

func MapPeriod:
    inputs:
        fpmlPeriod fpml.Period (0..1)
    output:
        period Period (0..1)

    set period:
        Period {
            periodMultiplier: fpmlPeriod -> periodMultiplier,
            period: fpmlPeriod -> period to-enum PeriodEnum
        }

func MapPeriodToFrequency:
    inputs:
        fpmlPeriod fpml.Period (0..1)
    output:
        frequency Frequency (0..1)

    set frequency:
        Frequency {
            periodMultiplier: fpmlPeriod -> periodMultiplier,
            period: fpmlPeriod -> period to-enum PeriodExtendedEnum,
        }

func MapDividendPaymentDate:
    inputs:
        fpmlDividendPaymentDate fpml.DividendPaymentDate (0..1)
    output:
        dividendPaymentDate DividendPaymentDate (0..1)

    set dividendPaymentDate:
        DividendPaymentDate {
            dividendDateReference:
                DividendDateReference {
                    dateReference: fpmlDividendPaymentDate -> dividendPaymentDateSequence -> dividendDateReference to-enum DividendDateReferenceEnum,
                    paymentDateOffset: MapOffset(
                                fpmlDividendPaymentDate -> dividendPaymentDateSequence -> paymentDateOffset
                            )
                },
            dividendDate: MapAdjustableDateOrAdjustedRelativeDate(
                        fpmlDividendPaymentDate -> adjustableDate,
                        empty
                    )
        }

func MapUnadjustedDateToDividendPaymentDate:
    inputs:
        fpmlUnadjustedDate fpml.IdentifiedDate (0..1)
    output:
        dividendPaymentDate DividendPaymentDate (0..1)

    set dividendPaymentDate:
        DividendPaymentDate {
            dividendDate: MapUnadjustedDateToAdjustableOrRelativeDate(
                        fpmlUnadjustedDate -> value -> date,
                        fpmlUnadjustedDate -> id
                    ),
            ...
        }

func MapAdjustableOrRelativeDateToDividendPaymentDate:
    inputs:
        fpmlAdjustableOrRelativeDate fpml.AdjustableOrRelativeDate (0..1)
    output:
        dividendPaymentDate DividendPaymentDate (0..1)

    set dividendPaymentDate:
        DividendPaymentDate {
            dividendDate: MapAdjustableOrRelativeDate(fpmlAdjustableOrRelativeDate),
            ...
        }

func MapDateReferenceToDividendPaymentDate:
    inputs:
        fpmlDateReference fpml.DateReference (0..1)
    output:
        dividendPaymentDate DividendPaymentDate (0..1)

    set dividendPaymentDate:
        DividendPaymentDate {
            dividendDate: MapAdjustedRelativeDateReference(fpmlDateReference),
            ...
        }

func MapPeriodicPaymentToCalculationPeriodFrequency:
    inputs:
        fpmlPeriodicPayment fpml.PeriodicPayment (0..1)
    output:
        calculationPeriodFrequency CalculationPeriodFrequency (0..1)

    set calculationPeriodFrequency:
        CalculationPeriodFrequency {
            periodMultiplier: fpmlPeriodicPayment -> paymentFrequency -> periodMultiplier,
            period: fpmlPeriodicPayment -> paymentFrequency -> period to-enum PeriodExtendedEnum,
            rollConvention: fpmlPeriodicPayment -> rollConvention to-enum RollConventionEnum,
            ...
        }

func MapPeriodicPaymentToPaymentDates:
    inputs:
        fpmlPeriodicPayment fpml.PeriodicPayment (0..1)
    output:
        paymentFrequency PaymentDates (0..1)

    set paymentFrequency:
        PaymentDates {
            paymentFrequency: MapPeriodToFrequency(fpmlPeriodicPayment -> paymentFrequency),
            firstPaymentDate: fpmlPeriodicPayment -> firstPaymentDate -> date,
            lastRegularPaymentDate: fpmlPeriodicPayment -> lastRegularPaymentDate -> date,
            ...
        }

func MapCommodityDeliveryDates:
    inputs:
        fpmlCommodity fpml.Commodity (0..1)
    output:
        offset Offset (0..1)

    alias deliveryDates:
        fpmlCommodity -> commodityProductModel -> commodityProductModelSequence -> commodityProductModelSequenceChoice -> deliveryDates

    set offset:
        Offset {
            period: if deliveryDates exists then M else empty,
            periodMultiplier: MapDeliveryDatesToPeriodMultiplier(deliveryDates),
            ...
        }

func MapDeliveryDatesToPeriodMultiplier:
    inputs:
        fpmlDeliveryDates fpml.DeliveryDatesEnum (0..1)
    output:
        periodMultiplier int (0..1)

    set periodMultiplier:
        if fpmlDeliveryDates = FirstNearby
        then 1
        else if fpmlDeliveryDates = SecondNearby
        then 2
        else if fpmlDeliveryDates = ThirdNearby
        then 3
        else if fpmlDeliveryDates = FourthNearby
        then 4
        else if fpmlDeliveryDates = FifthNearby
        then 5
        else if fpmlDeliveryDates = SixthNearby
        then 6
        else if fpmlDeliveryDates = SeventhNearby
        then 7

func MapCommodityRelativePaymentDates:
    inputs:
        commodityPaymentDatesModel fpml.CommodityPaymentDatesModel (0..1)
    output:
        paymentDates PaymentDates (0..1)

    alias relativePaymentDates: commodityPaymentDatesModel -> relativePaymentDates

    set paymentDates:
        PaymentDates {
            payRelativeTo: MapPayRelativeToEnum(
                        relativePaymentDates -> payRelativeTo to-string
                    ),
            paymentDaysOffset: MapOffset(relativePaymentDates -> paymentDaysOffset),
            paymentDatesAdjustments:
                BusinessDayAdjustments {
                    businessDayConvention: MapBusinessDayConventionEnum(
                                relativePaymentDates -> paymentDaysOffset -> businessDayConvention to-string
                            ),
                    businessCenters: MapBusinessCenters(
                                relativePaymentDates -> businessCentersOrReferenceModel -> businessCenters
                    ),
                },
            ...
        }

func MapCommodityPriceDatesToPricingDates:
    inputs:
        fpmlCommodityPricingDates fpml.CommodityPricingDates (0..1)
    output:
        pricingDates PricingDates (0..1)

    set pricingDates:
        PricingDates {
            parametricDates: MapParametricDates(fpmlCommodityPricingDates),
            ...
        }

func MapParametricDates:
    inputs:
        fpmlCommodityPricingDates fpml.CommodityPricingDates (0..1)
    output:
        parametricDates ParametricDates (0..1)

    alias commodityPricingDates:
        fpmlCommodityPricingDates -> commodityPricingDatesSequence -> commodityPricingDatesSequenceSequence
    alias daysModel: commodityPricingDates -> daysModel

    set parametricDates:
        ParametricDates {
            dayType: MapDayTypeEnum(daysModel -> dayType to-string),
            dayDistribution: MapDayDistributionEnumWithScheme(
                        daysModel -> daysModelSequence0 -> dayDistribution -> value,
                        daysModel -> daysModelSequence0 -> dayDistribution -> commodityFrequencyTypeScheme
                    ),
            dayOfWeek: daysModel -> daysModelSequence1 -> dayOfWeek
                    extract MapDayOfWeekEnum(item to-string),
            dayFrequency: daysModel -> daysModelSequence1 -> dayNumber,
            businessCenters: MapCommodityBusinessCalendarToBusinessCenters(
                        commodityPricingDates -> businessCalendar
                    ),
            ...
        }

func MapCommodityBusinessCalendarToBusinessCenters:
    inputs:
        fpmlBusinessCalendar fpml.CommodityBusinessCalendar (0..1)
    output:
        businessCenters BusinessCenters (0..1)

    set businessCenters:
        BusinessCenters {
            commodityBusinessCalendar: MapCommodityBusinessCalendarEnumWithScheme(
                        fpmlBusinessCalendar -> value,
                        fpmlBusinessCalendar -> commodityBusinessCalendarScheme
                    ),
            ...
        }

func MapDayDistributionEnumWithScheme:
    inputs:
        value string (0..1)
        scheme string (0..1)
    output:
        dayDistribution DayDistributionEnum (0..1)
            [metadata scheme]

    set dayDistribution: value to-enum DayDistributionEnum
    set dayDistribution -> scheme: scheme

func MapCommodityBusinessCalendarEnumWithScheme:
    inputs:
        value string (0..1)
        scheme string (0..1)
    output:
        commodityBusinessCalendar CommodityBusinessCalendarEnum (0..1)
            [metadata scheme]

    set commodityBusinessCalendar:
        value to-enum CommodityBusinessCalendarEnum with-meta {
            scheme: scheme
        }

func MapCommodityCalculationPeriods:
    inputs:
        fpmlCommodityCalculationPeriods fpml.CommodityCalculationPeriodsModel (0..1)
    output:
        calculationPeriodDates CalculationPeriodDates (0..1)

    set calculationPeriodDates:
        CalculationPeriodDates {
            calculationPeriodFrequency: MapCommodityCalculationPeriodFrequency(
                        fpmlCommodityCalculationPeriods
                    ),
            ...
        }

func MapCommodityCalculationPeriodFrequency:
    inputs:
        fpmlCommodityCalculationPeriodsModel fpml.CommodityCalculationPeriodsModel (1..1)
    output:
        calculationPeriodFrequency CalculationPeriodFrequency (0..1)

    alias calculationPeriod:
        fpmlCommodityCalculationPeriodsModel -> calculationPeriodsSchedule

    set calculationPeriodFrequency:
        CalculationPeriodFrequency {
            period: MapPeriodExtendedEnum(calculationPeriod -> period to-string),
            periodMultiplier: calculationPeriod -> periodMultiplier,
            rollConvention: empty,
            balanceOfFirstPeriod: calculationPeriod -> balanceOfFirstPeriod
        } with-meta {
            key: calculationPeriod -> id
        }

func MapCommodityCalculationPeriodsScheduleToCalculationPeriodFrequncy:
    inputs:
        fpmlCommodityCalculationPeriodsSchedule fpml.CommodityCalculationPeriodsSchedule (0..1)
    output:
        calculationPeriodFrequency CalculationPeriodFrequency (0..1)

    set calculationPeriodFrequency:
        CalculationPeriodFrequency {
            periodMultiplier: fpmlCommodityCalculationPeriodsSchedule -> periodMultiplier,
            period: fpmlCommodityCalculationPeriodsSchedule -> period to-enum PeriodExtendedEnum,
            balanceOfFirstPeriod: fpmlCommodityCalculationPeriodsSchedule -> balanceOfFirstPeriod,
            rollConvention: empty
        } with-meta {
            key: fpmlCommodityCalculationPeriodsSchedule -> id
        }

func MapPerformanceValuationDates:
    inputs:
        fpmlDeterminationMethod fpml.DeterminationMethod (1..1)
        fpmlEquityValuation fpml.EquityValuation (0..1)
    output:
        performanceValuationDates PerformanceValuationDates (0..1)

    set performanceValuationDates:
        PerformanceValuationDates {
            determinationMethod: fpmlDeterminationMethod -> value to-enum DeterminationMethodEnum,
            valuationDates: MapAdjustableRelativeOrPeriodicDates(
                        fpmlEquityValuation -> valuationDates
                    ),
            valuationDate: MapAdjustableDateOrRelativeDateSequenceToAdjustableOrAdjustedRelativeDate(
                        fpmlEquityValuation -> valuationDate -> adjustableDate,
                        fpmlEquityValuation -> valuationDate -> relativeDateSequence,
                        fpmlEquityValuation -> valuationDate -> id
                    ),
            valuationTime: MapBusinessCenterTime(fpmlEquityValuation -> valuationTime),
            valuationTimeType: fpmlEquityValuation -> valuationTimeType to-enum TimeTypeEnum,
        }

func MapFpmlDateTimeListToDateTimeList: <"Creates a ZonedDateTime from the provided ZonedDateTime">
    inputs:
        fpmldateTime fpml.DateTimeList (0..1)
    output:
        zonedDateTime DateTimeList (0..*)

    add zonedDateTime:
        DateTimeList {
            dateTime: fpmldateTime -> dateTime,
        }

func MapEventTimestampQualification:
    inputs:
        messageHeaderModel fpml.MessageHeaderModel (0..1)
        fpmlTrade fpml.Trade (0..1)
    output:
        qual EventTimestampQualificationEnum (0..1)

    alias partyTradeInformation:
        fpmlTrade -> tradeHeader -> partyTradeInformation distinct only-element

    set qual:
        if messageHeaderModel -> creationTimestamp exists
        then eventCreationDateTime
        else if partyTradeInformation -> timestamps -> submittedForClearing exists
        then clearingReceiptDateTime
        else if partyTradeInformation -> timestamps -> cleared exists
        then clearingReceiptDateTime
        else if partyTradeInformation -> timestamps -> confirmed exists
        then confirmationDateTime
        else if partyTradeInformation -> executionDateTime exists
        then executionDateTime

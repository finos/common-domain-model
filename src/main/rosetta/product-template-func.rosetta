namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*

import cdm.observable.asset.*

import cdm.product.common.*
import cdm.product.common.settlement.*

func Create_TradeLot:
    inputs:
        lotIdentifier Identifier (0..*) <"The lot Identifiers.">
        priceQuantity PriceQuantity (1..*) <"List of PriceQuantity.">
    output:
        tradeLot TradeLot (1..1)

    assign-output tradeLot -> lotIdentifier: lotIdentifier
    assign-output tradeLot -> priceQuantity: priceQuantity

func FilterTradeLot: <"Filter list of TradeLot based on TradeLot->lotIdentifier.">
	inputs:
		tradeLots TradeLot (0..*) <"List of TradeLots to filter.">
		lotIdentifier Identifier (0..*) <"The lot Identifiers to filter by.">
	output:
		filteredTradeLots TradeLot (0..*)

	set filteredTradeLots:
	    tradeLots
	        filter [ item -> lotIdentifier = lotIdentifier ]

func AddTradeLot: <"Add a TradeLot to an existing list of TradeLots.">
	inputs:
		tradeLots TradeLot (0..*) <"Input list of TradeLots.">
		newTradeLot TradeLot (1..1) <"The TradeLot to append to the list.">
	output:
		updatedTradeLots TradeLot (0..*)

	assign-output updatedTradeLots: tradeLots
	assign-output updatedTradeLots: newTradeLot

func MergeTradeLot: <"Replace TradeLot in with matching TradeLot->lotIdentifier.">
	inputs:
		tradeLots TradeLot (0..*) <"Input list of TradeLots.">
		newTradeLot TradeLot (1..1) <"The TradeLot to replace a matching TradeLot in the list.">
	output:
		mergedTradeLots TradeLot (0..*)

	set mergedTradeLots: <"Where the lot identifier matches, replace the existing TradeLot with the new TradeLot.">
	    tradeLots
	        map [
	            if item -> lotIdentifier = newTradeLot -> lotIdentifier
	                or ( item -> lotIdentifier is absent and newTradeLot -> lotIdentifier is absent )
	            then newTradeLot
	            else item
            ]

func CompareTradeLot: <"Compare the Quantity in TradeLot 1 to the Quantity (with the same unit of amount) in TradeLot 2, based on the CompareOp enum.">
	inputs:
		tradeLot1 TradeLot (1..1)
        op CompareOp (1..1)
		tradeLot2 TradeLot (1..1)
	output:
		result boolean (1..1)

	alias unitOfAmounts:
		tradeLot2 -> priceQuantity -> quantity -> unitOfAmount distinct

	alias results:
		unitOfAmounts
		    // for each unit of amount
			map unitOfAmount [
			    // get quantities from tradeLot 1 with the given unit of amount
				FilterQuantity( tradeLot1 -> priceQuantity -> quantity, unitOfAmount )
					map quantity1 [
						// get quantities from tradeLot 2 with the given unit of amount
                        FilterQuantity( tradeLot2 -> priceQuantity -> quantity, unitOfAmount )
							map quantity2 [
							    // compare quantity 1 with each quantity 2
							    CompareNumbers( quantity1 -> amount, op, quantity2 -> amount )
                            ]
					] flatten
			] flatten

	assign-output result:
		results all = True

func CompareTradeLotToAmount: <"Compare the Quantity amount in TradeLot to the given amount (regardless of unit of amount), based on the CompareOp enum.">
	inputs:
		tradeLot TradeLot (1..1)
		op CompareOp (1..1)
		amount number (1..1)
	output:
		result boolean (1..1)

	alias results:
		tradeLot -> priceQuantity -> quantity
			map [ CompareNumbers( item -> amount, op, amount ) ]

	assign-output result:
		results all = True

func FpmlIrd8: <"FpML validation rule ird-8 - If the same party is specified as the payer and receiver, then different accounts must be specified.">
	inputs:
		tradableProduct TradableProduct (1..1)
		accounts Account (0..*)
	output:
		success boolean (1..1) <"Validation result">

func Create_TradableProduct: <"Creates a new TradableProduct with the given inputs.">
	inputs:
		product Product (1..1) <"The product to set.">
		tradeLot TradeLot (1..*) <"The settlement instructions to set, including price, quantity and settlement terms (if any).">
		counterparty Counterparty (2..2) <"The counterparties to set.">
		ancillaryParty AncillaryParty (0..*) <"The ancillary parties to set.">
		adjustment NotionalAdjustmentEnum (0..1) <"The adjustment to set.">
	output:
		tradableProduct TradableProduct (1..1)

	assign-output tradableProduct -> product:
         product

    assign-output tradableProduct -> tradeLot:
        tradeLot

    assign-output tradableProduct -> counterparty:
        counterparty

    assign-output tradableProduct -> ancillaryParty:
        ancillaryParty

    assign-output tradableProduct -> adjustment:
        adjustment

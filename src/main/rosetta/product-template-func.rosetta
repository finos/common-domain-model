namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*

import cdm.observable.asset.*

import cdm.product.common.*
import cdm.product.common.settlement.*

func Create_TradeLot:
    inputs:
        lotIdentifier Identifier (0..*) <"The lot Identifiers.">
        priceQuantity PriceQuantity (1..*) <"List of PriceQuantity.">
    output:
        tradeLot TradeLot (1..1)

    assign-output tradeLot -> lotIdentifier: lotIdentifier
    assign-output tradeLot -> priceQuantity: priceQuantity

func FilterTradeLot: <"Filter list of TradeLot based on TradeLot->lotIdentifier.">
	inputs:
		tradeLots TradeLot (0..*) <"List of TradeLots to filter.">
		lotIdentifier Identifier (0..*) <"The lot Identifiers to filter by.">
	output:
		filteredTradeLots TradeLot (0..*)

	set filteredTradeLots:
	    tradeLots
	        filter [ item -> lotIdentifier = lotIdentifier ]

func AddTradeLot: <"Add a TradeLot to an existing list of TradeLots.">
	inputs:
		tradeLots TradeLot (0..*) <"Input list of TradeLots.">
		newTradeLot TradeLot (1..1) <"The TradeLot to append to the list.">
	output:
		updatedTradeLots TradeLot (0..*)

	assign-output updatedTradeLots: tradeLots
	assign-output updatedTradeLots: newTradeLot

func MergeTradeLot: <"Replace TradeLot in with matching TradeLot->lotIdentifier.">
	inputs:
		tradeLots TradeLot (0..*) <"Input list of TradeLots.">
		newTradeLot TradeLot (1..1) <"The TradeLot to replace a matching TradeLot in the list.">
	output:
		mergedTradeLots TradeLot (0..*)

	set mergedTradeLots: <"Where the lot identifier matches, replace the existing TradeLot with the new TradeLot.">
	    tradeLots
	        map [
	            if item -> lotIdentifier = newTradeLot -> lotIdentifier
	                or ( item -> lotIdentifier is absent and newTradeLot -> lotIdentifier is absent )
	            then newTradeLot
	            else item
            ]

func FpmlIrd8: <"FpML validation rule ird-8 - If the same party is specified as the payer and receiver, then different accounts must be specified.">
	inputs:
		tradableProduct TradableProduct (1..1)
		accounts Account (0..*)
	output:
		success boolean (1..1) <"Validation result">

func Create_TradableProduct: <"Creates a new TradableProduct with the given inputs.">
	inputs:
		product Product (1..1) <"The product to set.">
		tradeLot TradeLot (1..*) <"The settlement instructions to set, including price, quantity and settlement terms (if any).">
		counterparty Counterparty (2..2) <"The counterparties to set.">
		ancillaryParty AncillaryParty (0..*) <"The ancillary parties to set.">
		adjustment NotionalAdjustmentEnum (0..1) <"The adjustment to set.">
	output:
		tradableProduct TradableProduct (1..1)

	assign-output tradableProduct -> product:
         product

    assign-output tradableProduct -> tradeLot:
        tradeLot

    assign-output tradableProduct -> counterparty:
        counterparty

    assign-output tradableProduct -> ancillaryParty:
        ancillaryParty

    assign-output tradableProduct -> adjustment:
        adjustment

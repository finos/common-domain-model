namespace cdm.product.common
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*

import cdm.product.asset.*
import cdm.product.template.*
import cdm.product.common.settlement.*
import cdm.product.common.schedule.*

import cdm.synonyms.config.*

isProduct root EconomicTerms;

func Qualify_CreditDefaultSwap: <"This product qualification is temporary until such time that the ISDA Credit Group specifies a proper taxonomy for credit derivatives that is based upon economic terms.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> creditDefaultPayout exists
		and (economicTerms -> payout -> interestRatePayout
		or economicTerms -> payout -> cashflow) exists
		and economicTerms -> payout -> equityPayout is absent
		and economicTerms -> payout -> optionPayout is absent

func Qualify_CreditDefaultSwaption: <"This product qualification is temporary until such time that the ISDA Credit Group specifies a proper taxonomy for credit derivatives that is based upon economic terms.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> optionPayout exists
		and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
		and (economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> interestRatePayout
		or economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> cashflow) exists
		and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> equityPayout is absent
		and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> optionPayout is absent

func Qualify_EquitySwap_PriceReturnBasicPerformance_SingleName: <"The Price Return Basic Performance equity swap specified in the ISDA taxonomy V2.0 corresponds to the price and total return swaps.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_SingleName"]
	assign-output is_product:
        economicTerms -> payout -> interestRatePayout exists
        and ( economicTerms -> payout -> equityPayout -> returnType = ReturnTypeEnum -> Price
            or economicTerms -> payout -> equityPayout -> returnType = ReturnTypeEnum -> Total )
        and ( economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Equity
            or (economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Fund
				and economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> fundType = FundProductTypeEnum -> ExchangeTradedFund)
			or (economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Fund
				and economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> fundType = FundProductTypeEnum -> MutualFund)
			or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Warrant
            )

func Qualify_EquitySwap_ParameterReturnDividend_SingleName: <"The Parameter Return Dividend equity swap specified in the ISDA taxonomy V2.0 corresponds to the dividend return swap.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnDividend_SingleName"]
	assign-output is_product:
        economicTerms -> payout -> interestRatePayout exists
        and economicTerms -> payout -> equityPayout -> returnType = ReturnTypeEnum -> Dividend
		and ( economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Equity
            or (economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Fund
				and economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> fundType = FundProductTypeEnum -> ExchangeTradedFund)
			or (economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Fund
				and economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> fundType = FundProductTypeEnum -> MutualFund)
			or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Warrant
            )


func Qualify_InterestRate_IRSwap_Basis:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Basis"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent

func Qualify_InterestRate_IRSwap_FixedFloat_PlainVanilla: <"This product qualification doesn't represent the exact terms of the ISDA Taxonomomy V2.0 for the plain vanilla swaps, as some of those cannot be represented as part of the CDM syntax (e.g. the qualification that there is no provision for early termination which uses an off-market valuation), while some other are deemed missing in the ISDA taxonomy and have been added as part of the CDM (absence of cross-currency settlement provision, absence of fixed rate and notional step schedule, absence of stub). ">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> settlementProvision is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule -> step is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> step is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floatingRateMultiplierSchedule is absent
		and economicTerms -> payout -> interestRatePayout -> payoutQuantity -> quantitySchedule -> stepSchedule -> step is absent
		and economicTerms -> payout -> interestRatePayout -> stubPeriod is absent
		and economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> stubPeriodType is absent
		and economicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier =
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period <> PeriodExtendedEnum -> T
		and economicTerms -> payout -> interestRatePayout -> compoundingMethod is absent

func Qualify_InterestRate_IRSwap_FixedFloat:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period <> PeriodExtendedEnum -> T
		and (economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule -> step exists
		or economicTerms -> payout -> interestRatePayout -> payoutQuantity -> quantitySchedule -> stepSchedule -> step exists
		or economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floatingRateMultiplierSchedule exists
		or economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> step exists
		or economicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier <>
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
		or economicTerms -> payout -> interestRatePayout -> compoundingMethod exists
		or economicTerms -> payout -> interestRatePayout -> stubPeriod exists
		or economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> stubPeriodType exists
		or economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> settlementProvision exists)
		and economicTerms -> payout -> interestRatePayout -> paymentDates exists

func Qualify_InterestRate_IRSwap_FixedFixed:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFixed"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent

func Qualify_InterestRate_CrossCurrency_Basis:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_Basis"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists
		and economicTerms -> payout -> optionPayout is absent

func Qualify_InterestRate_CrossCurrency_FixedFloat:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists
		and economicTerms -> payout -> optionPayout is absent

func Qualify_InterestRate_CrossCurrency_FixedFixed:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFixed"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists
		and economicTerms -> payout -> optionPayout is absent

func Qualify_InterestRate_IRSwap_FixedFloat_ZeroCoupon:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T

func Qualify_InterestRate_IRSwap_FixedFloat_OIS:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex = FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND

func Qualify_InterestRate_IRSwap_Basis_OIS:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Basis"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex = FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND

func Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> Y

func Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T

func Qualify_InterestRate_InflationSwap_Basis_YearOn_Year:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> Y

func Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T

func Qualify_InterestRate_Option_Swaption:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_Option_Swaption"]
	assign-output is_product:
		economicTerms -> payout -> optionPayout exists
		and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2

func Qualify_InterestRate_Option_DebtOption:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_DebtOption"]
	assign-output is_product:
        economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Debt
		or (economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> securityType = SecurityTypeEnum -> Debt
			and economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> debtType -> debtClass = DebtClassEnum -> Convertible)

func Qualify_InterestRate_CapFloor:	
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_CapFloor"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> capRateSchedule exists
		or economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floorRateSchedule exists

func Qualify_InterestRate_Fra:
	[qualification Product]
	inputs: eTerms EconomicTerms(1..1)
	output: result boolean(1..1)
			[synonym ISDA_Taxonomy_v1 value "InterestRate_Fra"]

	assign-output result:
		eTerms -> payout -> interestRatePayout count = 2
		and eTerms -> payout -> creditDefaultPayout is absent
		and eTerms -> payout -> cashflow is absent
		and EffectiveDateContainsPaymentDate(eTerms) = True

func Qualify_ForeignExchange_Spot_Forward: <"Qualifies a product as Foreign Exchange based on economic terms, which is defined as an agreement to buy one currency against the delivery of another currency at a rate set on the trade date for settlement on a specified date in the future.  Dependent on conventions specific to local markets the product could be considered either Spot or Forward.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "ForeignExchange_Forward"]
			[synonym ISDA_Taxonomy_v1 value "ForeignExchange_Spot"]
			[synonym ISDA_Taxonomy_v2 value "ForeignExchange_Forward"]
			[synonym ISDA_Taxonomy_v2 value "ForeignExchange_Spot"]
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange only exists and
		economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange count = 1
		and economicTerms -> payout -> forwardPayout -> settlementTerms -> fxSettlementTerms is absent

func Qualify_ForeignExchange_Swap: <"Qualifies a product as Foreign Exchange Swap based on economic terms, which is defined as a contract in which one party borrows one currency from, and simultaneously lends another to, the second party. Each party uses the repayment obligation to its counterparty as collateral and the amount of repayment is fixed at the FX forward rate as of the start of the contract.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange only exists and
		economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange count = 2
		and economicTerms -> payout -> forwardPayout -> settlementTerms -> fxSettlementTerms is absent

func Qualify_ForeignExchange_NDF: <"Qualifies a product as Foreign Exchange Non-Deliverable Forward based on economic terms, which is defined as a Forward transaction where the notional amount of one of the currencies (the “reference currency”) is converted into the other currency (the “settlement currency”) at a spot foreign exchange rate that is observed on a valuation date prior to the settlement date, and a single net payment in the settlement currency is made on the settlement date. No payment or account transfer takes place in the reference currency.">
	[qualification Product]

	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "ForeignExchange_NDF"]
			[synonym ISDA_Taxonomy_v2 value "ForeignExchange_NDF"]
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange only exists and
		economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange count = 1
		and economicTerms -> payout -> forwardPayout -> settlementTerms -> fxSettlementTerms exists

func Qualify_ForeignExchange_VanillaOption: <"Qualifies a product as FX Plain Vanilla Option based on economic terms, which is defined as one where 1) exercise style is American or European style only, and 2) does not contain any feature like Forward Starting Strike or Performance payout.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
			[synonym ISDA_Taxonomy_v1 value "ForeignExchange_VanillaOption"]
			[synonym ISDA_Taxonomy_v2 value "ForeignExchange_VanillaOption"]
	assign-output is_product:
		economicTerms -> payout -> optionPayout exists
		and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> foreignExchange only exists
		and	(economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise exists
			or economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> europeanExercise exists)
		and (economicTerms -> payout -> optionPayout -> feature is absent
			or economicTerms -> payout -> optionPayout -> feature -> averagingRateFeature only exists)

func Qualify_RepurchaseAgreement:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> securityPayout -> securityLeg count >= 1 and
		economicTerms -> payout -> interestRatePayout count = 1

func Qualify_Commodity_Swap_FixedFloat:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> commodityPayout exists
		and economicTerms -> payout -> fixedForwardPayout exists
		
func Qualify_Commodity_Swap_Basis:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> commodityPayout count = 2



namespace cdm.product.common
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*

import cdm.product.asset.*
import cdm.product.template.*
import cdm.product.common.settlement.*
import cdm.product.common.schedule.*

import cdm.synonyms.config.*

isProduct root EconomicTerms;

func Qualify_CreditDefaultSwap_SingleName: <"Qualifies a product as a Credit Default Swap which provides protection relative to defaults of a reference entity that could be a corporate, municipal, sovererign, or special purpose vehicle issuer of publically traded debt.  The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit deault leg and one interest leg or cashflow leg, 2) the reference entity is corporate, municipal, or sovererign issuer of debt, 3) the reference obligation is not a loan, and 4) there are no opton features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)	output: is_product boolean (1..1)
	assign-output is_product:
		// qualifies that  only the credit default payout and interest rate payout or cash flow exist and all other payouts are absent
		((economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> cashflow) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout, economicTerms -> payout -> cashflow) only exists)

		// qualifies the Credit Default Swap as having a single name underlyer that is not a loan
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->referenceInformation exists
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->referenceInformation ->referenceObligation->loan is absent

func Qualify_CreditDefaultSwap_Index: <"Qualifies a product as a Credit Default Swap which provides protection relative to the performance of an index. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit deault leg and one interest leg or cashflow leg, 2) the reference entity is an index, and 3) there are no opton features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)	output: is_product boolean (1..1)
	assign-output is_product:
		// qualifies that  only the credit default payout and interest rate payout or cash flow exist and all other payouts are absent
		((economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout) only exists
			or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> cashflow) only exists
			or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout, economicTerms -> payout -> cashflow) only exists)

		// qualifies the Credit Default Swap as having a single name underlyer that is not a loan
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->indexReferenceInformation exists
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->indexReferenceInformation->tranche is absent

func Qualify_CreditDefaultSwap_IndexTranche: <"Qualifies a product as a Credit Default Swap which provides protection relative to the performance of an index. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit deault leg and one interest leg or cashflow leg, 2) the reference entity is an index, and 3) there are no opton features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)	output: is_product boolean (1..1)
	assign-output is_product:
		// qualifies that  only the credit default payout and interest rate payout or cash flow exist and all other payouts are absent
		((economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> cashflow) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout, economicTerms -> payout -> cashflow) only exists)

		// qualifies the Credit Default Swap as having a single name underlyer that is not a loan
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->indexReferenceInformation exists
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->indexReferenceInformation->tranche exists

func Qualify_CreditDefaultSwap_Loan: <"Qualifies a product as a Credit Default Swap which provides protection relative to defaults of a reference entity that is a loan. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit deault leg and one interest leg or cashflow leg, 2) the reference entity is a loan, and there are no opton features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)	output: is_product boolean (1..1)
	assign-output is_product:
		// qualifies that  only the credit default payout and interest rate payout or cash flow exist and all other payouts are absent
		((economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> cashflow) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout, economicTerms -> payout -> cashflow) only exists)

		// qualifies the Credit Default Swap as having a single name underlyer that is not a loan
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->referenceInformation exists
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->referenceInformation ->referenceObligation->loan exists

func Qualify_CreditDefaultSwap_Basket: <"Qualifies a product as a Credit Default Swap which provides protection relative to defaults of a reference entity that is a loan. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit deault leg and one interest leg or cashflow leg, 2) the reference entity is a loan, and there are no opton features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)	output: is_product boolean (1..1)
	assign-output is_product:
		// qualifies that  only the credit default payout and interest rate payout or cash flow exist and all other payouts are absent
		((economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> cashflow) only exists
            or (economicTerms -> payout -> creditDefaultPayout, economicTerms -> payout -> interestRatePayout, economicTerms -> payout -> cashflow) only exists)

		// qualifies the Credit Default Swap as having a single name underlyer that is not a loan
		and economicTerms -> payout -> creditDefaultPayout-> generalTerms ->basketReferenceInformation exists

func Qualify_CreditDefaultSwaption: <"This product qualification is temporary until such time that the ISDA Credit Group specifies a proper taxonomy for credit derivatives that is based upon economic terms.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		(economicTerms -> payout -> optionPayout only exists
		    or (economicTerms -> payout -> optionPayout, economicTerms -> payout -> cashflow) only exists)

		and economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
		and (economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout
			or economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> cashflow) exists
		and economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> equityPayout is absent
		and economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> optionPayout is absent

func Qualify_EquitySwap_PriceReturnBasicPerformance_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the price change on a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one equity leg and one interest leg, 2) the returnType is Price, 3) the underlier is an equity security, a fund, an exchange traded fund, mutual fund, or warrant, and 4) there are no option features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_SingleName"]
		[synonym ISDA_Taxonomy_v2 value "EquitySwap_PriceReturnBasicPerformance_SingleName"]
	alias equityPayout: economicTerms -> payout -> equityPayout only-element
	assign-output is_product:
	    // qualifies that  only the equity payout and interest rate payout exist and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> equityPayout) only exists

		// qualifies that the returnType is price and the underlier is an equity security, a fund, an exchange traded fund, mutual fund, or warrant
        and  equityPayout -> returnType = ReturnTypeEnum -> Price
        and ( equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Equity
            or ( equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Fund
				and equityPayout -> underlier -> security -> fundType = FundProductTypeEnum -> ExchangeTradedFund)
			or (equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Fund
				and equityPayout -> underlier -> security -> fundType = FundProductTypeEnum -> MutualFund)
			or equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Warrant
        )

func Qualify_EquitySwap_TotalReturnBasicPerformance_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the price changes and dividend returns on a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one equity leg and one interest leg, 2) the returnType is Total, 3) the underlier is an equity security, a fund, an exchange traded fund, mutual fund, or warrant, and 4) there are no option features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	alias equityPayout: economicTerms -> payout -> equityPayout only-element
	assign-output is_product:
	    // qualifies that  only the equity payout and interest rate payout exist and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> equityPayout) only exists

		// qualifies that the returnType is total and the underlier is an equity security, a fund, an exchange traded fund, mutual fund, or warrant
 		and equityPayout -> returnType = ReturnTypeEnum -> Total
        and ( equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Equity
            or (equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Fund
				and equityPayout -> underlier -> security -> fundType = FundProductTypeEnum -> ExchangeTradedFund)
			or (equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Fund
				and equityPayout -> underlier -> security -> fundType = FundProductTypeEnum -> MutualFund)
			or equityPayout -> underlier -> security -> securityType = SecurityTypeEnum -> Warrant
        )

func Qualify_EquitySwap_PriceReturnBasicPerformance_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the price change on an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one equity leg and one interest leg 2) the returnType is Price 3) the underlier is an index, and 4) there are no option features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_Index"]
		[synonym ISDA_Taxonomy_v2 value "EquitySwap_PriceReturnBasicPerformance_Index"]
	alias equityPayout: economicTerms -> payout -> equityPayout only-element
	assign-output is_product:
	    // qualifies that  only the equity payout and interest rate payout exist and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> equityPayout) only exists

		// qualifies that the returnType is price or total and the underlier is an index
		and equityPayout -> returnType = ReturnTypeEnum -> Price
	    and equityPayout -> underlier -> index exists

func Qualify_EquitySwap_TotalReturnBasicPerformance_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the price changes and dividend returns on an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one equity leg and one interest leg 2) the returnType is Total 3) the underlier is an index, and 4) there are no option features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	alias equityPayout: economicTerms -> payout -> equityPayout only-element
	assign-output is_product:
	    // qualifies that  only the equity payout and interest rate payout exist and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> equityPayout) only exists

		// qualifies that the returnType is price or total and the underlier is an index
		and equityPayout -> returnType = ReturnTypeEnum -> Total
	    and equityPayout -> underlier -> index exists

func Qualify_EquityOption_PriceReturnBasicPerformance_SingleName: <"Qualifies a product as a plain vanilla Equity Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) An option product  for which the underlier is a single stock and 2) No special option feature exists other than option averaging.">//
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	[synonym ISDA_Taxonomy_v1 value "EquityOption_PriceReturnBasicPerformance_SingleName"]
	[synonym ISDA_Taxonomy_v2 value "EquityOption_PriceReturnBasicPerformance_SingleName"]
	assign-output is_product:
	    // qualifies that  only the option payout or option payout and cashflow (for the premium) exist and all other payouts are absent
	 	(economicTerms -> payout -> optionPayout only exists
			or (economicTerms -> payout -> optionPayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies that the underlier is an equity security
	 	and ( economicTerms -> payout -> optionPayout -> underlier -> security -> securityType all = SecurityTypeEnum -> Equity
	        or (economicTerms -> payout -> optionPayout -> underlier -> security -> securityType all = SecurityTypeEnum -> Fund
				and economicTerms -> payout -> optionPayout -> underlier -> security -> fundType all = FundProductTypeEnum -> ExchangeTradedFund)
			or (economicTerms -> payout -> optionPayout -> underlier -> security -> securityType all = SecurityTypeEnum -> Fund
				and economicTerms -> payout -> optionPayout -> underlier -> security -> fundType all = FundProductTypeEnum -> MutualFund)
			or economicTerms -> payout -> optionPayout -> underlier -> security -> securityType all = SecurityTypeEnum -> Warrant
	      )
		// qualifies that an option style is defined and that no feature other than averaging exists
		and	(economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise exists
			or economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> europeanExercise exists
			or economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> bermudaExercise exists)
		and (economicTerms -> payout -> optionPayout -> feature is absent
			or economicTerms -> payout -> optionPayout -> feature -> averagingRateFeature only exists)

func Qualify_IndexVanillaOption: <"Qualifies a product as a plain vanilla Index Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) An option product for which the underlier is an index, which could be an index with any underlying type 2) No special option feature exists other than option averaging.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	[synonym ISDA_Taxonomy_v1 value "EquityOption_PriceReturnBasicPerformance_Index"]
	[synonym ISDA_Taxonomy_v2 value "EquityOption_PriceReturnBasicPerformance_Index"]
	assign-output is_product:
	    // qualifies that  only the option payout or option payout and cashflow (for the premium) exist and all other payouts are absent
	 	(economicTerms -> payout -> optionPayout only exists
			or (economicTerms -> payout -> optionPayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies that the the underlier is an index
		 and economicTerms -> payout -> optionPayout -> underlier -> index exists

		// qualifies that an option style is defined and that no feature other than averaging exists
		and	(economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise exists
			or economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> europeanExercise exists
			or economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> bermudaExercise exists)
		and (economicTerms -> payout -> optionPayout -> feature is absent
			or economicTerms -> payout -> optionPayout -> feature -> averagingRateFeature only exists)

func Qualify_InterestRate_IRSwap_FixedFloat: <"Qualifies a product as a Fixed-Float Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and more than one payment, 2) without inflation features or cross-currency features or 'zero coupon' features, and 3) where the floating leg is not based on an OIS index.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
        [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFloat"]

	alias floatingRateIndex:
		economicTerms -> payout -> interestRatePayout  -> rateSpecification -> floatingRate -> rateOption ->floatingRateIndex

	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one floating leg (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
	    and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both)
			and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// qualifies product as not having cross-currency features
		and economicTerms -> payout -> interestRatePayout -> principalExchanges is absent

		// qualifies product as not having the 'zero coupon' feature
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period any <> PeriodExtendedEnum -> T

		// qualifies product as not having an OIS index in the floating rate index
		and floatingRateIndex all <> FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> OIS
		and floatingRateIndex all <> FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND_SwapMarker
		and floatingRateIndex all <> FloatingRateIndexEnum -> CAD_CORRA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> CNY_Shibor_OIS_Compounding
		and floatingRateIndex all <> FloatingRateIndexEnum -> COP_IBR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> DKK_DKKOIS_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_4_15_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND_Bloomberg
		and floatingRateIndex all <> FloatingRateIndexEnum -> EUR_EURONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> GBP_SONIA_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> GBP_SONIA_OIS_4_15_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> HKD_HONIX_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> INR_MIBOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> INR_MITOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> JPY_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> JPY_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> JPY_OIS_3_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> JPY_TONA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> NZD_NZIONA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> PLN_POLONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> RUB_RUONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> SEK_SIOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> SGD_SONAR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> SGD_SONAR_OIS_VWAP_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_Federal_Funds_H_15_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_11_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_11_00_LON_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_11_00_NY_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_3_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_3_00_NY_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum -> USD_OIS_4_00_TRADITION

func Qualify_InterestRate_IRSwap_FixedFixed: <"Qualifies a product as a Fixed-Fixed Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two fixed legs and more than one payment and 2) without inflation features or cross-currency features but could have 'zero coupon' features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFixed"]
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFixed"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	((economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists))

		// qualifies product as an Interest Rate Product with two fixed legs (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 2

		// qualifies product as not having cross-currency features
		and economicTerms -> payout -> interestRatePayout -> principalExchanges is absent

func Qualify_InterestRate_IRSwap_Basis: <"Qualifies a product as a Basis (Float-Float) Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two floating legs and more than one payment, 2) without inflation features or cross-currency features but could have 'zero coupon' features, and 3) where neither floating leg is  based on an OIS index.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Basis"]
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Basis"]

	alias floatingRateIndex:
		economicTerms -> payout -> interestRatePayout  -> rateSpecification -> floatingRate -> rateOption ->floatingRateIndex

	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with two floating legs (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2

		// qualifies product as not having cross-currency features
		and economicTerms -> payout -> interestRatePayout -> principalExchanges is absent
	
		// qualifies product as not having an OIS index in the floating leg
		and floatingRateIndex all <> FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> OIS
		and floatingRateIndex all <> FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND_SwapMarker
		and floatingRateIndex all <> FloatingRateIndexEnum-> CAD_CORRA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> CNY_Shibor_OIS_Compounding
		and floatingRateIndex all <> FloatingRateIndexEnum-> COP_IBR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> DKK_DKKOIS_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_4_15_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND_Bloomberg
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EURONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_OIS_4_15_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> HKD_HONIX_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> INR_MIBOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> INR_MITOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_OIS_3_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_TONA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> NZD_NZIONA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> PLN_POLONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> RUB_RUONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> SEK_SIOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> SGD_SONAR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> SGD_SONAR_OIS_VWAP_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_Federal_Funds_H_15_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_LON_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_NY_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_3_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_3_00_NY_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_4_00_TRADITION

func Qualify_InterestRate_IRSwap_FixedFloat_ZeroCoupon: <"Qualifies a product as a Fixed-Float Zero Coupon Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and more than one payment, 2) without inflation features or cross-currency features, and 3) where the floating leg is not based on an OIS index.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFloat_ZeroCoupon"]

	alias floatingRateIndex:
		economicTerms -> payout -> interestRatePayout  -> rateSpecification -> floatingRate -> rateOption ->floatingRateIndex

	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one floating leg (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
	    and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both) therefore, given all the constraints, it's qualified as a Fixed-Float IR Swap
		and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// qualifies product as not having cross-currency features
		and economicTerms -> payout -> interestRatePayout -> principalExchanges is absent
	
		// qualifies product as having the 'zero coupon' feature
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier all = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period all = PeriodExtendedEnum -> T

		// qualifies product as not having an OIS index in the floating rate index
		and floatingRateIndex all <> FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> OIS
		and floatingRateIndex all <> FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND_SwapMarker
		and floatingRateIndex all <> FloatingRateIndexEnum-> CAD_CORRA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> CNY_Shibor_OIS_Compounding
		and floatingRateIndex all <> FloatingRateIndexEnum-> COP_IBR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> DKK_DKKOIS_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_4_15_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND_Bloomberg
		and floatingRateIndex all <> FloatingRateIndexEnum-> EUR_EURONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> GBP_SONIA_OIS_4_15_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> HKD_HONIX_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> INR_MIBOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> INR_MITOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_OIS_11_00_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_OIS_3_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> JPY_TONA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> NZD_NZIONA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> PLN_POLONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> RUB_RUONIA_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> SEK_SIOR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> SGD_SONAR_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> SGD_SONAR_OIS_VWAP_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_Federal_Funds_H_15_OIS_COMPOUND
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_LON_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_NY_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_11_00_TRADITION
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_3_00_BGCANTOR
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_3_00_NY_ICAP
		and floatingRateIndex all <> FloatingRateIndexEnum-> USD_OIS_4_00_TRADITION

func Qualify_InterestRate_IRSwap_FixedFloat_OIS: <"Qualifies a product as a Fixed-Float OIS Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and more than one payment and where the floating leg is based on an OIS index, 2) without inflation features or cross-currency features, and 3) could include 'zero coupon' features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFloat_OIS"]

	alias floatingRateIndex:
		economicTerms -> payout -> interestRatePayout  -> rateSpecification -> floatingRate -> rateOption ->floatingRateIndex

	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one floating leg (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
	    and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both) therefore, given all the constraints, it's qualified as a Fixed-Float IR Swap
		and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// qualifies product as not having cross-currency features
		and economicTerms -> payout -> interestRatePayout -> principalExchanges is absent
	
		// qualifies product as having a floating rate leg with an OIS index
		and (floatingRateIndex all = FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> OIS
			or floatingRateIndex all = FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND_SwapMarker
			or floatingRateIndex all = FloatingRateIndexEnum-> CAD_CORRA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> CNY_Shibor_OIS_Compounding
			or floatingRateIndex all = FloatingRateIndexEnum-> COP_IBR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> DKK_DKKOIS_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_BGCANTOR
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_11_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_4_15_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND_Bloomberg
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EURONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_OIS_4_15_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> HKD_HONIX_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> INR_MIBOR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> INR_MITOR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_OIS_11_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_OIS_11_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_OIS_3_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_TONA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> NZD_NZIONA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> PLN_POLONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> RUB_RUONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> SEK_SIOR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> SGD_SONAR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> SGD_SONAR_OIS_VWAP_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_Federal_Funds_H_15_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_BGCANTOR
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_LON_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_NY_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_3_00_BGCANTOR
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_3_00_NY_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_4_00_TRADITION)

func Qualify_InterestRate_IRSwap_Basis_OIS: <"Qualifies a product as a Basis (Fixed-Float) OIS Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two floating legs and more than one payment and where one or both the floating leg is based on an OIS index, 2) without inflation features or cross-currency features, and 3) could include 'zero coupon' features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Basis"]

	alias floatingRateIndex:
		economicTerms -> payout -> interestRatePayout  -> rateSpecification -> floatingRate -> rateOption ->floatingRateIndex

	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with two floating legs (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both) therefore, given all the constraints, it's qualified as a Fixed-Float IR Swap
		and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// qualifies product as not having cross-currency features
		and economicTerms -> payout -> interestRatePayout -> principalExchanges is absent
	
		// qualifies product as having a floating rate leg with an OIS index
		and (floatingRateIndex all = FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> OIS
			or floatingRateIndex all = FloatingRateIndexEnum-> AUD_AONIA_OIS_COMPOUND_SwapMarker
			or floatingRateIndex all = FloatingRateIndexEnum-> CAD_CORRA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> CNY_Shibor_OIS_Compounding
			or floatingRateIndex all = FloatingRateIndexEnum-> COP_IBR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> DKK_DKKOIS_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_BGCANTOR
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_10_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_11_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_4_15_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EONIA_OIS_COMPOUND_Bloomberg
			or floatingRateIndex all = FloatingRateIndexEnum-> EUR_EURONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_OIS_11_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> GBP_SONIA_OIS_4_15_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> HKD_HONIX_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> INR_MIBOR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> INR_MITOR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_OIS_11_00_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_OIS_11_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_OIS_3_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> JPY_TONA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> NZD_NZIONA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> PLN_POLONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> RUB_RUONIA_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> SEK_SIOR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> SGD_SONAR_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> SGD_SONAR_OIS_VWAP_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_Federal_Funds_H_15_OIS_COMPOUND
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_BGCANTOR
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_LON_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_NY_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_11_00_TRADITION
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_3_00_BGCANTOR
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_3_00_NY_ICAP
			or floatingRateIndex all = FloatingRateIndexEnum-> USD_OIS_4_00_TRADITION)

func Qualify_InterestRate_CrossCurrency_FixedFloat: <"Qualifies a product as a Fixed-Float Cross-Currency Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and a cross-currency feature and more than one payment, 2) without inflation features and 3) could be a 'zero coupon' and the floating leg index could be OIS or non-OIS.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFloat"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

	 	// qualifies product as a having a fixed and floating leg, and by elimination, given the count constraint above, no inflation legs
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
	    and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both) therefore, given all the constraints, it's qualified as a Fixed-Float IR Swap
		and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// and has CrossCurrency features in one or both legs
		and economicTerms -> payout -> interestRatePayout -> principalExchanges exists

func Qualify_InterestRate_CrossCurrency_Basis: <"Qualifies a product as a Basis (Float-Float) Cross Currency Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two floating legs, a cross-currency feature in one or both legs, and more than one payment, 2) but without inflation features, and 3) could be a 'zero coupon' and floating leg index could be OIS or non-OIS.">

	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_Basis"]
		[synonym ISDA_Taxonomy_v2 value "InterestRate_CrossCurrency_Basis"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one floating leg (by elimination not inflation)
		and	economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2

		// qualifies that the product and has cross-currency features in one or both legs
		and economicTerms -> payout -> interestRatePayout -> principalExchanges exists

func Qualify_InterestRate_CrossCurrency_FixedFixed: <"Qualifies a product as a Fixed-Fixed Cross-Currency Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two fixed legs and a cross-currency feature and more than one payment, 2) without inflation features and 3) could be a 'zero coupon'">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFixed"]
		[synonym ISDA_Taxonomy_v2 value "InterestRate_CrossCurrency_FixedFixed"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with two fixed legs (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 2

		// qualifies product as having a cross-currency feature in one or more legs
		and economicTerms -> payout -> interestRatePayout -> principalExchanges exists

func Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year: <"Qualifies a product as a Fixed-Float Annual Reset Inflation Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one inflation rate leg and more than one payment, and 2) without cross-currency features or 'zero coupon' features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one inflation rate leg (by elimination not floating interest)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
	    and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both)
		and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// qualifies product as not having the 'zero coupon' feature
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period any <> PeriodExtendedEnum -> T

		// qualifies product as having an annual payment frequency
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier all = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period all = PeriodExtendedEnum -> Y

func Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon: <"Qualifies a product as a Fixed-Float Inflation Swap with a single accrual period based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one inflation rate leg and more than one payment, and 2) without cross-currency features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one inflation rate leg (by elimination not floating interest)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1

		// qualifies product as having the 'zero coupon' feature
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier all = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period all = PeriodExtendedEnum -> T

func Qualify_InterestRate_InflationSwap_Basis_YearOn_Year: <"Qualifies a product as a Basis (Float-Float) Annual Reset Inflation Swap based on the economic terms and the following criteria: 1) An interest rate product with one floating interest rate leg and one inflation rate leg and more than one payment, and 2) without cross-currency features or 'zero coupon' features.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one inflation rate leg and one floating interest rate leg (by elimination not fixed interest)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1

		// qualifies product as having more than a single payment in each leg (note that the InterestRatePayout data type has a condition that allows for population of paymentDates or paymentDate, but not both)
		and economicTerms -> payout -> interestRatePayout ->paymentDates count = 2

		// qualifies product as not having the 'zero coupon' feature
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period any <> PeriodExtendedEnum -> T

		// qualifies product as having an annual payment frequency
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier all = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period all = PeriodExtendedEnum -> Y

func Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon: <"Qualifies a product as a Fixed-Float Inflation Swap with a single accrual period based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one inflation rate leg and more than one payment, and 2) without cross-currency features.">

	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one inflation rate leg (by elimination not floating interest)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1

		// qualifies product as having the 'zero coupon' feature
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier all = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period all = PeriodExtendedEnum -> T

func Qualify_InterestRate_Fra: <"Qualifies the product as a Floating Rate Agreement based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg, each of which has a single payment, and 2) could include a cross-currency feature, and the floating rate leg could be based OIS index.">

	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: result boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_Fra"]
		[synonym ISDA_Taxonomy_v1 value "InterestRate_Fra"]

	assign-output result:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate Product with one fixed and one floating leg (by elimination not inflation)
		and economicTerms -> payout -> interestRatePayout count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
	    and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1

		// qualifies product as having a single payment in each leg (the complex type paymentDate is used when there is a single payment)
		and economicTerms -> payout -> interestRatePayout -> paymentDate count = 2

func Qualify_InterestRate_CapFloor:	<"Qualifies a product as an interest rate cap, interest rate floor, or an interest rate collar based on the economic terms and the following criteria: 1) An interest rate product with one one leg that includes a cap and/or a floor.">

	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CapFloor"]
		[synonym ISDA_Taxonomy_v2 value "InterestRate_CapFloor"]
	assign-output is_product:
		// qualifies that either only the interest rate payout exists, or the interest rate payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> interestRatePayout only exists
			or (economicTerms -> payout -> interestRatePayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies product as an Interest Rate product with a single leg
		and economicTerms -> payout -> interestRatePayout count = 1

		// qualifies the product as having a cap and/or floor in the interestRatePayout
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> capRateSchedule exists
		or economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floorRateSchedule exists

func Qualify_InterestRate_Option_Swaption: <"Qualifies a product as a Swaption that can be exercised into an Interest Rate Swap, which could be any type of interest rate product with two legs based on the economic terms.">
    [qualification Product]
    inputs: economicTerms EconomicTerms (1..1)
    output: is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_Option_Swaption"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_Option_Swaption"]
    assign-output is_product:
		// qualifies that either only the option rate payout exists, or the option payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> optionPayout only exists
            or (economicTerms -> payout -> optionPayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies that the underlier is an interest rate product with two legs
		and	economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2

func Qualify_InterestRate_Option_DebtOption: <"Qualifies a product as a Option that can be exercised into an Debt Product based on the economic terms.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_Option_DebtOption"]
		[synonym ISDA_Taxonomy_v2 value "InterestRate_Option_DebtOption"]
	alias optionPayout: economicTerms -> payout -> optionPayout
	assign-output is_product:
		// qualifies that either only the option rate payout exists, or the option payout exists and the cashflow exists and all other payouts are absent
	 	(economicTerms -> payout -> optionPayout only exists
            or (economicTerms -> payout -> optionPayout,  economicTerms -> payout -> cashflow) only exists)

		// qualifies the underlyer of the option as a debt security
		and optionPayout -> underlier -> security -> securityType only-element = SecurityTypeEnum -> Debt

func Qualify_ForeignExchange_Spot_Forward: <"Qualifies a product as Foreign Exchange based on economic terms, which is defined as an agreement to buy one currency against the delivery of another currency at a rate set on the trade date for settlement on a specified date in the future.  Dependent on conventions specific to local markets the product could be considered either Spot or Forward.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_Forward"]
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_Spot"]
		[synonym ISDA_Taxonomy_v2 value "ForeignExchange_Forward"]
		[synonym ISDA_Taxonomy_v2 value "ForeignExchange_Spot"]
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> underlier -> foreignExchange only exists
		and economicTerms -> payout -> forwardPayout -> underlier -> foreignExchange count = 1
		and economicTerms -> payout -> forwardPayout -> settlementTerms -> cashSettlementTerms is absent

func Qualify_ForeignExchange_Swap: <"Qualifies a product as Foreign Exchange Swap based on economic terms, which is defined as a contract in which one party borrows one currency from, and simultaneously lends another to, the second party. Each party uses the repayment obligation to its counterparty as collateral and the amount of repayment is fixed at the FX forward rate as of the start of the contract.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> underlier -> foreignExchange only exists
		and economicTerms -> payout -> forwardPayout -> underlier -> foreignExchange count = 2
		and economicTerms -> payout -> forwardPayout -> settlementTerms -> cashSettlementTerms is absent

func Qualify_ForeignExchange_NDF: <"Qualifies a product as Foreign Exchange Non-Deliverable Forward based on economic terms, which is defined as a Forward transaction where the notional amount of one of the currencies (the “reference currency”) is converted into the other currency (the “settlement currency”) at a spot foreign exchange rate that is observed on a valuation date prior to the settlement date, and a single net payment in the settlement currency is made on the settlement date. No payment or account transfer takes place in the reference currency.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_NDF"]
		[synonym ISDA_Taxonomy_v2 value "ForeignExchange_NDF"]
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> underlier -> foreignExchange only exists
		and economicTerms -> payout -> forwardPayout -> underlier -> foreignExchange count = 1
		and economicTerms -> payout -> forwardPayout -> settlementTerms -> cashSettlementTerms exists

func Qualify_ForeignExchange_VanillaOption: <"Qualifies a product as FX Plain Vanilla Option based on economic terms, which is defined as one where 1) exercise style is American or European style only, and 2) does not contain any feature like Forward Starting Strike or Performance payout.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_VanillaOption"]
		[synonym ISDA_Taxonomy_v2 value "ForeignExchange_VanillaOption"]
	assign-output is_product:
		economicTerms -> payout -> optionPayout exists
		and economicTerms -> payout -> optionPayout -> underlier -> foreignExchange only exists
		and	(economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise exists
			or economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> europeanExercise exists)
		and (economicTerms -> payout -> optionPayout -> feature is absent
			or economicTerms -> payout -> optionPayout -> feature -> averagingRateFeature only exists)

func Qualify_RepurchaseAgreement:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> securityPayout -> securityLeg count >= 1 and
		economicTerms -> payout -> interestRatePayout count = 1

func Qualify_Commodity_Swap_FixedFloat: <"Qualifies a product as a Fixed Float Commodity Swap.  The determination of the qualification is based on the economic terms and the following criteria: 1) One Floating Leg represented by the CommodityPayout, with an underlier that is a commodity, 2) One Fixed Leg represented by the FixedForwardPaayoute, and 3) there are no other payout types.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		((economicTerms -> payout -> commodityPayout, economicTerms -> payout -> fixedForwardPayout) only exists
		    or (economicTerms -> payout -> commodityPayout, economicTerms -> payout -> fixedForwardPayout, economicTerms -> payout -> cashflow) only exists)
		and economicTerms -> payout -> commodityPayout -> underlier -> commodity exists

func Qualify_Commodity_Swap_Basis: <"Qualifies a product as a Basis Commodity Swap.  The determination of the qualification is based on the economic terms and the following criteria: 1) Two Floating Legs represented by the CommodityPayout, with an underlier that is a commodity, and 2) there are no other payout types.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
	    (economicTerms -> payout -> commodityPayout only exists
	        or (economicTerms -> payout -> commodityPayout, economicTerms -> payout -> cashflow) only exists)
		and economicTerms -> payout -> commodityPayout count = 2
		and economicTerms -> payout -> commodityPayout -> underlier -> commodity count = 2

func Qualify_Commodity_Option:
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		(economicTerms -> payout -> optionPayout only exists
		    or (economicTerms -> payout -> optionPayout, economicTerms -> payout -> cashflow) only exists)
		and economicTerms -> payout -> optionPayout -> underlier -> commodity exists

func Qualify_SecurityLendingAgreement: <"Qualifies a product as a Security Loan.">
	[qualification Product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> securityFinancePayout exists

namespace cdm.product.asset : <"Product concepts applicable to specific asset classes.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.rates.*

import cdm.observable.asset.*

import cdm.product.template.*
import cdm.product.common.schedule.*
import cdm.legalagreement.common.*

func ForwardFX:
	inputs:
		forwardPayout ForwardPayout(1..1)
	output: result ForeignExchange (1..1)
	assign-output result: forwardPayout -> underlier -> foreignExchange

func FixedAmount: <"2006 ISDA Definition Article 5 Section 5.1. Calculation of a Fixed Amount: The Fixed Amount payable by a party on a Payment Date will be: (a) if an amount is specified for the Swap Transaction as the Fixed Amount payable by that party for that Payment Date or for the related Calculation Period, that amount; or (b) if an amount is not specified for the Swap Transaction as the Fixed Amount payable by that party for that Payment Date or for the related Calculation Period, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Fixed Amount = Calculation Amount × Fixed Rate × Day Count Fraction.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		fixedRate number (1..1)
		quantity Quantity (1..1)
		date date (1..1)

	output:
		fixedAmount number (1..1)

	alias calculationAmount:
		quantity -> amount

	alias dayCountFraction:
		DayCountFraction(interestRatePayout, interestRatePayout -> dayCountFraction, date)

	assign-output fixedAmount:
		calculationAmount * fixedRate * dayCountFraction

func FloatingAmount: <"2006 ISDA Definition Article 6 Section 6.1. Calculation of a Floating Amount: Subject to the provisions of Section 6.4 (Negative Interest Rates), the Floating Amount payable by a party on a Payment Date will be: (a) if Compounding is not specified for the Swap Transaction or that party, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Floating Amount = Calculation Amount × Floating Rate + Spread × Floating Rate Day Count Fraction (b) if 'Compounding' is specified to be applicable to the Swap Transaction or that party and 'Flat Compounding' is not specified, an amount equal to the sum of the Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period; or (c) if 'Flat Compounding' is specified to be applicable to the Swap Transaction or that party, an amount equal to the sum of the Basic Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period plus the sum of the Additional Compounding Period Amounts for each such Compounding Period.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		spread number (1..1)
		rate number (1..1)
		quantity Quantity (1..1)
		date date (1..1)

	output:
	    floatingAmount number (1..1)

	alias calculationAmount:
	    quantity -> amount

	alias dayCountFraction:
	    DayCountFraction(interestRatePayout, interestRatePayout -> dayCountFraction, date)

	assign-output floatingAmount:
	    calculationAmount * (rate + spread) * dayCountFraction

func DayCountFraction: <"A description of inputs and outputs for all day count fraction calculations">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		dayCountFractionEnum DayCountFractionEnum (1..1)
		date date (1..1)
	output:
		result number (1..1)

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> _1_1): <"2006 ISDA Definition Article 4 section 4.16(a):	if '1/1' is specified, 1;">
	[calculation]
	assign-output result: 1.0

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_ACT_ISDA): <"'2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias calculationPeriod: CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)
	alias daysInLeapYearPeriod: <"The number of days of the period that fall in a leap year.">
		calculationPeriod -> daysInLeapYearPeriod
	alias daysInNonLeapPeriod: <"The difference between the total days in the period and the days in leap year period">
		(calculationPeriod -> daysInPeriod) - (calculationPeriod -> daysInLeapYearPeriod)
	assign-output result:
		(daysInNonLeapPeriod / 365) + (daysInLeapYearPeriod / 366)

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_ACT_ICMA): <"2006 ISDA Definition Article 4 section 4.16(c):	(c)	if 'Actual/Actual (ICMA)' or 'Act/Act (ICMA)' is specified, a fraction equal to 'number of days accrued/number of days in year', as such terms are used in Rule 251 of the statutes, by-laws, rules and recommendations of the International Capital Market Association (the 'ICMA Rule Book'), calculated in accordance with Rule 251 of the ICMA Rule Book as applied to non US dollar denominated straight and convertible bonds issued after December 31, 1998, as though the interest coupon on a bond were being calculated for a coupon period corresponding to the Calculation Period or Compounding Period in respect of which payment is being made;">
	[calculation]
	alias calculationPeriod: CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)
	alias daysInPeriod: <"Number of calendar in the calculation period">
		calculationPeriod -> daysInPeriod
	alias periodsInYear: <"Number of calculation periods in a year">
		PeriodsInYear(interestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency)
	assign-output result:
		daysInPeriod / (daysInPeriod * periodsInYear)

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_365_FIXED): <"'2006 ISDA Definition Article 4 section 4.16(d): If 'Actual/365 (Fixed)', 'Act/365 (Fixed)', 'A/365 (Fixed)' or 'A/365F' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365. ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias daysInPeriod: <"Number of calendar in the calculation period">
		CalculationPeriod(interestRatePayout -> calculationPeriodDates, date) -> daysInPeriod
	assign-output result:
		daysInPeriod / 365

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_360): <"'2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias daysInPeriod: <"Number of calendar in the calculation period">
		CalculationPeriod(interestRatePayout -> calculationPeriodDates, date ) -> daysInPeriod
	assign-output result:
		daysInPeriod / 360

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> _30_360): <"2006 ISDA Definition Article 4 section 4.16(f): if '30/360', '360/360' or 'Bond Basis' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows:[[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360.">
	[calculation]
	alias calculationPeriod:
		CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)

	alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">
		calculationPeriod -> startDate -> year

	alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">
		calculationPeriod -> endDate -> year

	alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">
		calculationPeriod -> startDate -> month

	alias endMonth: <"The calendar month, expressed as number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">
		calculationPeriod -> endDate -> month

	alias endDay: <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31 and D2, is greater than 29, in which case D2 will be 30">
		if calculationPeriod -> startDate -> day > 29 then Min(calculationPeriod -> endDate -> day, 30) else calculationPeriod -> endDate -> day

	alias startDay: <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case, will be 30">
		Min(calculationPeriod -> startDate -> day, 30)
	assign-output result:
		(360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360): <"'2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias calculationPeriod:
		CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)

	alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">
		calculationPeriod -> startDate -> year

	alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">
		calculationPeriod -> endDate -> year

	alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">
		calculationPeriod -> startDate -> month

	alias endMonth: <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">
		calculationPeriod -> endDate -> month

	alias endDay: <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30">
		Min(calculationPeriod -> endDate -> day, 30)

	alias startDay: <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30">
		Min(calculationPeriod -> startDate -> day, 30)
	assign-output result:
		(360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360_ISDA): <"2006 ISDA Definition Article 4 section 4.16(h): if '30E/360 (ISDA)' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows: [[360 × (Y2 - Y1)]+[30 × (M2 - M1)] +(D2 - D1)]/360 ">
	[calculation]

	alias calculationPeriod:
		CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)

	alias interestRatePayoutTerminationDate:
		ResolveAdjustableDate (interestRatePayout -> calculationPeriodDates -> terminationDate)

	alias startDateIsInLeapYear:
		IsLeapYear(calculationPeriod -> startDate -> year)

	alias endDateIsInLeapYear:
		IsLeapYear(calculationPeriod -> endDate -> year)

	alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">
		calculationPeriod -> startDate -> year

	alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">
		calculationPeriod -> endDate -> year

	alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">
		calculationPeriod -> startDate -> month

	alias endMonth: <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">
		calculationPeriod -> endDate -> month

	alias startDay:
		if startDateIsInLeapYear = False and calculationPeriod -> startDate -> month = 2 and calculationPeriod -> startDate -> day = 28
			or startDateIsInLeapYear = True and calculationPeriod -> startDate -> month = 2 and calculationPeriod -> startDate -> day = 29
			or calculationPeriod -> startDate -> day = 31
		then 30 else calculationPeriod -> endDate -> day

	alias endDay:
		if endDateIsInLeapYear = False and calculationPeriod -> endDate -> month = 2 and calculationPeriod -> endDate -> day = 28
			or endDateIsInLeapYear = True and calculationPeriod -> endDate -> month = 2 and calculationPeriod -> endDate -> day = 29
			or calculationPeriod -> endDate -> day = 31
			or calculationPeriod -> endDate = interestRatePayoutTerminationDate
		then 30 else calculationPeriod -> endDate -> day
	assign-output result:
		(360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func DayCountFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_365L): <"The actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365 (or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366). ">
	[calculation]
	alias calculationPeriod:
		CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)

	alias endDateIsInLeapYear:
		IsLeapYear(calculationPeriod -> endDate -> year)

	alias daysInPeriod: <"The actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made ">
		calculationPeriod -> daysInPeriod

	alias daysInYear: <"365 or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366. ">
		if (endDateIsInLeapYear = True) then 366 else 365

	assign-output result:
		daysInPeriod / daysInYear

func ResolveRateIndex: <"The function to specify that the floating rate index enumeration will be expressed as a number once the rate is observed.">
	inputs: index FloatingRateIndexEnum (1..1)
	output: rate number (1..1)

func ResolveEquityPeriodStartPrice: <"Resolves the price from the end of the previous period. If first period, then take the initial price.">
	inputs:
		equityPayout EquityPayout (1..1)
		priceQuantity PriceQuantity (0..*)
		date date (1..1)
	output:
		price Price (1..1)

	alias priceReturnTerms:
		equityPayout -> priceReturnTerms

	alias calculationPeriod:
		CalculationPeriod(equityPayout -> calculationPeriodDates, date)

	assign-output price: <"The initial price is taken from the original contract when Resetting for the first time i.e. when the number of updated contracts is one.">
		if calculationPeriod -> isFirstPeriod
		then ResolveEquityInitialPrice( priceQuantity ) 
		else priceReturnTerms -> valuationPriceInterim -> price 

func ResolveEquityPeriodEndPrice:
	inputs:
		equityPayout EquityPayout (1..1)
		date date (1..1)
	output:
		price number (1..1)

	alias priceReturnTerms:
		equityPayout -> priceReturnTerms

	alias calculationPeriod:
		CalculationPeriod(equityPayout -> calculationPeriodDates, date)

	assign-output price: <"If the last period, take the price from the Valuation Price Final, otherwise from Valuation Price Interim.">
		if calculationPeriod -> isLastPeriod
		then priceReturnTerms -> valuationPriceFinal -> price -> amount
		else priceReturnTerms -> valuationPriceInterim -> price -> amount

func ResolveEquityInitialPrice:
	inputs:
		priceQuantity PriceQuantity (0..*)

	output:
		initialPrice Price (1..1)

func DividendCashSettlementAmount: <"Based on the following legal text: means, in respect of a Dividend Period and the related Dividend Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent for such Dividend Period to which the Dividend Cash Settlement Amount relates, pursuant to the following formula: Dividend Cash Settlement Amount = Record Amount × Number Of Securities.">

	inputs:
		numberOfSecurities number (1..1)
		declaredDividend number (1..1)

	output:
		dividendCashSettlementAmount number (1..1)

	assign-output dividendCashSettlementAmount:
		declaredDividend * numberOfSecurities



// =====================================================================
//
// Fixede Amount Calculation definitions
//
// these functions return the calculated fixed amount
//
// ======================================================================

func FixedAmountEnhanced: <"Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
	//	fixedRate number (1..1)
	//	quantity Quantity (1..1)
		calculationPeriodStartDate date (1..1)
	output:
		fixedAmount number (1..1)

	alias calcPeriod :  CalculationPeriod(interestRatePayout -> calculationPeriodDates, calculationPeriodStartDate)
	alias calculationPeriod : InitCalculationPeriodBase(calcPeriod)
	assign-output fixedAmount : FixedAmounCalculationNew(interestRatePayout, calculationPeriod)



// TODO: should this be enhanced to support spreads and do spread-exclusive calculations for compounding?
func FixedAmounCalculationNew: <"Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)

		calculationPeriod CalculationPeriodBase (1..1)
	output:
		fixedAmount number (1..1)

	alias fixedRate : LookupFixedRate(interestRatePayout, calculationPeriod)
	alias calculationAmount : LookupNotionalAmount(interestRatePayout,calculationPeriod)
	alias yearFraction:
		DayCountFraction(interestRatePayout, interestRatePayout -> dayCountFraction, calculationPeriod->adjustedStartDate)
	assign-output fixedAmount:
		calculationAmount->multiplier * fixedRate * yearFraction


func LookupFixedRate: <"Look up the fixed rate for a calculation period">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which you want the spread">
	output:
	    fixedRate number(0..1)  <"the fixed rate value value for the period">
	alias	startDate : calculationPeriod->adjustedStartDate
	assign-output
		fixedRate: LookupRateScheduleAmount(interestRatePayout->rateSpecification -> fixedRate->rateSchedule, startDate)


// =====================================================================
//
// Floating Rate Amount Calculation definitions
//
// these functions perform the floating amount calculations
//
// ======================================================================

func FloatingAmountEnhanced: <"2006 ISDA Definition Article 6 Section 6.1. Calculation of a Floating Amount: Subject to the provisions of Section 6.4 (Negative Interest Rates), the Floating Amount payable by a party on a Payment Date will be: (a) if Compounding is not specified for the Swap Transaction or that party, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Floating Amount = Calculation Amount  Floating Rate + Spread  Floating Rate Day Count Fraction (b) if 'Compounding' is specified to be applicable to the Swap Transaction or that party and 'Flat Compounding' is not specified, an amount equal to the sum of the Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period; or (c) if 'Flat Compounding' is specified to be applicable to the Swap Transaction or that party, an amount equal to the sum of the Basic Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period plus the sum of the Additional Compounding Period Amounts for each such Compounding Period.   This enhanced version supports parameterized rate treatments, such as spread schedules, cap rate schedules, negative rate treatment, final rate rounding, etc.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"The interest rate poiyout for which the floating amount is to be computed">
		spread number (0..1)		<"This is ignored if provided and instead the spread is obtained from the interest rate payount ">
		rate number (0..1)			<"This is ignored and instead the rate is obtained by querying the IndexValueObservation function ">
		quantity Quantity (0..1)	<"This is ignored and instead the notional is determined by querying the noitonal schedule">
		calculationPeriodStartDate date (1..1)  <"The start date of the calculation period">
	output:
	    floatingAmount number (1..1)
	// determine the calculation period corresponding to the supplied end date
	alias calcPeriod :  CalculationPeriod(interestRatePayout -> calculationPeriodDates, calculationPeriodStartDate)
	//perform the floating amount calculation
	alias results : FloatingAmountCalculation(interestRatePayout, InitCalculationPeriodBase(calcPeriod), calcPeriod->isFirstPeriod)
	// record the results
	assign-output floatingAmount : results -> calculatedAmount


func FloatingAmountCalculation: <"Calculate a floating amount for a calculation period by determining the raw floating rate, applying any rate treatments, looking up the calculation period notional, then performing the multiplication of the notional, rate, and year fraction.  Floating amount calculations are described in the 2021 ISDA Definitions in Section 6 and 7.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"The interest rate stream for which the floating amount calculation is being done">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which the floating rate calculation is being done">
		isInitialPeriod boolean (1..1) <"Is this the initial calculation period?">
	output:
	    result FloatingAmountCalculationDetails(1..1) <"The details of the floating rate calculation, including raw rate, rate treatment details, notional, and calculated cashlow amount">

	//Get the floating rate before treatments
	alias rawFloatingRateDetails : DetermineFloatingRateReset(interestRatePayout, calculationPeriod)
	alias rawFloatingRate :	rawFloatingRateDetails->floatingRate

	//apply rate treatments/conditioning
	alias conditioningParameters : GetFloatingRateConditioningParameters(interestRatePayout, calculationPeriod)
	// TOOD: implement initial rate
	alias conditioningDetails  : ApplyFloatingRateConditioning(conditioningParameters, rawFloatingRate, calculationPeriod, isInitialPeriod)
	alias appliedRate : conditioningDetails-> conditionedRate
	alias spreadExclusiveRate : conditioningDetails->spreadExclusiveRate

	//determine notional, year fraction, and perform the final calculation
	alias notional : LookupNotionalAmount(interestRatePayout, calculationPeriod)
	alias dcf : interestRatePayout->dayCountFraction
	alias yearFraction : DayCountFraction(interestRatePayout, dcf, calculationPeriod->adjustedStartDate)
	alias annualAccrual : notional->multiplier  * appliedRate
	alias notionalAccrual : notional->multiplier * yearFraction
	alias cashflow : notionalAccrual * appliedRate
	alias spreadExclusiveCashflow : notionalAccrual * spreadExclusiveRate

// record results
	assign-output result->calculationPeriod : calculationPeriod
	assign-output result->calculationPeriodNotionalAmount : notional
	assign-output result->floatingRate : rawFloatingRateDetails
	assign-output result->conditioningDetails : conditioningDetails
	assign-output result->appliedRate : appliedRate
	//assign-output result->notionalAmount : notional->amount
	assign-output result->yearFraction : yearFraction
	assign-output result->calculatedAmount : cashflow
	assign-output result->spreadExclusiveCalculatedAMount : spreadExclusiveCashflow




//-------------------------------------------------------
// The following functions determine the type of rate and what to do for each
//-------------------------------------------------------

func DetermineFloatingRateReset: <"Get the value of a floating rate by either observing it directly or performing a rate calculation.  This function works differently depending on the rate category and style, as described in the 2021 ISDA Definitions, Section 6.6.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)	<"Floating rate stream definition">
		calcPeriod CalculationPeriodBase(1..1)	<"The calculation period for which you want the rate">
	output:
		floatingRate FloatingRateSettingDetails(1..1)	<"Details of the rate observation/calculation corresonding to the supplied rate definition and calculation period">

	// figure out the characteristics of the rate
	alias  rateDef : interestRatePayout->rateSpecification->floatingRate
	alias	processingType : GetFloatingRateProcessingType(rateDef)			// get a processing category that will be used to dermine how to process the rate, based on the rate category, style, and calculation method

	// perform the relevant operation (look up a term rate or do the rate calculation for a calculated rate)
	assign-output floatingRate : ProcessFloatingRateReset(interestRatePayout, calcPeriod, processingType)


func GetFloatingRateProcessingType: <" Get a classification of  the floating rate is processed. This is based on FRO category, style, and calculation method, as described in the 2021 ISDA Definitions Section 6.6.  The categorization information is obtained from the FRO metadata. ">
[calculation]
	inputs:
		rateDef FloatingRateSpecification(1..1) <"Specification details of the floating rate">
	output:
		processingType FloatingRateIndexProcessingTypeEnum(1..1)<" The processing category for the rate ">

	// is it a modular calculated rate?
	alias	isCalculatedRate : rateDef->calculationParameters exists

	// look up the floating rate option definition from the metadata
	alias   floatingRateDefinition : RetrieveFloatingRateIndexMetadata(rateDef->rateOption->floatingRateIndex)
	alias 	calcDefaults: floatingRateDefinition->calculationDefaults
	alias 	category : calcDefaults->category
	alias 	idxStyle : calcDefaults->indexStyle
	alias 	method : calcDefaults->method

	alias   calcProcessingType : if (calcDefaults->indexStyle = FloatingRateIndexStyleEnum->CompoundedFRO and calcDefaults->method= FloatingRateIndexCalculationMethodEnum->OISCompound)
	                                        then FloatingRateIndexProcessingTypeEnum->OIS else
                             				if (idxStyle = FloatingRateIndexStyleEnum->AverageFRO and  calcDefaults->method= FloatingRateIndexCalculationMethodEnum->Average) then FloatingRateIndexProcessingTypeEnum->OVERNIGHTAVG
    alias   definitionProcessingType : if calcDefaults->category = FloatingRateIndexCategoryEnum->ScreenRate
                                                then  FloatingRateIndexProcessingTypeEnum->SCREEN
                                                else   calcProcessingType

    alias   processingCategory : if (isCalculatedRate=True) then FloatingRateIndexProcessingTypeEnum->MODULAR else
                                 					(if floatingRateDefinition->fro exists then definitionProcessingType
                                 						else FloatingRateIndexProcessingTypeEnum->SCREEN)
	// categorize the rates based on the floating rate specification in the payout and based on the FRO definition from the metadata and output the resulting category
	assign-output
		processingType : processingCategory



func ProcessFloatingRateReset: <"Entry point for the function that performs the floating rate resetting operation.  There are different variactions depending on the processing type (e.g. screen rate, OIS, modular calculated rate. ">
[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)	<"Floating rate stream definition">
		calcPeriod CalculationPeriodBase(1..1)	<"The calculation period for which you want the rate">
		processingType FloatingRateIndexProcessingTypeEnum(1..1)  <"The rate processing type (e.g. Screeen Rate, OIS); this drives how the resetting calculation is done. ">

	output:
		floatingRate FloatingRateSettingDetails(1..1)	<"Details of the rate observation/calculation">


func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->SCREEN): <"Evaulate the rate for a screen rate - call logic to determine how to observe the screen rate">
[calculation]
	// set up convenience aliases
	alias resetDates : interestRatePayout->resetDates			
	alias rateDef : interestRatePayout->rateSpecification->floatingRate

	assign-output 
		floatingRate: EvaluateScreenRate(rateDef, resetDates, calcPeriod)  // Call the screen rate evaluation logic


func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->MODULAR): <"Evaulate the rate for a modular calculated rate.  Call the calculated rate calculation logic to determine the value of the reset">
[calculation]
	// set up convenience aliases
	alias  rateDef : interestRatePayout->rateSpecification->floatingRate
	alias resetDates : interestRatePayout->resetDates
	alias dayCount : interestRatePayout->dayCountFraction
	alias fro : rateDef->rateOption
	alias calcParams : rateDef->calculationParameters

	// determine the prior calculation period corresponding to this period, in case needed.  (used for set-in-advance calculated rates and some fallback rates.)
	alias priorCalculationPeriod : InitCalculationPeriodBase(CalculationPeriod(interestRatePayout -> calculationPeriodDates, calcPeriod->adjustedStartDate))

// call the calculated rate evaulation logic 
assign-output 
	floatingRate :	EvaluateCalculatedRate(fro, calcParams,  resetDates, calcPeriod, priorCalculationPeriod, dayCount)	


func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->OIS): <"Evaulate the rate for an OIS calculated rate. Call the calculated rate calculation logic to determine the value of the reset.  See the 2021 ISDA Definitions Section 6.6.3">
[calculation]
// set up convenience aliases
	alias  rateDef : interestRatePayout->rateSpecification->floatingRate
	alias resetDates : interestRatePayout->resetDates
	alias dayCount : interestRatePayout->dayCountFraction
	alias fro : rateDef->rateOption
	// create a pseudo calculation parameters block to drive the OIS calculation
	alias calcParams : GetCalculatedFROCalculationParameters(resetDates, CalculationMethodEnum->Compounding)

// call the calculated rate evaluation logic to evaluate the OIS rate
assign-output 
	floatingRate :	EvaluateCalculatedRate(fro, calcParams, resetDates  , calcPeriod, calcPeriod, dayCount)


func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->OVERNIGHTAVG): <"Evaulate the rate for a daily average calculated FRO. Call the calculated rate calculation logic to determine the value of the reset. See the 2021 ISDA Definitions Section 6.6.3">
[calculation]
// set up convenience aliases
	alias  rateDef : interestRatePayout->rateSpecification->floatingRate
	alias resetDates : interestRatePayout->resetDates
	alias dayCount : interestRatePayout->dayCountFraction
	alias rateOption : rateDef->rateOption
	// create a pseudo calculation parameters block to drive the averaging calculation
	alias calcParams : GetCalculatedFROCalculationParameters(resetDates, CalculationMethodEnum->Averaging)

// call the calculated rate evaluation logic to evaluate the daily average rate
assign-output 
	floatingRate :	EvaluateCalculatedRate(rateOption, calcParams, resetDates  , calcPeriod, calcPeriod, dayCount)


func GetCalculatedFROCalculationParameters: <"Initializze a calculation parameters block for an OIS or a daily average rate. Used to support FROs that include an embedded calculation.">
	inputs:
		resetDates ResetDates(1..1)		<"The reset dates for the interest rate payount for which the calculated rate is being compputed">
		calcMethod CalculationMethodEnum(1..1)  <"Whether the rate is a compound (OIS) or daily average rate">
	output:
		calcParams FloatingRateCalculationParameters(1..1) <"A calculation parameters block">
	
	// generate and output the required type
	assign-output calcParams->calcType : calcMethod
	assign-output calcParams->applicableBusinessDays : resetDates->fixingDates ->businessCenters
	

func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->COUMPOUNDINDEX): <"Call the compounded index processing logic to calculate the reset">
// TODO:  this will depend on exactly how FpML implements this.

//-------------------------------------------------------
// The following functions do rate reset processing for Screen Rates
//-------------------------------------------------------

func EvaluateScreenRate: <"Evaluate/lookup the value of a screen rate">
	[calculation]
	inputs:
		rateDef FloatingRate(1..1)  <"Floating rate definition">
		resetDates ResetDates(1..1)	<"Reset dates for observing the rate">
		calculationPeriod CalculationPeriodBase(1..1)	<"Calculation period for which you want the rate">
	output:
		details FloatingRateSettingDetails(1..1)	<"Resulting details of the rate setting ">

	// figure out the date for which the rate is needed
	alias resetDate : DetermineResetDate(resetDates, calculationPeriod)
	alias fixingDate : DetermineFixingDate(resetDates, resetDate)

	// look up the rate on that date
	alias observedRate : IndexValueObservation(fixingDate, rateDef->rateOption)
	// record relevant dates and observed rate
	assign-output details->resetDate : resetDate
	assign-output details->observationDate : fixingDate
	assign-output details->floatingRate : observedRate


func DetermineResetDate: <"Determine the value of the reset date given a reset dates structure and a calculation paeriod for which it's needed. Reset dates are defined in the 2021 ISDA Definition in Section 6.5.5.">
	[calculation]
	inputs:
		resetDates ResetDates(1..1)	<"Reset dates for observing the rate">
		calculationPeriod CalculationPeriodBase(1..1)	<"Calculation period for which you want the rate">
	output:
		resetDate date (1..1)	<"The date upon which the rate should be observed. ">
	// figure out the date for which the rate is needed
	alias resetRelativeTo : resetDates->resetRelativeTo
	alias isStart : resetRelativeTo = ResetRelativeToEnum->CalculationPeriodStartDate
	alias reset : if (isStart) then calculationPeriod->adjustedStartDate else calculationPeriod->adjustedEndDate

	assign-output resetDate : reset

func DetermineFixingDate: <"Determine the observation (fixing) date needed given a reset dates structure and a reset date">
	[calculation]
	inputs:
		resetDates ResetDates(1..1)	<"Reset date parameters for observing the rate">
		resetDate date(1..1) <"The date that the rate is needed for">
	output:
		fixingDate date (1..1)	<"The date upon which the rate should be observed. ">


	alias fixingOffsetDays : resetDates->fixingDates->periodMultiplier
	alias fixDate : AddBusinessDays(resetDate, fixingOffsetDays, resetDates->fixingDates->businessCenters)

	assign-output fixingDate : fixDate

//-------------------------------------------------------
// The following functions look up current notional 
//-------------------------------------------------------


func LookupNotionalAmount: <"Look up the notional amouunt in effect for a calculation period">
[calculation]
inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which you want the notional">
	output:
	    notional Money(1..1) <"The notional that is in effect starting from the adjusterPeriodStartDate">
	// look up and return the notional from the notional schedule
	assign-output notional->multiplier: LookupQuantityScheduleAmount(interestRatePayout->payoutQuantity->quantitySchedule, calculationPeriod->adjustedStartDate)
	assign-output notional->multiplierUnit->currency : interestRatePayout->payoutQuantity->quantitySchedule->initialQuantity->multiplierUnit->currency


func LookupQuantityScheduleAmount: <"Look up a value from a quantity schedule given a supplied starting date.  It will return the value of the last step that is before the supplied starting date, or if none matches, the intial value.">
[calculation]
inputs:
	schedule NonNegativeQuantitySchedule(0..1) <"The quantity schedule bein looked up from">
	periodStartDate date(1..1)	<"The date for which the quantity is required">
output:
	value number(1..1)	<"The quantity in effect on the supplied date">
alias stepValues : FindNonNegativeScheduleSteps(schedule->stepSchedule, periodStartDate, 0)
alias vals : AppendToVector (stepValues, schedule->initialQuantity->multiplier)
assign-output
	value:  SelectFromVector(vals, 0)


func FindNonNegativeScheduleSteps: <"Find all  schedule step values whose stepDate is before or equal to the supplied periodStartDate, starting from supplied startingStep number.  Returns a list of step values starting from the last matching one and going in reverse order.  Done this slightly odd way for efficiency and simplicity in code generation.">
[calculation]
inputs:
	schedule NonNegativeStepSchedule(1..1) <"The quantity schedule being looked up from">
	periodStartDate date(1..1)	<"The date for which the quantity is required">
	startingStep int(1..1) <"The first step to start looking at">
output:
	vector Vector(1..1)
	alias currentStep : SelectNonNegativeScheduleStep(schedule, startingStep)
	alias remainingValues : FindNonNegativeScheduleSteps(schedule, periodStartDate, startingStep + 1)
	alias append : AppendToVector (remainingValues, currentStep->stepValue)
	alias checkAppend : if (periodStartDate >= stepDate) then append
	alias stepDate : currentStep->stepDate
	assign-output vector:
		if (startingStep < schedule->step count) then checkAppend


func SelectNonNegativeScheduleStep: <"Retrieve a single step from a  schedule given a step number.  This is an entry point to a function written in a native langugage like Java.  Returns the step if it exists, else null. The index is 0-based, so 0 returns the first setp.">
inputs:
	schedule NonNegativeStepSchedule(1..1) <"The quantity schedule being looked up from">
	stepNo int(1..1) <"The  step to return">
output:
	step NonNegativeStep(0..1)	<"The returned step, or null if it does not exist">


// =====================================================================
//
// Rate conditioning and treatment functions
//
// these functions retrieve and apply conditioning and treatment parameters for a floating rate.
// This includeds multipliers, spreads, caps/floors, rate treatment, rounding, and negative treatment
//
// ======================================================================

//-------------------------------------------------------------
// The following functions look up conditioning parameters
//-------------------------------------------------------------


func GetFloatingRateConditioningParameters: <"Determine the conditioning parameters to use from the InterestRatePayout by looking them up if necessary from the corresponding schedules in the interest rate stream">
inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1)	<"The calculation period for which the calculation is being perfmored (needed to look up paramters)">
output:
	conditioningParameters FloatingRateConditioningParameters(1..1)  <"The conditioning parameters">
// look up parameters
	alias	spreadRate : SpreadAmount(interestRatePayout, calculationPeriod)
	alias 	multiplier : MultiplierAmount(interestRatePayout, calculationPeriod)
	alias	cap : CapRateAmount(interestRatePayout, calculationPeriod)
	alias	floor : FloorRateAmount(interestRatePayout, calculationPeriod)

	alias 	rounding : interestRatePayout->rateSpecification->floatingRate->finalRateRounding
	alias	negativeTreatment : interestRatePayout->rateSpecification->floatingRate->negativeInterestRateTreatment
	alias	treatment : interestRatePayout->rateSpecification->floatingRate->rateTreatment

assign-output conditioningParameters->initialRate : interestRatePayout->rateSpecification->floatingRate->initialRate
assign-output conditioningParameters->spread : spreadRate
assign-output conditioningParameters->multiplier : multiplier
assign-output conditioningParameters->treatment :  treatment
assign-output conditioningParameters->capRate : cap
assign-output conditioningParameters->floorRate : floor
assign-output conditioningParameters->rounding : rounding
assign-output conditioningParameters->negativeTreatment : negativeTreatment


func SpreadAmount: <"Look up the spread amount for a calculation period">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which you want the spread">
	output:
	    spread number(0..1)  <"the spread value for the period">
	alias	startDate : calculationPeriod->adjustedStartDate
	assign-output
		spread: LookupRateScheduleAmount(interestRatePayout->rateSpecification->floatingRate->spreadSchedule only-element, startDate)


func MultiplierAmount: <"Look up the multiplier amount for a calculation period">
[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which you want the multiplier">
	output:
	    multiplier number(0..1) <"The multiplier in effect from the calculation period start date">
assign-output
		multiplier: LookupRateScheduleAmount(interestRatePayout->rateSpecification->floatingRate->floatingRateMultiplierSchedule, calculationPeriod->adjustedStartDate)


func CapRateAmount: <"Look up the cap rate amount for a calculation period">
[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which you want the cap rate">
	output:
	    capRate number(0..1) <"The cap rate in effect from the calculation period start date">
	// look up and return the amount from the cap rate schedule
	assign-output
		capRate: LookupRateScheduleAmount(interestRatePayout->rateSpecification->floatingRate->capRateSchedule only-element, calculationPeriod->adjustedStartDate)


func FloorRateAmount: <"Look up the floor rate amount for a calculation period">
[calculation]
inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for which you want the floor rate">
output:
	    floorRate number(0..1) <"The cap rate in effect from the calculation period start date">
// look up and return the amount
assign-output
		floorRate: LookupRateScheduleAmount(interestRatePayout->rateSpecification->floatingRate->floorRateSchedule only-element, calculationPeriod->adjustedStartDate)


func LookupRateScheduleAmount: <"Look up an amount for a calculation period from a rate schedule">
[calculation]
inputs:
	schedule RateSchedule(0..1)  <"The rate schedule">
	periodStartDate date(1..1)	<"The start date for which you want the rate">
output:
	value number(0..1) <"The value that is in effect starting from the supplied start date">

// create a list of all matching schedule stesp in reverse order, starting from the beginning
alias stepValues : FindScheduleSteps(schedule->step, periodStartDate, 0)
// add the initail level to the end of the list
alias vals : AppendToVector (stepValues, schedule->initialValue->amount)

// return the first from the list (which is the latest aplicable value)
assign-output
	value:  SelectFromVector(vals, 0)


func FindScheduleSteps: <"Find all rate schedule step values whose stepDate is before or equal to the supplied periodStartDate, starting from supplied startingStep number.  Returns a list of step values starting from the last matching one and going in reverse order.  Done this slightly odd way for efficiency and simplicity in code generation.  Assumes scehdule stesp are in ascending date order.">
[calculation]
inputs:
	steps Step(0..*) <"The quantity schedule being looked up from">
	periodStartDate date(1..1)	<"The date for which the quantity is required">
	startingStep int(1..1) <"The first step to start looking at">
output:
	vector Vector(1..1)	<"SChedule step values equal or prior to the period start date, in reverse order">

// recursively call this function to get the remaining matching step values
	alias remainingValues : FindScheduleSteps(steps, periodStartDate, startingStep + 1)

// lookup the schedule step corresponding to the starting index
	alias currentStep : SelectScheduleStep(steps, startingStep)

// append this current step to the end of the list of matching steps
	alias append : AppendToVector (remainingValues, currentStep->stepValue)

// check if the current step is in the time range, if so append the current step to the remaining matching steps, otherwise return nothing (we've reached the end)
	alias stepDate : currentStep->stepDate
	alias appendIfInTimeRange : if (periodStartDate >= stepDate) then append

// check that we haven't fallen off the end of the schedule.  If not, check if in time range and if so append current step value to the list of matching values
	assign-output vector:
		if (startingStep < steps count) then appendIfInTimeRange


func SelectScheduleStep: <"Retrieve a single step from a  schedule given a step number">
inputs:
	steps Step(0..*) <"The quantity schedule bein looked up from">
	stepNo int(1..1) <"The  step to return">
output:
	step Step(0..1)	<"The matching step, or nothing if there is no corresponding step">


//-------------------------------------------------------------
// The following functions apply conditioning parameters
//-------------------------------------------------------------
func ApplyFloatingRateConditioning: <"Perform rate treatments on floating rates, such as applying spreads, multipliers, caps and floors, rounding, and negative interest treatment.  TODOO:  initialRate needs to be supported.  Also, to support compounding methods, it may be necessary to split the before spread and after spread values and return both, so that cashflows can be computed both ways.  This may require this function to be redesigned or split into pieces (e.g. factor out the post-spread conditioning).  Rate treatmentst are described in Section 6 of the 2021 ISDA Definitions">
	inputs:
		conditioning FloatingRateConditioningParameters(1..1) <"THe parameters to be used for condition, such as multipliers, spreads, cap rates, etc.">
		rawRate number(1..1)	<"The floating rate prior to treatment, either a single term rate, or a calculated rate such as an OIS or lookback compounded rate">
		calculationPeriod CalculationPeriodBase(1..1) <"The calculation period for with the conditioning need to be perormed">
		isInitialPeriod boolean(1..1)	<"Is this the initial calculation period of the payout?">
	output:
		details FloatingRateConditioningDetails(1..1)	<"Results are details of the rate treatment">

// evaluate any floating rate multiplier (these are not described in the ISDA Definition but are included in FpML to support Inverse Floaters.  The multiplier typically 1 or -1 and is applied prior to other treatments.
	alias   multiplier : 		conditioning -> multiplier
    alias   multiplied :        rawRate * multiplier
	alias	multipliedRate : 	if multiplier exists then multiplied else rawRate
// evaluate US Dollater treatements (described in Section 6.9 of the 2021 ISDA Definitions)
	alias 	treatedRate : 		ApplyUSRateTreatment(multipliedRate, conditioning->treatment, calculationPeriod) * 1.0

// begin evaluating the floating negative treatment, in section 5.8 of the 2021 ISDA definitions
	alias	negativeTreatment : conditioning->negativeTreatment
// the following linne addresses section 6.8.6.  If the rate is negative prior to the spread, set it to 0
	alias	negativeTreatedRate : if (negativeTreatment = NegativeInterestRateTreatmentEnum->ZeroInterestRateExcludingSpreadMethod) then Max(0.0, treatedRate) else treatedRate						

// add spread (covered in section 6.5.4 and other places)
	alias 	spreadRate : 		conditioning -> spread
	alias   added :             negativeTreatedRate + spreadRate
	alias	ratePlusSpread :  	if spreadRate exists then added else negativeTreatedRate
// the following linne addresses section 6.8.4.  If the rate is negative after the spread, set it to 0
	alias	negativeTreatedRatePlusSpread : 	if (negativeTreatment = NegativeInterestRateTreatmentEnum->ZeroInterestRateMethod) then Max(0.0, ratePlusSpread) else ratePlusSpread

// initia lrate - if the initial rate is specified and it is the initial (first) period, use the initial rate instead.  This sets up aliases to support that
	alias  doInitialRate : if (isInitialPeriod = True and conditioning->initialRate exists) then True else False
	alias initialRate : 	conditioning->initialRate->amount
	alias initialRatePluSpread : 	initialRate + spreadRate
	alias  initialRatePlusSpread :	if (spreadRate exists) then initialRatePluSpread else initialRate

// return the key inputs
	assign-output	details -> conditioningParameters : conditioning
	assign-output  details->rawRate : 	rawRate

// calculate and return the conditioned rate, both including and excluding the spread
	assign-output	details->conditionedRate : if (doInitialRate=True) then initialRatePluSpread else ApplyFloatingRatePostSpreadConditioning(ratePlusSpread, conditioning)
	assign-output	details->spreadExclusiveRate : if (doInitialRate=True) then initialRate else  ApplyFloatingRatePostSpreadConditioning(negativeTreatedRate, conditioning)



func ApplyFloatingRatePostSpreadConditioning: <"Perform post-spread rate treatments on floating rates, such as applying caps and floors, rounding, and negative interest treatment.  TODOO:  initialRate needs to be supported.  Also, to support compounding methods, it may be necessary to split the before spread and after spread values and return both, so that cashflows can be computed both ways.  This may require this function to be redesigned or split into pieces (e.g. factor out the post-spread conditioning).">
	inputs:
		inputRate number(1..1)	<"The floating rate prior to post-sprad, either a single term rate, or a calculated rate such as an OIS or lookback compounded rate">
		conditioning FloatingRateConditioningParameters(1..1)
	output:
		conditionedRate number (1..1)	<"rate after post-spread conditioning">	

// apply any caps and floors on the rate
    alias   cappedAndFlooredRate : 			ApplyCapsAndFloors(conditioning, inputRate)
// calculate and output the rounded rate
    assign-output	conditionedRate :		ApplyFinalRateRounding(cappedAndFlooredRate, conditioning->rounding)


func ApplyCapsAndFloors: <"Apply any cap or floor rate as a constraint on a regular swap rate, as discussed in the 2021 ISDA Definitions, section 6.5.8 and 6.5.9">
    [calculation]
    inputs:
		conditioning FloatingRateConditioningParameters(1..1)
		inputRate number(1..1)	<"The floating rate prior to treatment, either a single term rate, or a calculated rate such as an OIS or lookback compounded rate">
    output:
        cappedAndFlooredRate number(1..1) <"The rate after application of cap and/or floor">
    	alias cap : conditioning -> capRate
    	alias floor : conditioning -> floorRate
    	alias	cappedRate :		if cap exists and inputRate > cap then  cap else inputRate
        alias	flooredRate : 		if floor exists and cappedRate < floor then floor else cappedRate
        assign-output cappedAndFlooredRate :  flooredRate



// TOODO : implement
func ApplyUSRateTreatment: <"Apply the US rate treatment logic where applicable (Bond Equivalent Yield, Money Market Yield, as described in the 2021 ISDA Definitions, section 6.9">
	inputs:
		baseRate number(1..1) <"Rate before treatment">
		rateTreatment RateTreatmentEnum(1..1) <"type of treatment">
		calculationPeriod CalculationPeriodBase(1..1) <" The calculation period over which the rate is computed">
	output:
		treatedRate number(1..1)	<"rate after treatment">
	assign-output treatedRate : baseRate		// temporary, stub definition until support is added




func ApplyFinalRateRounding: <"Apply the final rate rounding treatment logic as described in the 2021 ISDA Definitions, section 4.8.1.">
[calculation]
	inputs:
		baseRate number(1..1) <"Rate before rounding">
		finalRateRounding Rounding(1..1) <"type of rounding (precision and direction)">
	output:
		roundedRate number(1..1) <"rate after rounding">

	alias precision : finalRateRounding->precision
	alias direction : finalRateRounding->roundingDirection

	assign-output  roundedRate : if (precision exists and direction exists) then RoundToPrecision(baseRate, precision, direction)	else baseRate






// =====================================================================
//
// Calculated rate functions
//
// these functions perform the necessary calculations on calculated rates,
// such as OIS Compound, lookback compound, etc.
// These calculations are described in Sectin 7 of the 2021 ISDA Definitions.
//
// ======================================================================

func EvaluateCalculatedRate: <"Evaluate a calculated rate as described in the 2021 ISDA Definitions, Section 7">
[calculation]
	inputs:
		floatingRateOption FloatingRateOption(1..1)	<"The base floating rate index">
		calculationParameters FloatingRateCalculationParameters(1..1) <"Floating rate definition for the calculated rate">
		resetDates ResetDates(0..1)						<"reset sctucture (needed only for fallback rates, otherwise will be empty)">
		calculationPeriod CalculationPeriodBase(1..1)	<"calculation period for which we want to determine the rate">
		priorCalculationPeriod CalculationPeriodBase(0..1) <"the prior calculation period (needed only for set in adance observation shift rates">
		dayCount DayCountFractionEnum(1..1)			<"The day count fraction in effect on the stream">
	output:
		results FloatingRateSettingDetails(1..1) <"detailed results of the floating rate calculation">

	// get the FRO
	alias fro : floatingRateOption
	
	// work out the observation dates needed and the weight for each
	alias datesAndWeights : GenerateObservationDatesAndWeights(calculationParameters, resetDates, calculationPeriod, priorCalculationPeriod)

	// get the observations
	alias observationDates : datesAndWeights->observationDates
	alias observations: IndexValueObservationMultiple(observationDates, fro)

//	apply observation parameters (caps/floors)
	alias processedObservations : ProcessObservations(calculationParameters, observations)

// perform the calculation (compounding or averaging)
	alias calcType : calculationParameters->calcType
	alias isCompounding : calcType = CalculationMethodEnum->Compounding
	alias weights : datesAndWeights->weights
	alias yearFraction : YearFractionForOneDay(dayCount)  // the year fraction of 1 business day (needed for compounding formula)
	alias calculationResults : if isCompounding then ApplyCompoundingFormula(processedObservations, weights, yearFraction) else
					ApplyAveragingFormula(observations, weights)

// reecord the results
	assign-output results->calculationDetails : calculationResults
	assign-output results->calculationDetails->observations->observationDates : datesAndWeights->observationDates
	assign-output results->calculationDetails->observations->weights : datesAndWeights->weights
	assign-output results->calculationDetails->observations->observedRates : observations
	assign-output results->calculationDetails->observations->processedRates : processedObservations
	assign-output results->floatingRate : calculationResults->calculatedRate


func GenerateObservationDatesAndWeights: <"Apply shifts to generate the list of observation dates and weights for each of those dates">
[calculation]
	inputs:
		calculationParams FloatingRateCalculationParameters(1..1) <"Floating rate definition for the calculated rate">
		resetDates ResetDates(0..1)						<"reset sctucture (needed only for fallback rates, otherwise will be empty)">
		calculationPeriod CalculationPeriodBase(1..1)	<"calculation period for which we want to determine the rate">
		priorCalculationPeriod CalculationPeriodBase(0..1) <"the prior calculation period (needed only for set in advance observation shift rates">
	output:
		results CalculatedRateObservationDatesAndWeights(1..1) <"observation dates and corresonding weights">

	// set up some convenience accessors
	alias obsShift: calculationParams->observationShiftCalculation
	alias lockout: calculationParams->lockoutCalculation
	alias specifiedLockout: if lockout->offsetDays exists then lockout->offsetDays else 5
	alias lockoutDays: if (lockout exists) then specifiedLockout else 0
	alias businessDays:		calculationParams->applicableBusinessDays

	// work out the calculation period for which the rate will actually be computed (might be the prior period or based on resetDates)
	alias calculateRelative : if obsShift->calculationBase exists then obsShift->calculationBase else ObservationPeriodDatesEnum->STANDARD
	alias adjustedCalculationPeriod : ComputeCalculationPeriod(calculationPeriod, priorCalculationPeriod, calculateRelative, resetDates)

	// generate the (shifted) observation period and then the observation dates
	alias observationPeriod : DetermineObservationPeriod(adjustedCalculationPeriod, calculationParams)
	alias observationDates : GenerateObservationDates(observationPeriod, businessDays, lockoutDays)

	// work out the date list for calculating weights, then calculate the weights
	alias weightingDates : DetermineWeightingDates(calculationParams, observationDates, observationPeriod, adjustedCalculationPeriod, lockoutDays)
	alias weights : GenerateWeights(weightingDates)

	// record the results
	assign-output results->observationDates : observationDates
	assign-output results->weights : weights
	// possibly record some other intermediate results to aid debugging/understanding?


func ComputeCalculationPeriod: <"Determine the calculation period to use for computing the calculated rate (it may not be the same as the normal calculation period, for instance if the rate is set in advance)">
[calculation]
	inputs:
		calculationPeriod CalculationPeriodBase(1..1)		<"The current calculation period for which the rate is needed">
		priorCalculationPeriod CalculationPeriodBase(0..1)	<"The prior actual or deemed calculation period, if needed">
		calculateRelativeTo	ObservationPeriodDatesEnum(0..1)	<"How the calculation is done with respect to the base calculation period">
		resetDates ResetDates(0..1)							<"The resetDates structure, if needed, e.g. for fallback rates">
	output:
		result CalculationPeriodBase(1..1)	<"The calculation period over which the calculated rate should be calculated">

func ComputeCalculationPeriod(calculateRelativeTo :  ObservationPeriodDatesEnum->SETINADVANCE):
	assign-output result: priorCalculationPeriod

func ComputeCalculationPeriod(calculateRelativeTo : ObservationPeriodDatesEnum -> STANDARD):
	assign-output result : calculationPeriod

func ComputeCalculationPeriod(calculateRelativeTo : ObservationPeriodDatesEnum -> FIXINGDATE):
// TODO : this should use the code in Evaluate Term Rate to do the offset calculation (needs refactoring)
	alias resetRelativeTo : resetDates->resetRelativeTo
	alias isStart : resetRelativeTo = ResetRelativeToEnum->CalculationPeriodStartDate
	alias calcPd : if (isStart) then priorCalculationPeriod else calculationPeriod
	alias fixingOffsetDays : resetDates->fixingDates->periodMultiplier
	alias endDate : AddBusinessDays(calcPd->adjustedEndDate, fixingOffsetDays, resetDates->resetDatesAdjustments->businessCenters)
	alias startDate: AddBusinessDays(calcPd->adjustedStartDate, fixingOffsetDays, resetDates->resetDatesAdjustments->businessCenters)
	assign-output result->adjustedEndDate : endDate
	assign-output result->adjustedStartDate : startDate


func DetermineObservationPeriod: <"Determine any applicable offsets/shifts for the period for observing an index, and then generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts">
	[calculation]
	inputs:
		adjustedCalculationPeriod CalculationPeriodBase(1..1)  <"The calculation period for which the rate is being comnputed, after any adjustments">
		calculationParams FloatingRateCalculationParameters(1..1) <"Floating rate definition for the calculated rate">
	output:
		observationPeriod CalculationPeriodBase(1..1)	<"The resulting observation period">

// convenience alias to categorize the shift types and calculate the business days to use
    alias obsShift: calculationParams->observationShiftCalculation
    alias lookback: calculationParams->lookbackCalculation
    alias businessDays:		calculationParams->applicableBusinessDays
    alias additionalBusinessDays: 	obsShift->additionalBusinessDays
    alias allBusinessDays: 	CombineBusinessCenters(businessDays, additionalBusinessDays)

// determine the shift amount
	alias shift : if (obsShift exists) then obsShift->offsetDays else if lookback exists then lookback->offsetDays else 0   // shift amount
// default to 5 days if not specified (this is the default value from the 2021 Definitions)
	alias shiftDefaulted : if shift exists then shift else 5

// calculate and return the shifted observation period
	alias obsPeriod : GenerateObservationPeriod(adjustedCalculationPeriod, allBusinessDays, shiftDefaulted)
	assign-output observationPeriod : obsPeriod


func GenerateObservationPeriod: <"Generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts.">
	[calculation]
	inputs:
		calculationPeriod CalculationPeriodBase(1..1)  <"The calculation period for which the rate is being comnputed">
		bc BusinessCenters(1..1)						<"The business centers to be used for shifting">
		shiftDays int(0..1)							<"The amount of any shift">
	output:
		observationPeriod CalculationPeriodBase(1..1)	<"The resulting observation period">

	// calculate the starting and ending dates
	alias calcStart : calculationPeriod->adjustedStartDate
	alias calcEnd : calculationPeriod->adjustedEndDate
	alias obsStart : AddBusinessDays(calcStart, -1 * shiftDays, bc)
	alias obsEnd: AddBusinessDays(calcEnd, -1 * shiftDays, bc)

	// record results
	assign-output observationPeriod->adjustedStartDate : obsStart
	assign-output observationPeriod->adjustedEndDate : obsEnd


func GenerateObservationDates: <"Generate the list of observation dates given an observation period">
	[calculation]
	inputs:
		observationPeriod CalculationPeriodBase(1..1)	<"The given observation period">
		bc BusinessCenters(1..1)						<"The observation dates">
		lockoutDays int(0..1)							<"The number of lockout dates">
	output:
		observationDates DateGroup(1..1)						<"The resulting list of observation dates">

	// work out the final date of the observations  - we skip observing on the last day of the observation period
	alias days : 1 + (if (lockoutDays exists) then lockoutDays else 0)
	alias endDate : AddBusinessDays(observationPeriod->adjustedEndDate, -1 * days, bc)

	// create the list of observation dates - all business days between the start and end dates
	alias obsDates : GenerateDateList(observationPeriod->adjustedStartDate, endDate, bc)
	// return it
	assign-output observationDates : obsDates


func DetermineWeightingDates: <"Determine the dates to be used for weighting observations">
[calculation]
	inputs:
		calculationParams FloatingRateCalculationParameters(1..1) <"Floating rate definition for the calculated rate">
		observationDates  DateGroup(1..1)
		observationPeriod CalculationPeriodBase(1..1)	<"The resulting observation period">
		adjustedCalculationPeriod CalculationPeriodBase(1..1)  <"The calculation period for which the rate is being comnputed, after any adjustments">
		lockoutDays int(1..1)							<"The number of lockout days">
   	output:
		weightingDates DateGroup(1..1)

	// set up some convenience aliases
	alias obsShift: calculationParams->observationShiftCalculation
	alias lookback: calculationParams->lookbackCalculation
	alias bc:		calculationParams->applicableBusinessDays

	// work out the date list for calculating weights
	alias baseWeightingDates : if obsShift exists then observationDates else GenerateObservationDates(adjustedCalculationPeriod, bc, lockoutDays)
	alias wtPeriod : if (lookback exists) then adjustedCalculationPeriod  else observationPeriod
	alias weightingDatesAll :  AppendDateToList(baseWeightingDates, wtPeriod->adjustedEndDate)     // including final date to compute weight

    assign-output weightingDates : weightingDatesAll


func ProcessObservations: <"Apply daily observation parameters to rate observation.  These are discussed in the 2021 ISDA Definitions, section 7.2.3 and 7.2.4.">
[calculation]
	inputs:
		calulationParameters FloatingRateCalculationParameters(1..1) <"Floating rate definition for the calculated rate">
		rawObservations Vector(1..1)
	output:
		processedObservations Vector(1..1)
	
	//set up convenience aliases
    alias params : calulationParameters->observationParameters
	alias cap : if params exists then params->observationCapRate
	alias floor : if params exists then params->observationFloorRate

	//apply the daily cap and floor rates using vector math operations
	alias cappedObservations : if cap exists then VectorScalarOperation(ArithmeticOp->MaxOp, rawObservations, cap) else rawObservations
	alias flooredObservations : if floor exists then VectorScalarOperation(ArithmeticOp->MinOp, cappedObservations, floor) else cappedObservations

	// return the resulting values
	assign-output processedObservations : flooredObservations


func GenerateWeights: <"Recursively creates a list of weights based on the date difference between successive days.">
[calculation]
	inputs:
		weightingDates DateGroup(1..1)  <"a list of dates for which weightings are required">
	output:
		weights Vector(1..1)  <" a vector of weights, typically numbers between 1 and 3 or 4">

	alias active : weightingDates->dates count > 1		// do we still have more than one date in the list?
	alias refDate : LastInDateList(weightingDates)		// find the last date in the supplied list of dates
	alias remainingDates : PopOffDateList(weightingDates)	// determine the prior list of dates, i.e. omitting the last in the list
	alias prevDate : LastInDateList(remainingDates)		// find the second to last date in the supplied list of dates
	alias diff : DateDifference(prevDate, refDate)		// the weight is the date difference between the supplied ref date and the last one in the list

	alias remainingWeights : GenerateWeights(remainingDates)	// recursively generate weights for eearlier part of the list

	// if we have >= 1 in the list, add the date difference to the list of weights from the prior part of the list, else return nothing
	assign-output weights : if active then AppendToVector(remainingWeights, diff * 1.0) // else null (empty list)


func YearFractionForOneDay: <"Return the year fraction reprsented by a single day, i.e 1 / dayCountBasis, where daycountBasis represents the denominator of the day count fraction. This perhaps should take into account leap years, though the ISDA compounding formulas do not cover ACT basis at the moment.">
[calculation]
	inputs:
		dcf DayCountFractionEnum(1..1)	<"Supplied Day count fraction">
	output:
		yearFrac number(1..1)	<"Corresponding year fraction">
	// calculate and return the value from the DayCountBasis
	assign-output  yearFrac : 1.0 / DayCountBasis(dcf)


func DayCountBasis: <"Return the day count basis (the denominator of the day count fraction) for the day count fraction.  NB: this is not implemented for day count fractions with a denominator of Actual, as this is not fully defined in the 2021 ISDA Defintions for daily calculated rates in Section 7.">
[calculation]
	inputs:
		dcf DayCountFractionEnum(1..1)	<"a supplied day count fraction">
	output:
		basis int(1..1)		<" the corresponding basis, typically 360 or 365">

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_360):
	assign-output basis: 360

func DayCountBasis(dcf: DayCountFractionEnum ->_30_360):
	assign-output basis: 360

func DayCountBasis(dcf: DayCountFractionEnum ->_30E_360):
	assign-output basis: 360

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_365L):
	assign-output basis: 365

func DayCountBasis(dcf: DayCountFractionEnum ->ACT_365_FIXED):
	assign-output basis: 365

//func DayCountBasis(dcf: DayCountFractionEnum ->ACT_ACT_AFB):
//	assign-output basis: 365 // Should this support 366 in leap years?  requires passing in the actual dates

//func DayCountBasis(dcf: DayCountFractionEnum ->ACT_ACT_ISDA):
//	assign-output basis: 365  // Should this support 366 in leap years?  requires passing in the actual dates

//func DayCountBasis(dcf: DayCountFractionEnum ->ACT_ACT_ICMA):
//	assign-output basis: 365 // Should this support 366 in leap years? requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum ->BUS_252):
	assign-output basis: 252


func ApplyCompoundingFormula:  <"Implements the compounding formula:   Product of ( 1 + (rate * weight) / basis), then backs out the final rate. This is used to support section 7.3 of the 2021 ISDA Definitions.">
[calculation]
	inputs:
		observations Vector(1..1)	<"a vector of observation values">
		weights 	Vector(1..1)	<"a vector of weights (should be same size as observations, 1 weight per observation)">
		yearFrac	number(1..1)  <" year fraction of a single day (ie. 1/basis)">
	output:
		results  CalculatedRateDetails(1..1)  <"Details of the compounding calculations">

	// weight the observations
	alias  weightedObservations : VectorOperation(ArithmeticOp->MultiplyOp, observations, weights)

	// scale the weighted observations based on the basis
	alias  scaledAndWeightedObservations : VectorScalarOperation(ArithmeticOp->MultiplyOp, weightedObservations, yearFrac)

	// compute series of growth factors by adding 1 to the scaled and weighted observations
	alias  growthFactors : VectorScalarOperation(ArithmeticOp->AddOp, scaledAndWeightedObservations, 1.0)

	// compute a growth curve by successively applying the growth factors
	alias  growthCurve : VectorGrowthOperation(1.0, growthFactors)

	// find the final value of the growth curve (the product of all the growth factors times)
	alias finalValue : LastInVector(growthCurve)

	// find the values to scale by to compute the rate
	alias totalWeight : Sum(weights->values)
	alias overallYearFrac : totalWeight * yearFrac

	// compute the final calculated rate
	alias calculatedRate : (finalValue - 1) / overallYearFrac

	// record results
	assign-output  results->aggregateValue : finalValue
	assign-output  results->aggregateWeight: totalWeight
	assign-output  results->calculatedRate : calculatedRate
	assign-output  results->compoundedGrowth : growthCurve
	assign-output  results->growthFactor : growthFactors
	assign-output  results->weightedRates : weightedObservations



func ApplyAveragingFormula: <"Implementst the weighted arithmetic averaging formula.  Sums the weighted rates and divides by the total weight.  This is used to support section 7.4 of the 2021 ISDA Definitions.">
[calculation]
	inputs:
		observations Vector(1..1)	<"a vector of observation values">
		weights 	Vector(1..1)	<"a vector of weights (should be same size as observations, 1 weight per observation)">
	output:
		results  CalculatedRateDetails(1..1) <"Details of the averaging calculation">

// weight the observations
	alias  weightedObservations : VectorOperation(ArithmeticOp->MultiplyOp, observations, weights)

// sum the weighted observations
	alias totalWeightedObservations : Sum(weightedObservations->values)

// sum the weights
	alias totalWeight : Sum(weights->values)

// compute the final calculated rate
	alias calculatedRate : totalWeightedObservations / totalWeight

// record results
	assign-output  results->aggregateValue : totalWeightedObservations
	assign-output  results->aggregateWeight: totalWeight
	assign-output  results->calculatedRate : calculatedRate
	assign-output  results->weightedRates : weightedObservations


// =====================================================================
//
// Index value lookup (observation) functions
//
// these functions allow retrieval of the value of an index on a date or set of dates
// the could perhaps be moved to a different package
//
// ======================================================================

// BAL additions for new calculated rates //
func IndexValueObservation: <"BAL addition>> Retrieve the values of the supplied index on the specified observation date">
	inputs:
		observationDate date(1..1)
		floatingRateOption FloatingRateOption(1..1)
	output:
		observedValue number(1..1)

func IndexValueObservationMultiple: <"BAL addition>> Retrieve the values of the supplied index on the specified observation dates">
	inputs:
		observationDate DateGroup(1..1)
		floatingRateOption FloatingRateOption(1..1)
	output:
		observedValues Vector(1..1)
	

// =====================================================================
//
// utility functions
//
// these are supporting function for floating amount calculations
//
// ======================================================================

func InitCalculationPeriodBase: <"Initialize a CalculationPeriodBase type from CalculationPeriodData type">
	[calculation]
	inputs:
		calcPeriodData CalculationPeriodData(1..1)		<"A supplied CalculationPeriodData structure">
	output:
		calcPeriod CalculationPeriodBase(1..1)			<"The corresponding CalculationPeriodBase structure">
	assign-output calcPeriod->adjustedStartDate : calcPeriodData->startDate
	assign-output calcPeriod ->adjustedEndDate : calcPeriodData->endDate


// =====================================================================
//
// Floating Rate Index reference data and validation functions
//
// these functions allow retrieval of the reference data for a floating rate index, 
// and validation that it is a valid floating rate index name
//
// ======================================================================

func RetrieveFloatingRateIndexMetadata:  <"Retrieve all available metadata for the floating rate index ">
	inputs:
		floatingRateIndexName FloatingRateIndexEnum(1..1)  <"The name of the floating rate index ">
	output:
		floatingRateIndexDescription FloatingRateIndexDefinition(0..1)	<"The detailded description of the index if available, null otherwise">


func ValidateFloatingRateIndexName: <"Return whether the supplied floating rate index name is valid for the supplied contractual definitions">
inputs:
		floatingRateIndexName FloatingRateIndexEnum(1..1)  <"The name of the floating rate index ">
		// to be changed to string
		contractualDefs ContractualDefinitionsEnum (0..1)  <"optional, the contractual definitions to validate against">
output:
		isValid boolean(1..1) <"True if this is a floating rate index name that is valid ">

	alias defs : RetrieveFloatingRateIndexMetadata(floatingRateIndexName)
	alias isPresent :  defs exists
	alias defsOk : defs->supportedDefinition /* any */ = contractualDefs
	alias okDefs : if contractualDefs exists then  defsOk else defs exists

	assign-output  isValid : okDefs
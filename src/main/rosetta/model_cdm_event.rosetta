namespace "org.isda.cdm"

class AllocationOutcome extends ContractOrContractReference <"Class to specify the allocated contracts or contract references, alongside the state qualification of the execution.">
{
	execution ExecutionReference (1..1);
}

class AllocationPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before Execution (1..1);
		[synonym Rosetta_Workbench value before]
	after AllocationOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Cashflow extends CashflowBase <"A class to specify a cashflow, i.e. the outcome of either of computation (e.g. interest accrual) or some assessment of some sort (e.g. a fee). The cashflow can then be turned into a payment, artefact artefact to be used as the input to a payment system or the outcome of it.">
{
	cashflowAmount Money (1..1) <"The currency amount of the payment.">;
	cashflowDate AdjustableOrAdjustedOrRelativeDate (0..1);
		[synonym Rosetta_Workbench value paymentDate]
	cashflowCalculation string (0..1) <"The computation arguments used to compute the cashflow, when applicable.">;
		[synonym Rosetta_Workbench value cashflowCalculation]	
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value cashflowType] // set cashflowType.premium when synonym premium exists]
		/*
	  	 * TODO - Enable mapping syntax to map to the premium qualification
	 	 */
}

data rule Cashflow_cashflowAmount <"The cashflow amount should be a positive number, as the cashflow direction is indeed implied by the payer/receiver attribute.">
	when Cashflow -> cashflowAmount exists
	then Cashflow -> cashflowAmount -> amount >= 0.0

class CashflowBase <"A class to represent the attributes to be shared by the Cashflow and Payment classes.">
{
	id string (0..1) anchor;
		[synonym FpML value id]
	payerReceiver PayerReceiver (1..1);
	discountFactor number (0..1) <"The value representing the discount factor used to calculate the present value of the cash flow.">;
		[synonym FpML value discountFactor]
	presentValueAmount Money (0..1) <"The amount representing the present value of the forecast payment.">;
		[synonym FpML value presentValueAmount]
	premiumExpression PremiumExpression (0..1) <"FpML specifies the Premium.model group for representing the option premium when expressed in a way other than an amount.">;
	paymentDiscounting PaymentDiscounting (0..1) <"FpML specifies the FpML PaymentDiscounting.model group for representing the discounting elements that can be associated with a payment.">;
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction string (1..1);
	amount number (1..1);
	currency CurrencyEnum (0..1);
}

class ContractOrContractReference one of
{
	contract Contract (0..*);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractReference (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ContractOrListedProduct rosettaKey one of
{
	contractState ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value contractState]
	listedProduct ListedProduct (0..1);
		[synonym Rosetta_Workbench value listedProduct]
}

class ContractReference extends ContractIdentifier
{
	state StateEnum (0..1) <"The state qualification of a contractual product.">;
		[synonym Rosetta_Workbench value state]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class Event rosettaKey
{
	messageInformation MessageInformation (0..1);
	timestamp EventTimestamp (1..1);
		[synonym Rosetta_Workbench value timestamp]
	eventIdentifier Identifier (1..1);
		[synonym Rosetta_Workbench value eventIdentifier]
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym FpML value isCorrection 
			set action to ActionEnum.New when False, 
			set action to ActionEnum.Correct when True]
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, exercise events), reset values, ...">;
}

class EventEffect <"The set of operational and positional effects associated with a lifecycle event.">
{
	timestamp dateTime (1..1) <"The date and time on which the contract effect is taking place.">;
	referenceContract Contract (1..1) rosettaKey <"A pointer to the contract to which the event effect(s) apply.">;
	referenceEvent Event (1..1) rosettaKey <"A pointer to the event to which the event effect(s) apply.">;
	product ContractOrListedProduct (0..*) rosettaKey <"A pointer to the products effect(s), an example of such being the outcome of an option physical exercise.">;
	payment Payment (0..*) rosettaKey <"A pointer to the payment effect(s).">;
	reset ResetPrimitive (0..*) rosettaKey <"A pointer to the reset effect(s).">;
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*); // calculation;
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimestamp <"This class corresponds to the timestamp components of the FpML MessageHeader.model. These would be applicable even if the event is communicated through a mean other than messaging (e.g. blockchain).">
{
	creationTimestamp dateTime (1..1) <"The date and time (on the source system) when this event was created.">;
		[synonym FpML value creationTimestamp pathExpression "header"]
		[synonym Rosetta_Workbench value creationTimestamp]
	expiryTimestamp dateTime (0..1) <"The date and time (on the source system) when this event will be considered expired.">;
		[synonym FpML value expiryTimestamp]
}

class ExecutionReference
{
	executionReference Identifier (1..1);
		[synonym Rosetta_Workbench value executionReference]
	state StateEnum (1..1);
		[synonym Rosetta_Workbench value state]
}

class ExerciseOutcome extends ContractOrListedProduct one of
{
	payment Payment (0..1);
		[synonym Rosetta_Workbench value payment]
}

class ExercisePrimitive
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Execution
{
	identifier PartyContractIdentifier (1..*) <"The identifier(s) associated with the execution.">;
		[synonym Rosetta_Workbench value partyTradeIdentifier pathExpression "tradeHeader"]	
	tradeDate date (1..1) anchor <"The trade/execution date.">;
		[synonym Rosetta_Workbench value tradeDate pathExpression "tradeHeader"]
	contractualProduct ContractualProduct (1..1);
		[synonym Rosetta_Workbench value contractualProduct]
	party Party (0..*) <"The party reference is optional because positioned as part of the Event class when the execution is specified as part of such context.">;
}

data rule EventTimestamp_ExpireTime <"The expire time should be greater than the creation time.">
	when EventTimestamp -> expiryTimestamp exists
	then EventTimestamp -> expiryTimestamp > EventTimestamp -> creationTimestamp

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage
{
	contractReference Identifier (0..*) scheme "correlationIdScheme";
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class MessageInformation <"This class corresponds to the messaging components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme "messageIdScheme" <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId pathExpression "messageInformation"]
	sentBy string (0..1) scheme "messageAddressScheme" <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy pathExpression "messageInformation"]
	sentTo string (0..1) scheme "messageAddressScheme" <"The identifier for the recipient of a message instance.">;
		[synonym Rosetta_Workbench value sentTo pathExpression "messageInformation"]
	copyTo string (0..*) scheme "messageAddressScheme" <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

/*
 * TODO - The NewTrade primitive should inherit the ContractState class
 * The ingestion doesn't currently supports this inheritance, which needs to be understood/adjusted
 */
class NewTradePrimitive one of <"The primitive event to represent a new trade.">
{
	contract Contract (0..1);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	newTrade NewTradePrimitive (0..*) <"The new trade primitive is unbounded to address the case of events such as portfolio compressions, which could result in multiple new trades.">;
		[synonym Rosetta_Workbench value newTrade]
	quantityChange QuantityChangePrimitive (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	allocation AllocationPrimitive (0..*);
		[synonym Rosetta_Workbench value allocation]	
	termsChange TermsChangePrimitive (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]
}

class QuantityChangePrimitive <"The primitive event to represent a change in quantity or notional.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive rosettaKey <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	resetValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value resetValue]
	cashflow Cashflow (1..*);
		[synonym Rosetta_Workbench value cashflow]
}

class TermsChangePrimitive <"The primitive event to represent change(s) to the contractual terms.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme "timezoneLocationScheme" <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location]
}

isEvent Allocation <"The qualification of allocation event from the fact that (i) the intent is Allocation when specified, (ii) the only primitive is the allocation, (iii) the sum of quantities/notional before = after, and (iv) there is a single contractualProduct before (ensured through cardinality). Note: it is accepted that an allocation can result in a single contract.">
//	Event -> intent = IntentEnum.Allocation when present
	Event -> primitive -> allocation only exists
//	and quantityBeforeAllocation = quantityAfterAllocation

alias quantityBeforeAllocation <"The alias to represent the quantity or notional amount associated to a pre-allocation contractual product in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterAllocation <"The alias to represent the quantity or notional amount associated to allocated contract(s) in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue 
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

isEvent Compression <"The qualification of a compression event from the fact that (i) the intent is Compression when specified, (ii) the quantity change primitive exists, (iii) there are multiple contracts (or contract references) specified in the before state and (iv) the number of non-terminated contracts in the after state is less than the number of contracts in the before state.">
	Event -> intent = IntentEnum.Compression // when present
	and Event -> primitive -> quantityChange exists
//	and contractBeforeQuantityChange multiple exists
// and contractBeforeQuantityChange count > Event -> primitive -> quantityChange -> after -> contract -> state <> StateEnum.terminated count

alias contractBeforeQuantityChange
	Event -> primitive -> quantityChange -> before -> contract
	or Event -> primitive -> quantityChange -> before -> contractReference

alias contractAfterQuantityChange
	Event -> primitive -> quantityChange -> after -> contract

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists

isEvent Exercise <"The qualification of a full termination event from the fact that (i) the intent is Exercise when specified, (ii) the only primitive is the quantityChange.">
//	Event -> intent = IntentEnum.Exercise when present
	Event -> primitive -> exercise only exists

isEvent NewTradeEvent <"The qualification of a new trade event from the fact that (i) the intent is NewTrade when specified, and (ii) the only primitive is the newTrade.">
//	Event -> intent = IntentEnum.NewTrade when present
	Event -> primitive -> newTrade only exists

isEvent Novation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and newTrade exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> intent = IntentEnum.Novation // when present
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> newTrade exists
//	and quantityBeforeQuantityChange > quantityAfterQuantityChange
//	and quantityAfterQuantityChange > 0
	and Event -> primitive -> newTrade -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> newTrade -> contract -> tradeDate -> date
//	and Event -> effectiveDate = NovatedContractEffectiveDate
//	and originalContractParties <> newContractParties
	
alias NovatedContractEffectiveDate
	Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> date 
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> date
	
alias originalContractParties
	( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and 	Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)
	
alias newContractParties
	( Event -> primitive -> newTrade -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and 	Event -> primitive -> newTrade -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> newTrade -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> newTrade -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> newTrade -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> newTrade -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)	
		
isEvent PartialNovation <"The qualification of a novation event from the fact that (i) the intent is PartialNovation when specified, (ii) the primitives quantityChange and newTrade exist, (iii) the contract in the quantityChange/after node has a Novated state, (iv) the stepped-in contract has a different contract identifier than the novated contract, (v) the stepped-in contract has the novation event date and the novation event effective date, and (vi) the contract counterparties have changed.">
//	Event -> intent = IntentEnum.PartialNovation when present
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> newTrade exists
	and Event -> primitive -> quantityChange -> after -> contract -> state = StateEnum.Novated
	and Event -> primitive -> newTrade -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> newTrade -> contract -> tradeDate -> date
//	and Event -> effectiveDate = NovatedContractEffectiveDate
//	and originalContractParties <> newContractParties

data rule NovationFee <"Logic to specify that if a payment is qualified as a novation fee, it must have lineage into multiple contracts and one single event (the novation event).">
	when Event -> primitive -> payment -> paymentType = PaymentTypeEnum.NovationFee
	then Event -> lineage -> contractReference multiple exists
	and Event -> lineage -> eventReference single exists

isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists 

isEvent PartialTermination <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	Event -> intent = IntentEnum.PartialTermination // when present
	and Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> payment ) exists
//	and quantityBeforeQuantityChange > quantityAfterQuantityChange
//	and quantityAfterQuantityChange > 0

alias quantityBeforeQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue 
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) after a quantity change primitive.">
	Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue 
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount	

isEvent Payment <"The qualification of a payment event from the fact that the only primitive is the payment.">
	( Event -> primitive -> payment
	and Event -> party ) only exists

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists

isEvent Termination <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the contract state has the value 'terminated'.">
//	Event -> intent = IntentEnum.Termination when present
	Event -> primitive -> quantityChange single exists
//	and quantityAfterQuantityChange = 0
	and Event -> primitive -> quantityChange -> after -> contract -> state = StateEnum.Terminated
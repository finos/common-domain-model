namespace org.isda.cdm
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.party.*

import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.product.template.*
import cdm.product.asset.*
import cdm.product.common.schedule.*


/**
 * Function specifications that are used in the Equity Reset process 
 */
func ResolveEquityContract: <"Specifies how the updated contract should be constructed in a Equity Reset event.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		updatedContract Contract (1..1)

	alias price:
		observation -> observation

	alias equityPayout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias updatedEquityPayout:
		updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias periodEndDate:
		CalculationPeriod( equityPayout -> calculationPeriodDates, date ) -> endDate

	alias equityPerformance:
		EquityPerformance(contractState, observation -> observation, periodEndDate)

	condition IsEquityContract:
		equityPayout exists

	assign-output updatedEquityPayout -> priceReturnTerms -> valuationPriceFinal -> netPrice -> amount:
		if CalculationPeriod( equityPayout -> calculationPeriodDates, periodEndDate ) -> isLastPeriod then price

	assign-output updatedEquityPayout -> priceReturnTerms -> valuationPriceInterim -> netPrice -> amount:
		if CalculationPeriod( equityPayout -> calculationPeriodDates, periodEndDate ) -> isLastPeriod = False then price

	assign-output updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> performance:
		<"Reset primitive after state must be correctly populated with the equity payout including the performance.">
		equityPerformance

	assign-output updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> quantityMultiplier -> multiplierValue:
		<"Using the Rate of Return we 'reset' the multiplier, which is used to resolve the ultimate notional amount for the equity swap.">  
		1 + equityPerformance / 100

// should be provided as a fully specified function (with a body, like calculation) with logic based on the direction of RateOfReturn
func EquityAmountPayer: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 71. ' Equity Amount Payer' means: if the Rate Of Return is positive, then the Short Party shall be the Equity Amount Payer; and if the Rate Of Return is negative, then the Long Party shall be the Equity Amount Payer.">
	inputs: equityPayout EquityPayout (1..1)
	output: payerReceiver PayerReceiver (1..1)

func EquityCashSettlementAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		equityCashSettlementAmount Money (1..1)

	alias equityPayout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout

	// Consider moving this as a data rule on EquityPayout
	condition:
		equityPayout -> payoutQuantity -> assetIdentifier -> productIdentifier = equityPayout -> underlier -> underlyingProduct -> security -> productIdentifier

	assign-output equityCashSettlementAmount -> amount: <"Equity Cash Settlement Amount is defined here as Abs( Equity Performance ). Per the ISDA Definitions: Equity Performance = (Rate Of Return) × Equity Notional Amount and Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount; so the calculation for Equity Cash Settlement Amount in the CDM is mathematically equivalent, with the added benefit that Rate of Return does not need to be recomputed, since it was already computed in the Reset Event."> 
		Abs(contractState -> updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element -> performance)

	assign-output equityCashSettlementAmount -> currency: <"Does not handle the cross currency case, currently.">
		ResolveEquityInitialPrice( equityPayout only-element -> underlier, contractState -> contract -> tradableProduct -> priceNotation ) -> netPrice -> currency

func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return) × Equity Notional Amount.">
	inputs:
		contractState ContractState (1..1)
		observation number (1..1)
		date date (1..1)

	output:
		equityPerformance number (1..1)

	alias equityPayout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias periodStartPrice:
		ResolveEquityPeriodStartPrice(equityPayout, contractState -> contract -> tradableProduct -> priceNotation, date)

	alias periodEndPrice:
		observation

	alias assetIdentifier:
		equityPayout -> payoutQuantity -> assetIdentifier

	alias numberOfSecurities:
		ExtractQuantityByAsset( contractState -> contract -> tradableProduct -> quantityNotation, assetIdentifier ) -> quantity -> amount

	alias rateOfReturn:
		RateOfReturn(periodStartPrice, periodEndPrice)

	alias notionalAmount:
		EquityNotionalAmount(numberOfSecurities, periodEndPrice)

	assign-output equityPerformance:
		rateOfReturn * notionalAmount

func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
	inputs:
		initialPrice number (1..1)
		finalPrice number (1..1)

	output:
		rateOfReturn number (1..1)

	assign-output rateOfReturn:
		(finalPrice - initialPrice) / initialPrice

func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
	inputs:
		numberOfSecurities number (1..1)
		price number (1..1)

	output:
		equityNotionalAmount number (1..1)

	assign-output equityNotionalAmount:
		numberOfSecurities * price

func StockSplit: <"Function specification to create the fully-formed business event which represents the impact of a stock split (or a reverse stock split) on an Equity Derivatives contract on a certain date.  The function uses the defined adjustmentRatio to adjust the quantity and price as represented in two business events: QuantityChange and termsChange. ">
	inputs:
		instruction StockSplitInstruction (1..1)

	output:
		businessEvent BusinessEvent (1..1)

	alias preSplitNumberOfShares:
		NoOfUnits(instruction -> trade -> contract -> tradableProduct -> quantityNotation)

	alias postSplitNumberOfShares: <"The adjustment ratio is be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.">
		preSplitNumberOfShares * instruction -> adjustmentRatio

	alias preSplitPrices:
		instruction -> trade -> contract -> tradableProduct -> priceNotation -> price -> cashPrice -> netPrice -> amount

	alias postSplitPrice: <"The pre-split price is be divided by the adjustment ratio to determine the post-split price.">
		preSplitPrices only-element / instruction -> adjustmentRatio

	condition:
		instruction -> trade -> contract exists

	assign-output businessEvent -> primitives -> quantityChange: <"Build QuantityChangePrimitive and add to WorkflowStep.">
		Create_QuantityChangePrimitive(instruction -> trade, empty, postSplitNumberOfShares)

	assign-output businessEvent -> primitives -> termsChange: <"Build TermsChangePrimitive (for price) and add to WorkflowStep.">
		Create_PriceChangePrimitive(instruction -> trade, postSplitPrice)


namespace org.isda.cdm
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.party.*

import cdm.observable.*
import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.product.asset.*
import cdm.product.template.*
import cdm.product.common.schedule.*

/*
 * Function Specifications for Equity Swap product creation
 *
 * These should be implementation-specific, and exist in implementors' "private" extensions of the CDM rather than the public CDM
 * They are positioned here for illustration of the equity workflow as part of the CDM, until such time when they could be deemed to be moved
 *
 */
func NewEquitySwapProduct: <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement. The inputs represent the minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">
	inputs:
		security Security (1..1) <"The underlying Equity asset for the swap.">
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1) <"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">

	output:
		product Product (1..1)

	alias payout:
		product -> contractualProduct -> economicTerms -> payout

	condition: <"Security must be equity (single name).">
		security -> securityType = SecurityTypeEnum -> Equity


	assign-output product -> contractualProduct -> economicTerms -> payout -> equityPayout:
		NewSingleNameEquityPayout(security, masterConfirmation)

	assign-output product -> contractualProduct -> economicTerms -> payout -> interestRatePayout: <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications">
		if masterConfirmation exists then NewFloatingPayout(masterConfirmation)

	post-condition: <"Other payout types must be absent.">
		if masterConfirmation is absent then payout -> interestRatePayout is absent
			and payout -> cashflow is absent
			and payout -> creditDefaultPayout is absent
			and payout -> forwardPayout is absent
			and payout -> optionPayout is absent

	post-condition: <"Non-contractual product types must be absent.">
		product -> contractualProduct only exists

func NewSingleNameEquityPayout: <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs:
		security Security (1..1)
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)

	output:
		equityPayout EquityPayout (1..1)

	condition: <"Security must be equity (single name).">
		security -> securityType = SecurityTypeEnum->Equity //= underlier

	assign-output equityPayout -> returnType: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> typeOfSwapElection

	assign-output equityPayout -> calculationPeriodDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> equityCalculationPeriod

	assign-output equityPayout -> paymentDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> equityCashSettlementDates

	assign-output equityPayout -> settlementTerms: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> settlementTerms


func NewFloatingPayout: <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs: masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output: interestRatePayout InterestRatePayout (1..1)

	post-condition: <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">
		if masterConfirmation exists
		then interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod
			and interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates

/**
 * Function specifications that are used in the Equity Reset process
 */
func ResolveEquityContract: <"Specifies how the updated contract should be constructed in a Equity Reset event.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		updatedContract Contract (1..1)

	alias price:
		observation -> observation

	alias equityPayout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias updatedEquityPayout:
		updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias periodEndDate:
		CalculationPeriod( equityPayout -> calculationPeriodDates, date ) -> endDate

	alias equityPerformance:
		EquityPerformance(contractState, observation -> observation, periodEndDate)

	condition IsEquityContract:
		equityPayout exists

	assign-output updatedEquityPayout -> priceReturnTerms -> valuationPriceFinal -> netPrice -> amount:
		if CalculationPeriod( equityPayout -> calculationPeriodDates, periodEndDate ) -> isLastPeriod then price

	assign-output updatedEquityPayout -> priceReturnTerms -> valuationPriceInterim -> netPrice -> amount:
		if CalculationPeriod( equityPayout -> calculationPeriodDates, periodEndDate ) -> isLastPeriod = False then price

	assign-output updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> performance:
		<"Reset primitive after state must be correctly populated with the equity payout including the performance.">
		equityPerformance

	assign-output updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> quantityMultiplier -> multiplierValue:
		<"Using the Rate of Return we 'reset' the multiplier, which is used to resolve the ultimate notional amount for the equity swap.">  
		1 + equityPerformance / 100

// should be provided as a fully specified function (with a body, like calculation) with logic based on the direction of RateOfReturn
func EquityAmountPayer: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 71. ' Equity Amount Payer' means: if the Rate Of Return is positive, then the Short Party shall be the Equity Amount Payer; and if the Rate Of Return is negative, then the Long Party shall be the Equity Amount Payer.">
	inputs: equityPayout EquityPayout (1..1)
	output: payerReceiver PayerReceiver (1..1)

func EquityCashSettlementAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		equityCashSettlementAmount Money (1..1)

	alias equityPayout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout

	// Consider moving this as a data rule on EquityPayout
	condition:
		equityPayout -> payoutQuantity -> assetIdentifier -> productIdentifier = equityPayout -> underlier -> underlyingProduct -> security -> productIdentifier

	assign-output equityCashSettlementAmount -> amount: <"Equity Cash Settlement Amount is defined here as Abs( Equity Performance ). Per the ISDA Definitions: Equity Performance = (Rate Of Return) × Equity Notional Amount and Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount; so the calculation for Equity Cash Settlement Amount in the CDM is mathematically equivalent, with the added benefit that Rate of Return does not need to be recomputed, since it was already computed in the Reset Event."> 
		Abs(contractState -> updatedContract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element -> performance)

	assign-output equityCashSettlementAmount -> currency: <"Does not handle the cross currency case, currently.">
		ResolveEquityInitialPrice( equityPayout only-element -> underlier, contractState -> contract -> tradableProduct -> priceNotation ) -> netPrice -> currency

func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return) × Equity Notional Amount.">
	inputs:
		contractState ContractState (1..1)
		observation number (1..1)
		date date (1..1)

	output:
		equityPerformance number (1..1)

	alias equityPayout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias periodStartPrice:
		ResolveEquityPeriodStartPrice(equityPayout, contractState -> contract -> tradableProduct -> priceNotation, date)

	alias periodEndPrice:
		observation

	alias assetIdentifier:
		equityPayout -> payoutQuantity -> assetIdentifier

	alias numberOfSecurities:
		ExtractQuantityByAsset( contractState -> contract -> tradableProduct -> quantityNotation, assetIdentifier ) -> quantity -> amount

	alias rateOfReturn:
		RateOfReturn(periodStartPrice, periodEndPrice)

	alias notionalAmount:
		EquityNotionalAmount(numberOfSecurities, periodEndPrice)

	assign-output equityPerformance:
		rateOfReturn * notionalAmount

func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
	inputs:
		initialPrice number (1..1)
		finalPrice number (1..1)

	output:
		rateOfReturn number (1..1)

	assign-output rateOfReturn:
		(finalPrice - initialPrice) / initialPrice

func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
	inputs:
		numberOfSecurities number (1..1)
		price number (1..1)

	output:
		equityNotionalAmount number (1..1)

	assign-output equityNotionalAmount:
		numberOfSecurities * price

func StockSplit: <"Function specification to create the fully-formed business event which represents the impact of a stock split (or a reverse stock split) on an Equity Derivatives contract on a certain date.  The function uses the defined adjustmentRatio to adjust the quantity and price as represented in two business events: QuantityChange and termsChange. ">
	inputs:
		instruction StockSplitInstruction (1..1)

	output:
		businessEvent BusinessEvent (1..1)

	alias preSplitNumberOfShares:
		NoOfUnits(instruction -> trade -> contract -> tradableProduct -> quantityNotation)

	alias postSplitNumberOfShares: <"The adjustment ratio is be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.">
		preSplitNumberOfShares * instruction -> adjustmentRatio

	alias preSplitPrices:
		instruction -> trade -> contract -> tradableProduct -> priceNotation -> price -> cashPrice -> netPrice -> amount

	alias postSplitPrice: <"The pre-split price is be divided by the adjustment ratio to determine the post-split price.">
		preSplitPrices only-element / instruction -> adjustmentRatio

	condition:
		instruction -> trade -> contract exists

	assign-output businessEvent -> primitives -> quantityChange: <"Build QuantityChangePrimitive and add to WorkflowStep.">
		Create_QuantityChangePrimitive(instruction -> trade, empty, postSplitNumberOfShares)

	assign-output businessEvent -> primitives -> termsChange: <"Build TermsChangePrimitive (for price) and add to WorkflowStep.">
		Create_PriceChangePrimitive(instruction -> trade, postSplitPrice)


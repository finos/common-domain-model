namespace "org.isda.cdm"
version "${project.version}"

/*
 * Function Specifications to process Equity Swap life cycle events (beyond execution) 
 * 
 * The sequence of business events being demonstrated will do the following:
 * 1) Create a new contract file that corresponds to an Equity Swap (Ingestion)
 * 2) Create a new MCA which attributes match the relevant terms of that Equity Swap (method TBD)
 * 3) Create a new execution event using the Execute function, that takes its inputs (product, parties, legal agreement) as references from the above
 * 3.5) Create a new contract event using the Contractualise function, that takes an execution as input (from #3) 
 * 4) Create a new observation event for the equity price
 * 5) Create a new reset event based on that observation
 * 6) Create a new transfer event based on that reset
 */
 
 /*
 * Function Specifications for Equity Swap product creation
 * 
 * These should be implementation-specific, and exist in implementors' "private" extensions of the CDM rather than the public CDM
 * They are positioned here for illustration of the equity workflow as part of the CDM, until such time when they could be deemed to be moved
 * 
 */
func NewEquitySwapProduct: <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement. The inputs represent the minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">
	inputs: 
		underlier Equity (1..1) <"The underlying Equity asset for the swap.">
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1) <"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">
		
	output:
		product Product (1..1)
		
	alias payout:
		product -> contractualProduct -> economicTerms -> payout
		
	assign-output product -> contractualProduct -> economicTerms -> payout -> equityPayout : 
		NewSingleNameEquityPayout( underlier, masterConfirmation )
	
	assign-output product -> contractualProduct -> economicTerms -> payout -> interestRatePayout : <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications">
		if masterConfirmation exists then NewFloatingPayout( masterConfirmation )
		
	post-condition: <"Other payout types must be absent.">
		if masterConfirmation is absent then payout -> interestRatePayout is absent; 
		payout -> cashflow is absent;
		payout -> creditDefaultPayout is absent;
		payout -> forwardPayout is absent;
		payout -> optionPayout is absent;	
		
	post-condition: <"Non-contractual product types must be absent.">
		product -> contractualProduct only exists;

		
func NewSingleNameEquityPayout: <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs:
		underlier Equity (1..1)
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
		
	output:
		equityPayout EquityPayout (1..1)
		
	assign-output equityPayout -> returnType : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> typeOfSwapElection
		
	assign-output equityPayout -> calculationPeriodDates : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> equityCalculationPeriod
		
	assign-output equityPayout -> paymentDates : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> equityCashSettlementDates
		
	assign-output equityPayout -> settlementTerms : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> settlementTerms
		
	post-condition: <"Equity payout must be single name on the provided equity underlier.">
		equityPayout -> underlier -> singleUnderlier -> underlyingProduct -> security -> equity = underlier;
		
		
func NewFloatingPayout: <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs: masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output: interestRatePayout InterestRatePayout (1..1)

	post-condition: <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">
		if masterConfirmation exists 
			then interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod 
				and interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates;

/**
 * Function specifications that are used in the Equity Reset process 
 */
func ResolveEquityContract: <"Specifies how the updated contract should be constructed in a Equity Reset event.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		
	output:
		updatedContract Contract (1..1)
		
	alias equityPayout:
		contractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout
	
	alias effectiveDate :
		equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate
	
	alias equityPayout : <"TODO: should be usable in assign-output blocks.">
		updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout only-element
		
	condition isEquityContract :
		equityPayout exists;
		
	condition isPeriodEndDate : <"The reset date must be the period end date on the equity payout.">
		GetBusinessDate() = CalculationPeriod( equityPayout -> calculationPeriodDates ) -> endDate;
		
	condition : <"effective date should be in the past.">
		if effectiveDate exists then effectiveDate < GetBusinessDate();
	
	// TODO: use alias EquityPayout_after when feature is available	
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> rateOfReturn : 
		<"Reset primitive after state must be correctly populated with the equity payout including the rate of return.">
		RateOfReturn( equityPayout )
		
	// TODO: use alias EquityPayout_after when feature is available		
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> performance : 
		<"Reset primitive after state must be correctly populated with the equity payout including the performance.">
		EquityPerformance( equityPayout )
		
	assign-output updatedContract -> contractualQuantity -> quantityNotation -> notationTag :
		<"Set the notional amount on the Updated Contract.">  
		QuantityNotationEnum.Notional
	
	assign-output updatedContract -> contractualQuantity -> quantityNotation -> quantity -> amount :
		<"Set the notional amount on the Updated Contract.">  
		EquityNotionalAmount( equityPayout )
		
	assign-output updatedContract -> contractualQuantity -> quantityNotation -> quantity -> currency :
		<"The currency of the Updated Contract should be taken from the original Contract.">
		contractState -> contract -> contractualQuantity -> quantityNotation -> quantity -> currency only-element
		
	// TODO: use alias EquityPayout_after when feature is available	
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> equityCashSettlementAmount : 
		<"Reset primitive after state must be correctly populated with the equity payout including the cash settlement amount.">
		EquityCashSettlementAmount( equityPayout )


// TODO: unused?
func EquityPriceObservation: <"Function specification for the observation of an equity price, based on the attributes of the 'EquityValuation' class.">
	inputs:
		equity Equity (1..1)
		valuationDate AdjustableOrRelativeDate (1..1)
		valuationTime BusinessCenterTime (0..1)
		timeType TimeTypeEnum (0..1)
		determinationMethod DeterminationMethodEnum (1..1)
		
	output:
		observation ObservationPrimitive (1..1)
		
	condition: <"Optional choice between directly passing a time or a timeType, which has to be resolved into a time based on the determination method.">
		if valuationTime exists then timeType is absent
		else if timeType exists then valuationTime is absent
		else False;
		
	post-condition: <"The date and time must be properly resolved as attributes on the output.">
		observation -> date = ResolveAdjustableDate( valuationDate );
		if valuationTime exists then
			observation -> time = TimeZoneFromBusinessCenterTime( valuationTime )
		else
			observation -> time = ResolveTimeZoneFromTimeType( timeType, determinationMethod );
			
	post-condition: <"The number recorded in the observation must match the number fetched from the source.">
		observation -> observation = EquitySpot( equity, observation -> date, observation -> time );


// should be provided as a fully specified function (with a body, like calculation) with logic based on the direction of RateOfReturn
func EquityAmountPayer: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 71. ' Equity Amount Payer' means: if the Rate Of Return is positive, then the Short Party shall be the Equity Amount Payer; and if the Rate Of Return is negative, then the Long Party shall be the Equity Amount Payer.">
	inputs: equityPayout EquityPayout (1..1) 
	output: payerReceiver PayerReceiver (1..1)
		

func EquitySpot: <"An external market data lookup for the spot equity price of the reference asset based on a determination method.">
	inputs:
		equity Equity (1..1)
		date date (1..1)
		time TimeZone (1..1 ) 
		
	output: spot number (1..1)


func TimeZoneFromBusinessCenterTime: <"Function to resolve a time passed as BusinessCenterTime into a TimeZone time.">
	inputs: time BusinessCenterTime (1..1)
	output: result TimeZone (1..1)


func ResolveTimeZoneFromTimeType: <"Function to resolve a TimeType into a TimeZone based on a determination method.">
	inputs:
		timeType TimeTypeEnum (1..1)
		determinationMethod DeterminationMethodEnum (1..1)
		
	output:
		time TimeZone (1..1)
		

func EquityCashSettlementAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount.">
	inputs: 
		equityPayout EquityPayout(1..1)
		
	output: 
		equityCashSettlementAmount Money (1..1)
		
	alias rateOfReturn : 
		Abs( RateOfReturn( equityPayout ) )
		
	alias notionalAmount : 
		EquityNotionalAmount( equityPayout )
		
	assign-output equityCashSettlementAmount -> amount : 
		rateOfReturn * notionalAmount
		
	assign-output equityCashSettlementAmount -> currency :
		if equityPayout -> priceReturnTerms -> initialPrice -> netPrice exists 
			then equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> currency
			else equityPayout -> priceReturnTerms -> initialPrice -> cleanNetPrice -> currency


func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return) × Equity Notional Amount.">
	inputs: 
		equityPayout EquityPayout(1..1)
		
	output: 
		equityPerformance number (1..1)
		
	alias rateOfReturn : 
		RateOfReturn( equityPayout )
		
	alias notionalAmount : 
		EquityNotionalAmount( equityPayout )
		
	assign-output equityPerformance : 
		rateOfReturn * notionalAmount


func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
	inputs: 
		equityPayout EquityPayout(1..1)
	
	output: 
		rateOfReturn number (1..1)		
		
	alias calculationPeriod : 
		EquityCalculationPeriod( equityPayout, GetBusinessDate() )
		
	alias initialPrice: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 102. 'Initial Price' means, in respect of the first Equity Valuation Date, the Specified Initial Price, and in respect of each subsequent Equity Valuation Date, the Final Price for the Equity Valuation Date immediately preceding such Equity Valuation Date."> 
		if calculationPeriod -> isFirstPeriod = True 
			then equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> amount
		else if equityPayout -> priceReturnTerms -> valuationPriceInterim exists 
			then ResolvePrice( equityPayout -> priceReturnTerms -> valuationPriceInterim, calculationPeriod -> startDate )
			else ResolvePrice( equityPayout -> priceReturnTerms -> valuationPriceFinal, calculationPeriod -> startDate ) 
				
	alias finalPrice: <"Part 1 Section 5, 'Pricing', of the 2018 ISDA CDM Equity Confirmation, Para 5.1, 'Determining Prices': Each price in relation to a Pricing Date shall be determined pursuant to the specified Pricing Method. Pricing Method for the final Equity Valuation Date shall be specified by the Final EVD Pricing Election and Pricing Method for any other Equity Valuation Date shall be 'Securities Close Pricing (Official)'"> 
		if calculationPeriod -> isLastPeriod = True 
			then ResolvePrice( equityPayout -> priceReturnTerms -> valuationPriceFinal, calculationPeriod -> endDate )
			else ResolvePrice( equityPayout -> priceReturnTerms -> valuationPriceInterim, calculationPeriod -> endDate )
			
	assign-output rateOfReturn : 
		( finalPrice - initialPrice ) / initialPrice 


func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
	inputs: 
		equityPayout EquityPayout(1..1)
		
	output: 
		equityNotionalAmount number (1..1)
		
	alias numberOfSecurities : 
		1.0 // equityPayout -> underlier -> singleUnderlier -> quantity -> amount
	
	alias initialPrice : 
		equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> amount
	
	assign-output equityNotionalAmount : 
		numberOfSecurities * initialPrice


func ResolvePrice: <"Function specification to return the price on a valuation date based on an EquityValuation method. Implementor of this function should make use of the observation primitive and fetch the price based on an observation key.">
	inputs: 
		equityValuation EquityValuation (1..1)
		date date (1..1)
		
	output:	
		price number  (1..1)



	
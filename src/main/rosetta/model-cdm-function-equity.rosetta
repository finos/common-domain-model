namespace "org.isda.cdm"
version "${project.version}"

/*
 * Function Specifications to process Equity Swap life cycle events (beyond execution) 
 * 
 * The sequence of business events being demonstrated will do the following:
 * 1) Create a new contract file that corresponds to an Equity Swap (Ingestion)
 * 2) Create a new MCA which attributes match the relevant terms of that Equity Swap (method TBD)
 * 3) Create a new execution event using the Execute function, that takes its inputs (product, parties, legal agreement) as references from the above
 * 3.5) Create a new contract event using the Contractualise function, that takes an execution as input (from #3) 
 * 4) Create a new observation event for the equity price
 * 5) Create a new reset event based on that observation
 * 6) Create a new transfer event based on that reset
 */
/*
 * Function Specifications for Equity Swap product creation
 * 
 * These should be implementation-specific, and exist in implementors' "private" extensions of the CDM rather than the public CDM
 * They are positioned here for illustration of the equity workflow as part of the CDM, until such time when they could be deemed to be moved
 * 
 */
func NewEquitySwapProduct: <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement. The inputs represent the minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">
	inputs: 
		underlier Equity (1..1) <"The underlying Equity asset for the swap.">
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1) <"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">
		
	output:
		product Product (1..1)
		
	alias payout:
		product -> contractualProduct -> economicTerms -> payout
		
	assign-output product -> contractualProduct -> economicTerms -> payout -> equityPayout : 
		NewSingleNameEquityPayout( underlier, masterConfirmation )
	
	assign-output product -> contractualProduct -> economicTerms -> payout -> interestRatePayout : <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications">
		if masterConfirmation exists then NewFloatingPayout( masterConfirmation )
		
	post-condition: <"Other payout types must be absent.">
		if masterConfirmation is absent then payout -> interestRatePayout is absent; 
		payout -> cashflow is absent;
		payout -> creditDefaultPayout is absent;
		payout -> forwardPayout is absent;
		payout -> optionPayout is absent;	
		
	post-condition: <"Non-contractual product types must be absent.">
		product -> contractualProduct only exists;

		
func NewSingleNameEquityPayout: <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs:
		underlier Equity (1..1)
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
		
	output:
		equityPayout EquityPayout (1..1)
		
	assign-output equityPayout -> returnType : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> typeOfSwapElection
		
	assign-output equityPayout -> calculationPeriodDates : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> equityCalculationPeriod
		
	assign-output equityPayout -> paymentDates : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> equityCashSettlementDates
		
	assign-output equityPayout -> settlementTerms : <"Equity payout must inherit terms from the Master Confirmation Agreement."> 
		masterConfirmation -> settlementTerms
		
	post-condition: <"Equity payout must be single name on the provided equity underlier.">
		equityPayout -> underlier -> singleUnderlier -> underlyingProduct -> security -> equity = underlier;
		
		
func NewFloatingPayout: <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs: masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output: interestRatePayout InterestRatePayout (1..1)

	post-condition: <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">
		if masterConfirmation exists 
			then interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod 
				and interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates;

/**
 * Function specifications that are used in the Equity Reset process 
 */
func ResolveEquityContract: <"Specifies how the updated contract should be constructed in a Equity Reset event.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		timestamp zonedDateTime (1..1)
		
	output:
		updatedContract Contract (1..1)
		
	alias price:
		observation -> observation
		
	alias equityPayout:
		contractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout
	
//	alias effectiveDate :
//		equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate
	
	alias updatedEquityPayout : <"TODO: should be usable in assign-output blocks.">
		updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout only-element
		
	alias periodEndDate :
		CalculationPeriod( equityPayout -> calculationPeriodDates, timestamp ) -> endDate
	
//	alias rateOfReturn :
//		RateOfReturn( equityPayout, price, periodEndDate )
		
	condition isEquityContract :
		equityPayout exists;
	
//	TODO: use alias equityPayout when assign-output can use alias'	
//	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> rateOfReturn : 
//		<"Reset primitive after state must be correctly populated with the equity payout including the rate of return.">
//		rateOfReturn
		
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout ->priceReturnTerms -> valuationPriceInterim -> netPrice :
		if EquityCalculationPeriod( equityPayout, periodEndDate ) -> isLastPeriod = False then price
		
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout ->priceReturnTerms -> valuationPriceFinal -> netPrice :
		if EquityCalculationPeriod( equityPayout, periodEndDate ) -> isLastPeriod then price
	
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout ->priceReturnTerms -> price :
		price
			
//	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> performance : 
//		<"Reset primitive after state must be correctly populated with the equity payout including the performance.">
//		EquityPerformance( equityPayout, observation -> observation, periodEndDate )
	
//	assign-output updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> quantityMultiplier -> multiplierValue :
//		<"Using the Rate of Return we 'reset' the multiplier, which is used to resolve the ultimate notional amount for the equity swap.">  
//		if equityPayout -> payoutQuantity -> quantityMultiplier -> multiplierValue exists 
//			then equityPayout -> payoutQuantity -> quantityMultiplier -> multiplierValue * rateOfReturn
//			else rateOfReturn

// TODO: unused?
func EquityPriceObservation: <"Function specification for the observation of an equity price, based on the attributes of the 'EquityValuation' class.">
	inputs:
		equity Equity (1..1)
		valuationDate AdjustableOrRelativeDate (1..1)
		valuationTime BusinessCenterTime (0..1)
		timeType TimeTypeEnum (0..1)
		determinationMethod DeterminationMethodEnum (1..1)
		
	output:
		observation ObservationPrimitive (1..1)
		
	condition: <"Optional choice between directly passing a time or a timeType, which has to be resolved into a time based on the determination method.">
		if valuationTime exists then timeType is absent
		else if timeType exists then valuationTime is absent
		else False;
		
	post-condition: <"The date and time must be properly resolved as attributes on the output.">
		observation -> date = ResolveAdjustableDate( valuationDate );
		if valuationTime exists then
			observation -> time = TimeZoneFromBusinessCenterTime( valuationTime )
		else
			observation -> time = ResolveTimeZoneFromTimeType( timeType, determinationMethod );
			
	post-condition: <"The number recorded in the observation must match the number fetched from the source.">
		observation -> observation = EquitySpot( equity, observation -> date, observation -> time );


// should be provided as a fully specified function (with a body, like calculation) with logic based on the direction of RateOfReturn
func EquityAmountPayer: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 71. ' Equity Amount Payer' means: if the Rate Of Return is positive, then the Short Party shall be the Equity Amount Payer; and if the Rate Of Return is negative, then the Long Party shall be the Equity Amount Payer.">
	inputs: equityPayout EquityPayout (1..1) 
	output: payerReceiver PayerReceiver (1..1)
		

func EquitySpot: <"An external market data lookup for the spot equity price of the reference asset based on a determination method.">
	inputs:
		equity Equity (1..1)
		date date (1..1)
		time TimeZone (1..1 ) 
		
	output: spot number (1..1)


func TimeZoneFromBusinessCenterTime: <"Function to resolve a time passed as BusinessCenterTime into a TimeZone time.">
	inputs: time BusinessCenterTime (1..1)
	output: result TimeZone (1..1)


func ResolveTimeZoneFromTimeType: <"Function to resolve a TimeType into a TimeZone based on a determination method.">
	inputs:
		timeType TimeTypeEnum (1..1)
		determinationMethod DeterminationMethodEnum (1..1)
		
	output:
		time TimeZone (1..1)
		

func EquityCashSettlementAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount.">
	inputs: 
		contractState ContractState (1..1)
		date date (1..1)
		
	output: 
		equityCashSettlementAmount Money (1..1)
	
	alias equityPayout :
		contractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout
	
//	alias calculationPeriod : 
//		EquityCalculationPeriod( equityPayout, date )
//			
//	alias initialPrice: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 102. 'Initial Price' means, in respect of the first Equity Valuation Date, the Specified Initial Price, and in respect of each subsequent Equity Valuation Date, the Final Price for the Equity Valuation Date immediately preceding such Equity Valuation Date."> 
//		if calculationPeriod -> isFirstPeriod
//			then equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> amount
//		else if calculationPeriod -> isLastPeriod 
//			then equityPayout -> priceReturnTerms -> valuationPriceFinal -> netPrice
//		else equityPayout -> priceReturnTerms -> valuationPriceInterim -> netPrice
		
	alias periodStartPrice :
		ResolveEquityPeriodStartPrice( contractState )
		
	alias periodEndPrice :
		contractState -> updatedContract -> contractualProduct -> economicTerms -> payout -> equityPayout -> priceReturnTerms -> price -> netPrice -> amount
	
	alias quantity:
		ResolveQuantity( equityPayout -> payoutQuantity, date )
		
	alias rateOfReturn:
		RateOfReturn( periodStartPrice, periodEndPrice )
		
	alias equityNotionalAmount:
		EquityNotionalAmount( quantity, periodEndPrice )
		
	alias equityPerformance: 
		EquityPerformance( rateOfReturn, equityNotionalAmount )
		
	condition:
		equityPayout -> payoutQuantity -> quantityNotationTag = QuantityNotationEnum.NumberOfSecurities; 
		
	assign-output equityCashSettlementAmount -> amount : <"Equity Cash Settlement Amount is defined as absolute value of the equity performance, this departs from the ISDA documentation (which defines the Equity Cash Settlement Amount as = ABS( Rate of Return ) x Equity Notional Amount."> 
		Abs( equityPerformance )  
		
	assign-output equityCashSettlementAmount -> currency : <"Does not handle the cross currency case, currently.">
		if equityPayout -> priceReturnTerms -> initialPrice -> netPrice exists 
			then equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> currency


func ResolveEquityPeriodStartPrice: <"Resolves the price from the end of the previous period. If first period, then take the initial price.">
	inputs: constractState ContractState (1..1)
	output: price number (1..1)
	assign-output price :
		if constractState -> updatedContract count = 1 then 
			constractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout
	// With the current state of the Reset implementation, a single updated contract is captured on the Contract State. 
	// Once the full history of Rest values are stored, this function will use the penultimate entry to retrieve the previous period's price.  
	
	
//func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return) × Equity Notional Amount.">
//	inputs: 
//		equityPayout EquityPayout(1..1)
//		observation number (1..1)
//		date date (1..1)
//		
//	output: 
//		equityPerformance number (1..1)
//		
//	alias rateOfReturn : 
//		RateOfReturn( equityPayout, observation, date )
//		
//	alias notionalAmount : 
//		EquityNotionalAmount( equityPayout, date )
//		
//	assign-output equityPerformance : 
//		rateOfReturn * notionalAmount


func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return) × Equity Notional Amount.">
	inputs:
		rateOfReturn number (1..1)
		equityNotionalAmount number (1..1)
	output:
		performance number (1..1)
		
	assign-output performance:
		rateOfReturn * equityNotionalAmount

func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
	inputs: 
		initialPrice number (1..1)
		finalPrice number (1..1)
	
	output: 
		rateOfReturn number (1..1)
		
	assign-output rateOfReturn :
		(finalPrice - initialPrice) / initialPrice
		
//	alias calculationPeriod : 
//		EquityCalculationPeriod( equityPayout, date )
//			
//	alias initialPrice: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 102. 'Initial Price' means, in respect of the first Equity Valuation Date, the Specified Initial Price, and in respect of each subsequent Equity Valuation Date, the Final Price for the Equity Valuation Date immediately preceding such Equity Valuation Date."> 
//		if calculationPeriod -> isFirstPeriod
//			then equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> amount
//		else if calculationPeriod -> isLastPeriod 
//			then equityPayout -> priceReturnTerms -> valuationPriceFinal -> netPrice
//		else equityPayout -> priceReturnTerms -> valuationPriceInterim -> netPrice	 
		
//	assign-output rateOfReturn : 
//		( observation - initialPrice ) / initialPrice 


func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
	inputs: 
//		equityPayout EquityPayout(1..1)
//		date date (1..1)
		numberOfSecurities Quantity (1..1)
		price number (1..1)
		
	output: 
		equityNotionalAmount number (1..1)
		
//	alias numberOfSecurities :
//		ResolveQuantity( equityPayout -> underlier -> singleUnderlier -> quantity, date ) -> amount
//	
//	alias initialPrice :
//		equityPayout -> priceReturnTerms -> initialPrice -> netPrice -> amount 
	
	assign-output equityNotionalAmount : 
		numberOfSecurities -> amount * price




	
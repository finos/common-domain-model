namespace org.isda.cdm
version "${project.version}"

import cdm.base.*
import cdm.base.maths.*
import cdm.base.datetime.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.asset.commons.*
import cdm.base.staticdata.party.*


type AssetIdentifier: <"Generic object to specify an identifier for a quantifiable object, which can either be a product, a currency or a rate option.">

	productIdentifier ProductIdentifier (0..1) <"Product identifier, when the quantifiable asset is a product.">
		// For QuantityNotation only set productIdentifier if openUnits exists
		[synonym FpML_5_10 value "equity" set when "openUnits" exists]
		[synonym CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "ignore"]
	currency string (0..1) <"Currency identifier, when the quantifiable asset is a currency.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "currency" maps 2 meta "currencyScheme"]
	rateOption FloatingRateOption (0..1) <"Rate option identifier, when the quantifiable asset is a floating rate.">

	condition: one-of


type Cashflow extends PayoutBase: <"Class to specify a cashflow, i.e. the outcome of either of computation (e.g. interest accrual) or an assessment of some sort (e.g. a fee). The cashflow can then be turned into a cash transfer, artefact to be used as the input to a payment system or the outcome of it. The associated rosettaKey denotes the ability to associate a hash value to the Cashflow instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 meta "id"]

	payerReceiver PayerReceiver (1..1)
	paymentDiscounting PaymentDiscounting (0..1) <"FpML specifies the FpML PaymentDiscounting.model group for representing the discounting elements that can be associated with a payment.">
	cashflowAmount Money (0..1) <"SCHEDULED FOR DEPRECATION, QUANTITY HANDLED IN PAYOUTBASE. The currency amount of the payment.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fixedAmount"]
	premiumExpression PremiumExpression (0..1) <"FpML specifies the Premium.model group for representing the option premium when expressed in a way other than an amount.">
	cashflowDate AdjustableOrAdjustedOrRelativeDate (0..1)
	cashflowCalculation calculation (0..1) <"This is a conceptual placeholder for providing the breakdown into the cashflow calculation components, leveraging the fact that the CDM provides calculation components, starting with the FixedAmount and the FloatingAmount. Further evaluation of expected usage needs to take place to confirm and prioritize such implementation.">
		[synonym Workflow_Event value "cashflowCalculation"]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, e.g. brokerage fee, premium, upfront fee etc. Particularly relevant when it cannot be inferred directly through lineage.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17 value "paymentType"]
	discountFactor number (0..1) <"The value representing the discount factor used to calculate the present value of the cashflow.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "discountFactor"]
	presentValueAmount Money (0..1) <"The amount representing the present value of the forecast payment.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "presentValueAmount"]
	paymentDelay boolean (0..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17 value "paymentDelay" path "trade->creditDefaultSwap->feeLeg"]

	condition CashflowAmount: <"The cashflow amount should be a positive number, as the cashflow direction is indeed implied by the payer/receiver attribute.">
		if cashflowAmount exists
		then cashflowAmount -> amount >= 0.0

/*
 * TODO - Follow-up to evaluate an alternative approach consisting in referencing those data points rather than specifying them.
 * Trello card: https://trello.com/c/4D6zubCG
 */
type ClosedState: <" A class to qualify the closed state of an execution or a contract through the combination or a state (e.g. terminated, novated) and a set of dates: activity date, effective date and, when relevant, last payment date.">

	state ClosedStateEnum (1..1) <"The qualification of what gave way to the contract or execution closure, e.g. allocation, termination, ...">
		[synonym Workflow_Event value "state"]
	activityDate date (1..1) <"The activity date on which the closing state took place, i.e. either the event date of the closing event (e.g. option exercise, contract early termination) or the contractual termination date.">
		[synonym Workflow_Event value "activityDate"]
	effectiveDate date (0..1) <"The date on which the closing event contractually takes effect, when different from the activity date. When an explicit event effective date attribute is associated with the closing event, it will be that date. In the case of a cancellation event, it will be the date on which the cancelled event took place.">
		[synonym Workflow_Event value "effectiveDate"]
	lastPaymentDate date (0..1) <"The date associated with the last payment in relation to the artefact (e.g. contract) to which this closed state applies. As an example, in the case of an early termination event, it would be the settlement date of the associated fee, if applicable.">
		[synonym Workflow_Event value "lastPaymentDate"]


type Contract: <" A class to specify a financial contract object, which can be invoked either within the context of an event, or independently from it. It corresponds to the FpML Trade in the Confirmation view (while the CDM Execution class corresponds to the FpML trade in the Pre-Trade view). The associated rosettaKey denotes the ability to associate a hash value to the Contract instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[rootType]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 meta "id" path "trade"]

	contractIdentifier Identifier (1..*) <"The identifier(s) that uniquely identify a contract, and which can be qualified by referencing or defining the issuer(s) of such identifier(s). There can be several contract identifier, an example of such being a contract is reportable to both the CFTC and ESMA and then has an associated USI (Unique Swap Identifier) UTI (Unique Trade Identifier).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "partyTradeIdentifier" path "trade->tradeHeader"]
		[synonym CME_ClearedConfirm_1_17 value "universalSwapIdentifier" path "trade->tradeHeader"]
		[synonym CME_SubmissionIRS_1_0 value "partyTradeIdentifier" path "Instrmt->SecXML->FpML->trade->tradeHeader"]
	tradeDate TradeDate (1..1) <"The date on which the contract has been executed.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17 value "tradeHeader" path "trade"]
		[synonym CME_SubmissionIRS_1_0 value "tradeHeader" path "Instrmt->SecXML->FpML->trade"]
	clearedDate date (0..1) <"If the trade was cleared (novated) through a central counterparty clearing service, this represents the date the trade was cleared (transferred to the central counterparty).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "clearedDate" path "trade->tradeHeader"]
		[synonym FpML_5_10, CME_ClearedConfirm_1_17 value "clearedDate" path "tradeHeader"]
	tradableProduct TradableProduct (1..1) <"The tradable product information that is associated with the contract, which combines quantity and price together with the product's economic terms, identification and taxonomy. The corresponding FpML construct is the product abstract element and the associated substitution group.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17 value "trade"]

		[synonym CME_SubmissionIRS_1_0 value "trade" path "Instrmt->SecXML->FpML"]
	collateral Collateral (0..1) <"Defines the collateral obligations of a party.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "collateral" path "trade"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "collateral"]
	documentation Documentation (0..1) <"Specifies the document(s) that govern the document, either as a reference to such documents when specified as part of the CDM, or through identification of some of the key terms of those documents, such as the type of document, the document identifier, the publisher, the document vintage and the agreement date.">
	governingLaw GoverningLawEnum (0..1) <"Identification of the law governing the contract.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "governingLaw" path "trade" meta "governingLawScheme"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "governingLaw"]
	party Party (0..*) <"The parties to the contract. The cardinality is optional to address the case where the contract object is part of an event record, in which case the party is specified as part of that object. In that respect, the CDM approach is distinct from FpML, where party information is specified as part of a wrapper alongside the trade object.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "party"]
		[synonym CME_SubmissionIRS_1_0 value "party" path "Instrmt->SecXML->FpML"]
	account Account (0..*) <"Optional account information.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0 value "account"]
	partyRole PartyRole (0..*) <"The role(s) that party(ies) may have in relation to the contract, further to the principal parties (i.e payer/receive or buyer/seller) to it.">
	calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAgent" path "trade", "calculationAgent" path "contract"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAgent" path "trade->swaption", "calculationAgent" path "contract->swaption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "trade"]
	partyContractInformation PartyContractInformation (0..*) <"Additional contract information that may be provided by each involved party.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0 value "partyTradeInformation" path "trade->tradeHeader"]
		[synonym CME_ClearedConfirm_1_17 value "partyTradeInformation" path "trade->tradeHeader"]
	closedState ClosedState (0..1) <"The qualification of what led to the contract closure alongside with the dates on which this closure took effect.">
		[synonym Workflow_Event value "closedState" path "trade"]

	condition InterestRatePayoutResolvable:
		if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payoutQuantity -> assetIdentifier exists
		then tradableProduct -> quantityNotation -> assetIdentifier exists
			and tradableProduct -> quantityNotation -> assetIdentifier contains tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payoutQuantity -> assetIdentifier

	condition EquityPayoutResolvable:
		if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> assetIdentifier exists
		then tradableProduct -> quantityNotation -> assetIdentifier exists
			and tradableProduct -> quantityNotation -> assetIdentifier contains tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> assetIdentifier

//	condition CashflowResolvable:
//		if contractualProduct -> economicTerms -> payout -> cashflow -> payoutQuantity -> assetIdentifier exists
//		then contractualQuantity -> quantityNotation -> assetIdentifier exists
//			and contractualQuantity -> quantityNotation -> assetIdentifier contains contractualProduct -> economicTerms -> payout -> cashflow -> payoutQuantity -> assetIdentifier

	condition DeliverableObligationsPhysicalSettlementMatrix: <"The below set of credit deliverable obligation provisions are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions cannot be omitted if the Credit Derivatives Physical Settlement Matrix doesn't governs the terms of the contract.">
		if ( documentation -> documentationIdentification -> contractualMatrix -> matrixType <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notSubordinated
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> specifiedCurrency
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notSovereignLender
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notDomesticCurrency
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notDomesticLaw
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notContingent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notDomesticIssuance
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> assignableLoan
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> consentRequiredLoan
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> transferable
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> maximumMaturity
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> notBearer
			) exists
			and ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> fullFaithAndCreditObLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> generalFundObligationLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> revenueObligationLiability
			) exists

	condition ObligationsPhysicalSettlementMatrix: <"The below set of obligation of the reference entity are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions cannot be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in case the case where an auction could not take place because of, say, liquidity considerations.">
		if ( documentation -> documentationIdentification -> contractualMatrix -> matrixType <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notSubordinated
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notSovereignLender
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notDomesticLaw
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notDomesticIssuance
			) exists
			and (
			tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> fullFaithAndCreditObLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> generalFundObligationLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> revenueObligationLiability
			) exists

	condition CreditEventsPhysicalSettlementMatrix: <"The below set of credit events are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions can only be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in the case where an auction could not take place because of, say, liquidity considerations.">
		if ( documentation -> documentationIdentification -> contractualMatrix -> matrixType <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent )
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> bankruptcy
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> obligationDefault
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> obligationAcceleration
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> repudiationMoratorium
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> governmentalIntervention
			) exists

	condition RestructuringPhysicalSettlementMatrix: <"The below multiple holder obligation restructuring provisions is specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that this provision can only be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in the case where an auction could not take place because of, say, liquidity considerations.">
		if ( documentation -> documentationIdentification -> contractualMatrix -> matrixType <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent )
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation exists

	/*
	 * TODO - Confirm the set of Contractual Terms Supplements that qualify mortgage products
	 */
	condition AdditionalFixedPaymentsMortgages: <"The below set of additional fixed payment provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
		if ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> mortgageBackedSecurity exists
			or documentation -> documentationIdentification -> contractualTermsSupplement -> contractualTermsSupplementType = ContractualSupplementEnum -> CDSonMBS)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> interestShortfallReimbursement
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> principalShortfallReimbursement
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> writedownReimbursement
			) exists

	condition FloatingAmountEventsMortgages: <"The below set of floating amount events provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
		if ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> mortgageBackedSecurity exists
			or documentation -> documentationIdentification -> contractualTermsSupplement -> contractualTermsSupplementType = ContractualSupplementEnum -> CDSonMBS)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> failureToPayPrincipal
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> writedown
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> impliedWritedown
			) exists

	condition CreditEventsMortgages: <"The below set of credit events provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
		if ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> mortgageBackedSecurity exists
			or documentation -> documentationIdentification -> contractualTermsSupplement -> contractualTermsSupplementType = ContractualSupplementEnum -> CDSonMBS)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> failureToPayPrincipal
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> failureToPayInterest
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> distressedRatingsDowngrade
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> maturityExtension
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> writedown
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> impliedWritedown
			) exists

	condition HedgingParty: <"FpML specifies that there cannot be more than 2 hedging parties.">
		if partyRole -> role = PartyRoleEnum -> HedgingParty
		then partyRole -> role count <= 2

	condition DeterminingParty: <"FpML specifies that there cannot be more than 2 determining parties.">
		if partyRole -> role = PartyRoleEnum -> DeterminingParty
		then partyRole -> role count <= 2

	condition BarrierDerterminationAgent: <"FpML specifies that there cannot be more than 1 barrier determination agent.">
		if partyRole -> role = PartyRoleEnum -> BarrierDeterminationAgent
		then partyRole -> role count <= 1

	condition ClearedDate: <"If the cleared date exists, it needs to be on or after the trade date.">
		if clearedDate exists
		then clearedDate >= tradeDate -> date

	condition ContractualProductExists:
		tradableProduct -> product -> contractualProduct only exists

	condition FpML_cd_1: <"FpML validation rule cd-1 - If referenceInformation exists, tradeDate must be before effectiveDate/unadjustedDate.">
		if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then tradeDate -> date < tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
			or tradeDate -> date < tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> adjustedDate

	condition FpML_cd_7: <"FpML validation rule cd-7 - If condition LongForm is true, then effectiveDate/dateAdjustments exists.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> dateAdjustments exists
			or tradeDate -> date < tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> adjustedDate

	condition FpML_cd_8: <"FpML validation rule cd-8 - If condition LongForm is true, and if scheduledTerminationDate exists then scheduledTerminationDate/dateAdjustments exists.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> terminationDate -> adjustableDate -> dateAdjustments exists

	condition FpML_cd_11: <"FpML validation rule cd-11 - If condition LongForm is true, and if condition ISDA2003 is true, then allGuarantees must exist.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
			and documentation -> documentationIdentification -> contractualDefinitions = ContractualDefinitionsEnum -> ISDA2003Credit
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees exists

	condition FpML_cd_19: <"FpML validation rule cd-19 - If the condition ISDA1999Credit is true, then the following elements must not exist: protectionTerms/creditEvents/creditEventNotice/businessCenter, protectionTerms/creditEvents/restructuring/multipleHolderObligation, protectionTerms/creditEvents/restructuring/multipleCreditEventNotices, generalTerms/referenceInformation/allGuarantees, generalTerms/indexReferenceInformation, generalTerms/substitution, generalTerms/modifiedEquityDelivery.">
		if documentation -> documentationIdentification -> contractualDefinitions = ContractualDefinitionsEnum -> ISDA1999Credit
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> businessCenter
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleCreditEventNotices
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> substitution
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> modifiedEquityDelivery )
	is absent

	condition FpML_cd_20: <"FpML validation rule cd-20 - If the condition ISDA2003 is true, then protectionTerms/obligations/notContingent must not exist.">
		if documentation -> documentationIdentification -> contractualDefinitions = ContractualDefinitionsEnum -> ISDA2003Credit
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notContingent is absent

	condition FpML_cd_23: <"FpML validation rule cd-23 - If the condition LongForm is true, then cashSettlementTerms or physicalSettlementTerms must exist.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> cashSettlementTerms or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms) exists

	condition FpML_cd_24: <"FpML validation rule cd-24 - If the condition LongForm is true, then the following elements must exist: protectionTerms/creditEvents/creditEventNotice, protectionTerms/obligations, generalTerms/referenceInformation/referencePrice.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout ->generalTerms -> referenceInformation -> referencePrice
			) exists

	condition FpML_cd_25: <"FpML validation rule cd-25 - If the condition LongForm is true, and if physicalSettlementTerms exists, then physicalSettlementTerms must contain settlementCurrency, physicalSettlementPeriod, escrow and deliverableObligations/accruedInterest.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms exists
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> settlementCurrency
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> physicalSettlementPeriod
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> escrow
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> accruedInterest
			) exists

	condition FpML_cd_32: <"FpML validation rule cd-32 - If condition LongForm is true, and if fixedAmountCalculation/calculationAmount exists, then fixedAmountCalculation/dayCountFraction must exist.">
		if ( documentation -> documentationIdentification -> masterConfirmation and documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payoutQuantity -> assetIdentifier -> currency exists
			and tradableProduct -> quantityNotation -> quantity -> amount exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> dayCountFraction exists


type ContractualProduct: <" A class to specify the contractual products' economic terms, alongside their product identification and product taxonomy. The contractual product class is meant to be used across the pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">

	productIdentification ProductIdentification (0..1) <"The product identification value(s) that might be associated with a contractual product. The CDM provides the ability to associate several product identification methods with a product.">
	productTaxonomy ProductTaxonomy (0..*) <"The product taxonomy value(s) associated with a contractual product.">
	economicTerms EconomicTerms (1..1) <"The economic terms associated with a contractual product, i.e. the set of features that are price-forming.">


type FixedRateSpecification extends RateSpecificationBase: <"Type defining the specification for a fixed rate.">
	[metadata key]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "Schedule" meta "id"]

	rateSchedule Schedule (0..1) <"The fixed rate or fixed rate schedule expressed as explicit fixed rates and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">

	condition CurrencyAssetIdentifier: <"The asset identifier for a fixed interest rate must be a currency.">
		assetIdentifier -> currency only exists


type QuantityMultiplier: <" Class to specify a mechanism for a quantity to be set as a multiplier to another (reference) quantity, based on a price observation. At the moment this class only supports FX or Equity-linked notional and re-uses existing building blocks for those 2 cases, until such time when component can be made more generic. This captures the case of resetting cross-currency swaps and resetting equity swaps.">

	fxLinkedNotionalSchedule FxLinkedNotionalSchedule (0..1) <"Multiplier specified as an FX-linked schedule, e.g. for a resetting cross-currency swap..">
	multiplierValue number (0..1)
	condition: one-of


type ResolvablePayoutQuantity: <" Generic class to specify the quantity for different payout legs in a contractual product, when that quantity can vary across payout legs or across time. A resolvable quantity can always be resolved into one number based on: (i) the quantity notation that must be specified alongside the contractual product description and (ii) a given date, where applicable. In addition to the base case where quantity is directly specified as a number as part of the quantity notation, the use cases are: (i) quantity based on some pre-defined schedule (eg amortising notional), (ii) quantity based on some pre-defined events (eg resetting cross-currency notional), or quantity set as reference to another quantity (eg equity notional as no. securities x price).">
	[metadata key]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 meta "id"]
	[synonym FpML_5_10 meta "id" path "notionalAmount"]
	[synonym FpML_5_10 meta "id" path "notionalStepSchedule"]

	quantitySchedule NonNegativeQuantitySchedule (0..1) <"Quantity specified as an absolute number, (possibly) with some step schedule, (possibly) with some unit, such as the currency in the case of a notional. This attribute is optional, as long as a quantity notation tag is specified so that quantity can be resolved. There needs to be at least 1 such absolutely defined quantity across payout legs of a product, to define an anchor that other payout quantities can refer to. This is enforced by a data rule on the Payout class.">
	assetIdentifier AssetIdentifier (0..1) <"Identifier for the asset being quantified.">
		// For Swap Stream:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalAmount", "notionalStepSchedule"]
		// For FRA, CDS Single Fee, Repo, and Bond Option:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "currency"]
		// For CDS:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount"]
		// For FX:
		[synonym FpML_5_10 value "paymentAmount"]
	quantityReference ResolvablePayoutQuantity (0..1) <"Reference quantity when resolvable quantity is defined as relative to another (resolvable) quantity. A resolvable quantity needs to contain either an absolute quantity or a reference to another (resolvable) quantity. This requirement is captured by a choice rule on the class.">
		[metadata reference]
		[synonym FpML_5_10 value "relativeNotionalAmount" meta "href"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "constantNotionalScheduleReference" meta "href"]
		// For CDS Option, CDX Index Option, Bond Option, Swaption:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalReference" meta "href"]
	quantityMultiplier QuantityMultiplier (0..1) <"Quantity multiplier is specified on top of a reference quantity and is used as a multiplying factor when resolving the quantity. A quantity multiplier can only exist when the resolvable quantity specifies a reference quantity.">
	reset boolean (0..1) <"Whether the quantity is resettable">
		[synonym FpML_5_10 value "notionalReset"]
	futureValueNotional FutureValueAmount (0..1) <"The future value notional is specific to BRL CDI swaps, and is specified alongside the notional amount. The value is calculated as follows: Future Value Notional = Notional Amount * (1 + Fixed Rate) ^ (Fixed Rate Day Count Fraction). The currency should always match that expressed in the notional schedule. The value date should match the adjusted termination date.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "futureValueNotional"]

	condition Choice: <"A payout quantity can be resolved either (i) by fetching its actual quantity from a higher-level quantity notation specification referenced via an asset identifier, or (ii) by reference to another (resolvable) quantity.">
		optional choice assetIdentifier, quantityReference

	condition QuantityMultiplier: <"A quantity reference must exist when there is a quantity multiplier on a resolvable quantity.">
		if quantityMultiplier exists
		then ResolvablePayoutQuantity -> quantityReference -> reference exists

//	condition ContractualQuantity_notionalReset: <"As the notionalReset attribute applies to return swaps, the equity payout needs to be present alongside it.">
// 		if ContractualProduct -> economicTerms -> quantity -> notionalReset exists
// 		then ContractualProduct -> economicTerms -> payout -> equityPayout exists

// 	condition ContractualQuantity_notionalAdjustments: <"As the notionalAdjustments attribute applies to return swaps, the equity payout needs to be present alongside it.">
// 		if ContractualProduct -> economicTerms -> quantity -> notionalAdjustments exists
//		then ContractualProduct -> economicTerms -> payout -> equityPayout exists

type CrossCurrencyTerms:

	principalExchanges PrincipalExchanges (0..1)
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "principalExchanges"]
	settlementProvision SettlementProvision (0..1)
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "settlementProvision"]


type CreditDefaultPayout: <" The credit default payout specification provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms. The associated rosettaKey denotes the ability to associate a hash value to the CreditDefaultPayout instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 meta "id"]

	generalTerms GeneralTerms (1..1) <"The specification of the non-monetary terms for the Credit Derivative Transaction, including the buyer and seller and selected items from the ISDA 2014 Credit Definition article II, such as the reference obligation and related terms.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "generalTerms"]
	protectionTerms ProtectionTerms (1..*) <"Specifies the terms for calculating a payout to protect the buyer of the swap in the case of a qualified credit event. These terms include the notional amount, the applicable credit events, the reference obligation, and in the case of a CDS on mortgage-backed securities, the floatingAmountEvents.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "protectionTerms"]
	cashSettlementTerms CashSettlementTerms (0..*) <"Specifies the terms applicable to the cash settlement of a credit event.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "cashSettlementTerms"]
	physicalSettlementTerms PhysicalSettlementTerms (0..*) <"Specifies the terms applicable to the physical settlement of a credit event.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "physicalSettlementTerms"]
	transactedPrice TransactedPrice (0..1) <"The qualification of the price at which the contract has been transacted, in terms of market fixed rate, initial points, market price and/or quotation style. In FpML, those attributes are positioned as part of the fee leg.">

	condition FpML_cd_12: <"FpML validation rule cd-12 - If referencePrice exists, referencePrice must be greater or equal to 0">
		if generalTerms -> referenceInformation -> referencePrice exists
		then generalTerms -> referenceInformation -> referencePrice >= 0

	condition FpML_cd_13: <"FpML validation rule cd-13 - If protectionTerms/creditEvents/creditEventNotice/notifyingParty/buyerPartyReference exists, then the @href attribute of protectionTerms/creditEvents/creditEventNotice/notifyingParty/buyerPartyReference is equal to the @href attribute of generalTerms/buyerPartyReference.">
		if protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> buyerPartyReference -> reference exists
		then protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> buyerPartyReference -> reference = generalTerms -> buyerSeller -> buyerPartyReference -> reference

	condition FpML_cd_14: <"FpML validation rule cd-14 - If protectionTerms/creditEvents/creditEventNotice/notifyingParty/sellerPartyReference exists, then the @href attribute of protectionTerms/creditEvents/creditEventNotice/notifyingParty/sellerPartyReference must be equal to the @href attribute of generalTerms/sellerPartyReference.">
		if protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> sellerPartyReference -> reference exists
		then protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> sellerPartyReference -> reference = generalTerms -> buyerSeller -> sellerPartyReference -> reference

	condition Choice: <"Choice rule to represent an FpML choice construct.">
		optional choice cashSettlementTerms, physicalSettlementTerms


type EconomicTerms: <" This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, the effective and termination date and the date adjustment provisions when applying uniformily across the payout components. This class also includes the legal provisions which have valuation implications: cancelable provision, extendible provision, early termination provision and extraordinary events specification. A rosettaKeyValue is associated to the contractual product economic terms for the purpose of supporting hash-based reconciliations thanks to the fact that its computation doesn't include meta data, such as identifiers, references, schemes and other rosettaKey artefacts. The rosettaKeyValue default implementation is available as part of the generated code as org.isda.cdm.rosettakey.RosettaKeyValueHashFunction.">
	[partialKey]
	effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "effectiveDate" path "generalTerms"]
	terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "scheduledTerminationDate" path "generalTerms"]
	dateAdjustments BusinessDayAdjustments (0..1) <"The business day adjustment convention when it applies across all the payout components. This specification of the business day convention and financial business centers is used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "dateAdjustments" path "generalTerms"]
	payout Payout (1..1) <"The payout specifies the future cashflow computation methodology which characterizes a financial product.">
	earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "earlyTerminationProvision"]
	optionProvision OptionProvision (0..1) <"Cancelable and/or extendible provisions.">
	extraordinaryEvents ExtraordinaryEvents (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Extraordinary Events.">
		[synonym FpML_5_10 value "extraordinaryEvents"]

	condition ExtraordinaryEvents: <"Extraordinary events provisions must be associated with an equity payout.">
		if extraordinaryEvents exists
		then payout -> equityPayout exists

	condition FpML_cd_26_28: <"FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate. This data rule tackles those two FpML validation rules at once, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute.">
		if payout -> creditDefaultPayout exists
			and payout -> cashflow exists
			and effectiveDate exists
			and payout -> cashflow -> cashflowDate -> unadjustedDate exists
			and payout -> cashflow -> cashflowDate -> relativeDate is absent
		then payout -> cashflow -> cashflowDate -> unadjustedDate > effectiveDate -> adjustableDate -> unadjustedDate
			or payout -> cashflow -> cashflowDate -> adjustedDate > effectiveDate -> adjustableDate -> adjustedDate
			or payout -> cashflow -> cashflowDate -> relativeDate -> adjustedDate > effectiveDate -> relativeDate -> adjustedDate

	condition FpML_cd_27: <"FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
		if payout -> creditDefaultPayout exists
			and payout -> cashflow exists
			and terminationDate exists
			and payout -> cashflow -> cashflowDate exists
		then payout -> cashflow -> cashflowDate -> unadjustedDate < terminationDate -> adjustableDate -> unadjustedDate
			or payout -> cashflow -> cashflowDate -> adjustedDate < terminationDate -> adjustableDate -> adjustedDate
			or payout -> cashflow -> cashflowDate -> relativeDate -> adjustedDate < terminationDate -> adjustableDate -> adjustedDate

	condition FpML_cd_30: <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
		if ( payout -> interestRatePayout -> paymentDates -> lastPaymentDate -> lastRegularPaymentDate
			and terminationDate) exists
		then payout -> interestRatePayout -> paymentDates -> lastPaymentDate -> lastRegularPaymentDate < terminationDate -> adjustableDate -> unadjustedDate


// FIXME Object compare: effectiveDate > terminationDate
//	condition CalculationPeriodDates_effectiveDate_terminationDate: <"If the effective date and the termination date are specified, then the termination date must be after the effective date. This data rule extends the FpML validation rules ird-14 & cd-5, which scope is limited to the unadjusted date, to the adjusted date.">
//		if effectiveDate exists
//		and terminationDate exists
//		then effectiveDate > terminationDate
type EquityPayout extends PayoutBase: <" The equity payout specification terms. The associated rosettaKey denotes the ability to associate a hash value to the EquityPayout instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[synonym FpML_5_10 meta "id"]

	payerReceiver PayerReceiver (0..1)
	underlier Underlier (1..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Security">
		[synonym FpML_5_10 value "singleUnderlyer" path "underlyer", "basket" path "underlyer"]
	returnType ReturnTypeEnum (1..1) <"Specifies the type of return associated with the equity payout.">
		[synonym FpML_5_10 value "returnType" path "return"]
	dividendReturnTerms DividendReturnTerms (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Dividend Obligations">
		[synonym FpML_5_10 value "dividendConditions" path "return", "singleUnderlyer" path "underlyer"]
	priceReturnTerms PriceReturnTerms (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Pricing">
	calculationPeriodDates CalculationPeriodDates (1..1) <"The calculation period dates schedule.">
	paymentDates PaymentDates (1..1) <"The payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
		[synonym FpML_5_10 value "paymentDates" path "rateOfReturn"]
	settlementTerms SettlementTerms (1..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Settlement.">
	rateOfReturn number (0..1) <"Rate of Return calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return'.">
	performance number (0..1) <"Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance'. Cumulative performance is used as a notional multiplier factor on both legs of an Equity Swap.">

	condition DividendReturn: <"An equity price return specifies price return terms, but no dividend terms.">
		if returnType = ReturnTypeEnum -> Price
		then priceReturnTerms exists
			and dividendReturnTerms is absent

	condition PriceReturn: <"An equity dividend return specifies dividend return terms, but no price terms.">
		if returnType = ReturnTypeEnum -> Dividend
		then dividendReturnTerms exists
			and priceReturnTerms is absent

	condition TotalReturn: <"An equity total return specifies price return as well as dividend terms.">
		if returnType = ReturnTypeEnum -> Total
		then priceReturnTerms exists
			and dividendReturnTerms exists

	condition SingleUnderlier: <"In the case of an equity payout with a single underlier, that underlier needs to be an equity product.">
		if underlier exists
		then (underlier -> underlyingProduct -> security -> equity
			or underlier -> underlyingProduct -> security -> exchangeTradedFund
			or underlier -> underlyingProduct -> security -> mutualFund
			or underlier -> underlyingProduct -> security -> warrant) exists


type Execution: <" A class to specify an execution, which consists essentially in the economic terms which are agreed between the parties, alongside with the qualification of the type of execution. The associated rosettaKey denotes the ability to associate a hash value to the respective Execution instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	executionType ExecutionTypeEnum (1..1) <"Specifies the type of execution, e.g. via voice, electronically...">
		[synonym Workflow_Event value "executionType" path "trade"]
		[synonym CME_SubmissionIRS_1_0 value "VenuTyp"]
	executionVenue LegalEntity (0..1) <"The execution venue identification, when applicable.">
	identifier Identifier (1..*) <"The identifier(s) associated with the execution.">
		[synonym FpML_5_10 value "partyTradeIdentifier" path "trade->tradeHeader"]

		[synonym CME_SubmissionIRS_1_0 value "partyTradeIdentifier" path "Instrmt->SecXML->FpML->trade->tradeHeader"]
	tradeDate date (1..1) <"The trade/execution date.">
		[metadata id]
		[synonym FpML_5_10 value "tradeDate" path "trade->tradeHeader" meta "id"]
		[synonym CME_SubmissionIRS_1_0 value "tradeDate" path "Instrmt->SecXML->FpML->trade->tradeHeader" meta "id"]
	tradableProduct TradableProduct (1..1) <"The product traded as part of this execution, including quantity and price">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17 value "trade"]
		[synonym CME_SubmissionIRS_1_0 value "trade" path "Instrmt->SecXML->FpML"]
	party Party (0..*) <"The party reference is optional because positioned as part of the Event class when the execution is specified as part of such context.">
		[metadata reference]
		[synonym CME_SubmissionIRS_1_0 value "party" path "Instrmt->SecXML->FpML"]
	partyRole PartyRole (0..*) <"The role(s) that party(ies) may have in relation to the execution, further to the principal parties (i.e payer/receive or buyer/seller) to it.">
		[synonym Workflow_Event value "trade"]
	closedState ClosedState (0..1) <"The qualification of what led to the execution closure alongside with the dates on which this closure takes effect.">
		[synonym Workflow_Event value "closedState" path "trade"]
	settlementTerms SettlementTerms (0..1) <"The execution settlement terms, which is applicable for products such as securities">

	condition ExecutionVenue: <"When the execution type is set to 'Electronically', the execution venue must be specified.">
		if executionType = ExecutionTypeEnum -> Electronic
		then executionVenue exists

	condition SecurityPartyRole: <"When the executed product is a security, both ExecutingEntity and Counterparty party roles must exist.">
		if tradableProduct -> product -> security exists
		then partyRole -> role contains PartyRoleEnum -> ExecutingEntity and partyRole -> role contains PartyRoleEnum -> Counterparty

	condition SecurityPartyRoleBuyerSeller: <"When the executed product is a security, both buyer and seller party roles must exist.">
		if tradableProduct -> product -> security exists
		then partyRole -> role contains PartyRoleEnum -> Buyer and partyRole -> role contains PartyRoleEnum -> Seller

	condition SecurityPrice: <"When the executed product is a security, the price must be specified.">
		if tradableProduct -> product -> security exists
		then tradableProduct -> priceNotation -> price exists

	condition SettlementTerms: <"When the executed product is a security, the settlement terms must be specified.">
		if tradableProduct -> product -> security exists
		then settlementTerms exists

	condition QuantityInterestRatePayoutResolvable:
		if Execution -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payoutQuantity -> assetIdentifier exists
		then Execution -> tradableProduct -> quantityNotation -> assetIdentifier exists
			and Execution -> tradableProduct -> quantityNotation -> assetIdentifier contains Execution -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payoutQuantity -> assetIdentifier

	condition QuantityEquityPayoutResolvable:
		if Execution -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> assetIdentifier exists
		then Execution -> tradableProduct -> quantityNotation -> assetIdentifier exists
			and Execution -> tradableProduct -> quantityNotation -> assetIdentifier contains Execution -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> assetIdentifier

//	condition ExecutionQuantity_cashflow_resolvable:
//		if Execution -> product -> contractualProduct -> economicTerms -> payout -> cashflow -> payoutQuantity -> assetIdentifier exists
//		then Execution -> executionQuantity -> quantityNotation -> assetIdentifier exists
//			and Execution -> executionQuantity -> quantityNotation -> assetIdentifier contains Execution -> product -> contractualProduct -> economicTerms -> payout -> cashflow -> payoutQuantity -> assetIdentifier

	condition QuantityBondResolvable:
		if Execution -> tradableProduct -> product -> security -> bond -> productIdentifier exists
		then Execution -> tradableProduct -> quantityNotation -> assetIdentifier -> productIdentifier exists
			and Execution -> tradableProduct -> quantityNotation -> assetIdentifier -> productIdentifier contains Execution -> tradableProduct -> product -> security -> bond -> productIdentifier


type GeneralTerms: <" A class specifying a set of non-monetary terms for the Credit Derivative Transaction, including the buyer and seller and selected items from the ISDA 2014 Credit Definition article II, such as the reference obligation and related terms. The CDM GeneralTerms class corresponds to the FpML GeneralTerms complex type, except that the effectiveDate and scheduledTerminationDate have been positioned as part of the InterestRatePayout class in the CDM instead of in GeneralTerms.">

	buyerSeller BuyerSeller (1..1) <"The credit default payout buyer/seller parties.">
	referenceInformation ReferenceInformation (0..1) <"This attribute contains all the terms relevant to defining the reference entity and reference obligation(s).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "referenceInformation"]
	indexReferenceInformation IndexReferenceInformation (0..1) <"This attribute contains all the terms relevant to defining the Credit DefaultSwap Index.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "indexReferenceInformation"]
	basketReferenceInformation BasketReferenceInformation (0..1) <"This attribute contains all the terms relevant to defining the Credit Default Swap Basket.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "basketReferenceInformation"]
	additionalTerm string (0..*) <"This attribute is used for representing information contained in the Additional Terms field of the 2003 Master Credit Derivatives confirm.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "additionalTerm" meta "additionalTermScheme"]
	substitution boolean (0..1) <"Value of this attribute set to 'true' indicates that substitution is applicable.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "substitution"]
		[synonym Workflow_Event value "substitution"]
	modifiedEquityDelivery boolean (0..1) <"Value of this attribute set to 'true' indicates that modified equity delivery is applicable.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "modifiedEquityDelivery"]
		[synonym Workflow_Event value "modifiedEquityDelivery"]

	condition Choice: <"Choice rule to represent an FpML choice construct.">
		required choice referenceInformation, indexReferenceInformation, basketReferenceInformation

	condition FpML_cd_41: <"FpML validation rule cd-41 - If indexReferenceInformation/tranche does not exist, then modifiedEquityDelivery must not exist.">
		if indexReferenceInformation -> tranche is absent
		then modifiedEquityDelivery is absent

	condition FpML_cd_42: <"FpML validation rule cd-42 - If basketReferenceInformation does not exist, then substitution must not exist.">
		if basketReferenceInformation is absent
		then substitution is absent

	condition BasketReferenceInformationNameOrId: <"The BasketReferenceInformation requires either a basket name or a basket identifier.">
		if basketReferenceInformation exists
		then basketReferenceInformation -> basketName exists
			or basketReferenceInformation -> basketId exists

type InterestRatePayout extends PayoutBase: <" A class to specify all of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg). The associated rosettaKey denotes the ability to associate a hash value to the InterestRatePayout instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 meta "id"]

	payerReceiver PayerReceiver (0..1) <"The payer/seller paradigm applies to swap products, whether interest rate swaps or the fee leg of credit default swaps.">
	rateSpecification RateSpecification (1..1) <"The specification of the rate value(s) applicable to the contract using either a floating rate calculation, a single fixed rate, a fixed rate schedule, or an inflation rate calculation.">
	dayCountFraction DayCountFractionEnum (0..1) <"The day count fraction. The cardinality has been relaxed when compared with the FpML interest rate swap for the purpose of accommodating standardized credit default swaps which DCF is not explicitly stated as part of the economic terms. The data rule InterestRatePayout_dayCountFraction requires that the DCF be stated for interest rate products.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "dayCountFraction" path "calculationPeriodAmount->calculation" meta "dayCountFractionScheme"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "dayCountFraction" path "periodicPayment->fixedAmountCalculation" meta "dayCountFractionScheme"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "dayCountFraction" path "periodicPayment->floatingAmountCalculation" meta "dayCountFractionScheme"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "dayCountFraction"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "dayCountFraction" path "interestCalculation" meta "dayCountFractionScheme"]
	calculationPeriodDates CalculationPeriodDates (0..1) <"The parameters used to generate the calculation period dates schedule, including the specification of any initial or final stub calculation periods.">
	paymentDates PaymentDates (0..1) <"The payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the reset dates).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "paymentDates"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "periodicPayment"]
		[synonym FpML_5_10 value "interestLegPaymentDates" path "interestLegCalculationPeriodDates"]
	paymentDate AdjustableDate (0..1) <"The payment date, where only one date is specified, as for the FRA product.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "paymentDate"]
	paymentDelay boolean (0..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "paymentDelay"]
	resetDates ResetDates (0..1) <"The reset dates schedule, i.e. the dates on which the new observed index value is applied for each period and the interest rate hence begins to accrue.">
	discountingMethod DiscountingMethod (0..1) <"The parameters specifying any discounting conventions that may apply. This element must only be included if discounting applies.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "discounting" path "calculationPeriodAmount->calculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "fraDiscounting"]
	compoundingMethod CompoundingMethodEnum (0..1) <"If one or more calculation period contributes to a single payment amount this element specifies whether compounding is applicable and, if so, what compounding method is to be used. This element must only be included when more than one calculation period contributes to a single payment amount.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "compoundingMethod" path "calculationPeriodAmount->calculation"]
	cashflowRepresentation CashflowRepresentation (0..1) <"The cashflow representation of the swap stream.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "cashflows"]
	crossCurrencyTerms CrossCurrencyTerms (0..1) <"The specification of the principle exchange and settlement provision terms.">
	stubPeriod StubPeriod (0..1) <"The stub calculation period amount parameters. This element must only be included if there is an initial or final stub calculation period. Even then, it must only be included if either the stub references a different floating rate tenor to the regular calculation periods, or if the stub is calculated as a linear interpolation of two different floating rate tenors, or if a specific stub rate or stub amount has been negotiated.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "stubCalculationPeriodAmount"]
	bondReference BondReference (0..1) <"Reference to a bond underlier to represent an asset swap or Condition Precedent Bond.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "bondReference"]
	fixedAmount calculation (0..1) <"Fixed Amount Calculation">
	floatingAmount calculation (0..1) <"Floating Amount Calculation">

	condition Choice: <"The paymentDates attributes is applicable to interest rate payouts with periodic payments, while the paymentDate reflects the FpML FRA implementation where one specific date is specified.">
		optional choice paymentDates, paymentDate

	condition FutureValueNotional: <"The BRL CDI future value notional only applies to a fixed Rate Schedule.">
		if rateSpecification -> fixedRate is absent
		then payoutQuantity -> futureValueNotional is absent

	condition TerminationDate: <"FpML states that the value date associated with the future value notional should match the adjusted termination date.">
		if payoutQuantity -> futureValueNotional exists
		then payoutQuantity -> futureValueNotional -> valueDate = calculationPeriodDates -> terminationDate -> adjustableDate -> adjustedDate

	condition FpML_ird_6: <"FpML validation rule ird-6 - If paymentDates/firstPaymentDate exists, and if calculationPeriodDates/effectiveDate exists, then paymentDates/firstPaymentDate must be after calculationPeriodDates/effectiveDate/unadjustedDate.">
		if paymentDates -> firstPaymentDate exists
			and calculationPeriodDates -> effectiveDate exists
		then paymentDates -> firstPaymentDate > calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

	condition FpML_ird_8: <"FpML validation rule ird-8 - The @href attribute of payerPartyReference must not be equal to the @href attribute of receiverPartyReference. If they are equal, and if payerAccountReference and receiverAccountReference both exist, the @href attribute of payerAccountReference must not be equal to the @href attribute of receiverAccountReference">
		if InterestRatePayout exists
		then payerReceiver -> payerPartyReference <> payerReceiver -> receiverPartyReference
			or payerReceiver -> payerAccountReference <> payerReceiver -> receiverAccountReference

	condition FpML_ird_23: <"FpML validation rule ird-23 - If the initialStub exists, the calculationPeriodDates element referenced by the @href attribute of stubCalculationPeriodAmount/calculationPeriodDatesReference contains firstRegularPeriodStartDate.">
		if stubPeriod -> initialStub exists
		then calculationPeriodDates -> firstRegularPeriodStartDate exists

	condition FpML_ird_24: <"FpML validation rule ird-24 - The finalStub exists if and only if the calculationPeriodDates element referenced by calculationPeriodDates/@href contains a lastRegularPeriodEndDate.">
		if stubPeriod -> finalStub exists
		then calculationPeriodDates -> lastRegularPeriodEndDate exists

	condition InitialStubFinalStub: <"Data rule to represent the FpML nested XML construct as part of StubCalculationPeriodAmount.">
		if stubPeriod exists
		then stubPeriod -> initialStub exists
			or stubPeriod -> finalStub exists

	condition SettlementProvisionSettlementCurrency: <"FpML specifies that the SettlementProvision exists when the settlement currency is different to the notional currency of the trade.">
		if crossCurrencyTerms -> settlementProvision -> nonDeliverableSettlement exists
		then crossCurrencyTerms -> settlementProvision -> settlementCurrency <> payoutQuantity -> assetIdentifier -> currency
			or crossCurrencyTerms -> settlementProvision -> settlementCurrency <> payoutQuantity -> quantityMultiplier -> fxLinkedNotionalSchedule -> varyingNotionalCurrency

	/*
	 * TODO - Need for an associated logic that will parse the respective legs of the swap, as this is not made explicit at present as part of the syntax
	 */
	condition FpML_ird_7_1: <"FpML validation rule ird-7 1/2 - The existence of compoundingMethod is prohibited when the calculation period and payment frequencies are the same.">
		if paymentDates -> paymentFrequency -> period = calculationPeriodDates -> calculationPeriodFrequency -> period
			and paymentDates -> paymentFrequency -> periodMultiplier = calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier
		then ( compoundingMethod is absent or compoundingMethod = CompoundingMethodEnum -> None)

	condition FpML_ird_7_2: <"FpML validation rule ird-7 2/2 - The existence of compoundingMethod is required when the calculation period and payment frequencies differ.">
		if (( paymentDates -> paymentFrequency -> period and calculationPeriodDates -> calculationPeriodFrequency -> period) exists
			and paymentDates -> paymentFrequency -> period <> calculationPeriodDates -> calculationPeriodFrequency -> period)
			or (( paymentDates -> paymentFrequency -> periodMultiplier and calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier) exists
			and paymentDates -> paymentFrequency -> periodMultiplier <> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
		then compoundingMethod exists

	condition FpML_ird_9: <"FpML validation rule ird-9 - If calculationPeriodAmount/calculation/compoundingMethod exists, then resetDates must exist.">
		if compoundingMethod exists
		then resetDates exists

	condition FpML_ird_29: <"FpML validation rule ird-29 - If compoundingMethod exists, then fixedRateSchedule must not exist.">
		if compoundingMethod exists
		then rateSpecification -> fixedRate is absent

	condition CalculationPeriodDatesFirstCompoundingPeriodEndDate: <"FpML specifies that the firstCompoundingPeriodEndDate must only be specified when the compounding method is specified and not equal to a value of None.">
		if compoundingMethod is absent
			or compoundingMethod = CompoundingMethodEnum -> None
		then calculationPeriodDates -> firstCompoundingPeriodEndDate is absent


type OptionExercise: <" A class to represent the applicable terms to qualify an option exercise: the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">

	optionStyle OptionStyle (1..1) <"The option exercise can be of American style, Bermuda style or European style. The FpML implementation makes use of a substitution group.">
	strike OptionStrike (0..1) <"Specifies the strike of the option on credit default swap.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "strike"]
	exerciseProcedure ExerciseProcedure (0..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "exerciseProcedure"]
	settlement OptionSettlement (0..1) <"The option settlement terms, such as cash vs. physical, the settlement date, the settlement currency and/or amount. FpML represents this information as part of the OptionSettlement.model.">


type OptionPayout extends PayoutBase: <" The option payout specification terms. The associated rosettaKey denotes the ability to associate a hash value to the respective OptionPayout instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 meta "id"]

	buyerSeller BuyerSeller (1..1)
	optionType OptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "optionType"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 set to OptionTypeEnum -> Straddle when "swaptionStraddle" = True]
	feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "feature"]
	denomination OptionDenomination (0..1) <"The denomination qualifies the number of units of underlier per option and the number of options comprised in the option transaction. FpML represents this information as part of the OptionDenomination.model.">
	exerciseTerms OptionExercise (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
	underlier Underlier (1..1) <"The product underlying the option, which can be of any type including ContractualProduct or Security.">
		[synonym CME_ClearedConfirm_1_17 hint "swap"]

type SecurityLeg: <" Terms defining a security leg in a securities financing transaction, which can either be the near leg or the far leg and is closely modelled onto the nearLeg and farLeg types in FpML">
	[metadata key]
	[synonym FpML_5_10 meta "id"]

	buyerSeller BuyerSeller (1..1) <"Whether the leg is a buyer or seller of security">
	settlementDate AdjustableOrRelativeDate (1..1) <"Settlement or Payment Date for the security leg">
		[synonym FpML_5_10 value "settlementDate"]
	settlementAmount Money (0..1) <"Settlement amount for the security leg">
		[synonym FpML_5_10 value "settlementAmount"]
	settlementCurrency string (0..1) <"Settlement Currency for use where the Settlement Amount cannot be known in advance.">
		[synonym FpML_5_10 value "settlementCurrency"]
	fxRate ExchangeRate (0..1) <"FX rate in case when cash settlement amount is in a different currency to the security.">
	deliveryDate AdjustableOrRelativeDate (0..1) <"Delivery Date for the transaction. Delivery Date can be populated when it is not equal to the Settlement Date.">
		[synonym FpML_5_10 value "deliveryDate"]
	deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">
		[synonym FpML_5_10 value "deliveryMethod"]
	condition Choice:
		required choice settlementAmount, settlementCurrency


type SecurityValuation: <" Terms defining the security valuation method as part of a security leg in a securities fianncing transaction and closely modelled onto the CollateralValuation type in FpML.">

	securityValuationModel SecurityValuationModel (1..1) <"The security valuation model choice, based on either a nominal amount or a number of units.">
		[synonym FpML_5_10 value "collateral"]
	underlier Security (1..1) <"The underlying security of the security leg.">


type SecurityValuationModel: <" The security valuation model choice, which can either be based on nominal amount as for a bond, or on the number of contract units as for equity.">

	bondValuationModel BondValuationModel (0..1) <"The valuation model when the security is a bond.">
	unitContractValuationModel UnitContractValuationModel (0..1) <"The valuation model when the security is a unit contract like equity.">
	condition: one-of

type BondValuationModel: <" Bond valuation model for the security leg in a securities financing transaction, closely modelled onto the BondCollateral.model in FpML.">

	nominalAmount Money (1..1) <"The quantity of the underlier expressed as a nominal amount.">
		[synonym FpML_5_10 value "nominalAmount"]
	bondPriceAndYieldModel BondPriceAndYieldModel (1..1) <"Price and yield model for valuing a bond security leg.">
	accrualsAmount Money (0..1) <"Accruals amount for the bond in the security leg">


type BondPriceAndYieldModel: <" Bond price and yield valuation model for the security leg in a securities financing transaction, closely modelled onto the BondPriceAndYield.model in FpML.">

	cleanOrDirtyPrice CleanOrDirtyPrice (0..1) <"Either the clean or dirty price of the bond.">
	relativePrice RelativePrice (0..1) <"Bond price relative to a Benchmark.">
	yieldToMaturity number (0..1) <"Price specified as a yield to maturity.">
	inflationFactor number (0..1) <"The inflation factor is specified for inflation-linked products which require some additional elements to calculate prices correctly.">
	allInPrice number (0..1) <"Bond all-in-price which is a price that includes all relevant price adjustments (i.e. accrued interest, haircut or margin ratio, inflation factor,etc.). It expresses a price in terms of percentage of nominal amount.">


type CleanOrDirtyPrice: <" Class specifying the bond price as either clean or dirty in a bond valuation model.">

	cleanPrice CleanPrice (0..1) <"The clean price and accruals presented separately.">
	dirtyPrice number (0..1) <"The dirty price presented as a single number.">
		[synonym FpML_5_10 value "dirtyPrice"]


type CleanPrice: <" Class to specify the clean price of a bond in a bond valuation model, with accruals presented separately, and modelled onto the cleanPrice model in BonPriceAndYield.model in FpML.">

	cleanPrice number (1..1) <"The clean price as a number.">
		[synonym FpML_5_10 value "cleanPrice"]
	accruals number (0..1) <"The accruals as a number.">
		[synonym FpML_5_10 value "accruals"]
	dirtyPrice calculation (0..1) <"Placeholder for a calculation of dirtyPrice based on cleanPrice and accruals.">


type RelativePrice: <" Bond price relative to a benchmark, as in a convertible bond.">

	spread number (1..1) <"The spread to a benchmark.">
	bondEquityModel BondEquityModel (1..*) <"Bond equity model for convertible bonds.">


type BondEquityModel: <" Bond equity model to value convertible bonds and modelled onto BondEquity.model in FpML.">

	bondchoiceModel BondChoiceModel (0..1) <"Either the bond or convertible bond.">
	equity Equity (0..1) <"The equity.">
	condition: one-of

type BondChoiceModel: <" Either a bond or convertible bond.">
	bond Bond (0..1)
	convertibleBond ConvertibleBond (0..1)
	condition: one-of

type UnitContractValuationModel: <" Unit contract model for security valuation, e.g. for equity, modelled onto UnitContract.model in FpML.">

	numberOfUnits Quantity (1..1) <"The number of units (index or securities).">
	unitPrice Money (1..1) <"The price of each unit.">


type SecurityPayout: <" Security payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction.">
	[metadata key]
	securityLeg SecurityLeg (1..*) <"Each SecurityLeg represent a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
		[synonym FpML_5_10 value "nearLeg"]
		[synonym FpML_5_10 value "farLeg"]
	// TO DO: triParty, collateral substitutions, callDate and callingParty for an evergreen transaction (or should this be part of an Option Payout?)
	initialMargin InitialMargin (0..1) <"RepoDurationEnum.">
		[synonym FpML_5_10 value "initialMargin"]
	repoDuration RepoDurationEnum (0..1) <"A duration code for the repo transaction. This defines a type of a repo transaction with fixed duration.">
		[synonym FpML_5_10 value "duration"]
	securityValuation SecurityValuation (1..*) <"The underlying securities and their valuation for the security leg.">
		[synonym FpML_5_10 value "nearLeg", "bond"]


type InitialMargin: <" Defines initial margin applied to a repo transaction. Initial margin is an agreed premium to the Purchase Price of a repo to determine the required Market Value of the collateral to be delivered on the Purchase Date. It reflects quality of the collateral. Its aim is to calculate the risk-adjusted or liquidation value of collateral.">

	marginType MarginTypeEnum (1..1) <"An element defining the type of assets (cash or securities) specified to apply as margin to the repo transaction. See GMRA 2011 paragraph 2(h) for 'Cash Margin' and GMRA 2011 paragraph 2(cc) for 'Margin Securities'.">
		[synonym FpML_5_10 value "marginType"]
	margin InitialMarginCalculation (1..*) <"Initial margin calculation for a collateral asset. Initial margin requirements may be specified for multiple pieces of collateral.">
		[synonym FpML_5_10 value "margin"]
	marginThreshold Money (0..1) <"An element defining a margin threshold which is the Net Exposure of a trade below which parties agree they will not call a margin from each other.">
		[synonym FpML_5_10 value "marginThreshold"]
	minimumTransferAmount Money (0..1) <"An element defining a minimum transfer amount which is the minimum margin call parties will make once the margin threshold (or margin ratio threshold / haircut threshold) has been exceeded.">
		[synonym FpML_5_10 value "minimumTransferAmount"]

	condition MarginThreshold:
		if marginThreshold exists
		then marginThreshold -> amount > 0

	condition MinimumTransferAmount:
		if minimumTransferAmount exists
		then minimumTransferAmount -> amount > 0

type InitialMarginCalculation: <" Defines the initial margin calculation applicable to a single piece of collateral.">

	marginRatio number (0..1) <"An element defining an initial margin expressed as a ratio of the Market Value of the collateral to the Purchase Price. A default value of initial margin ratio of 1.00 means there is no margin and thus no risk related with the collateral. See GMRA 2000 paragraph 2(z) and GMRA 2011 paragraph 2(bb).">
		[synonym FpML_5_10 value "marginRatio"]
	marginRatioThreshold number (0..2) <"An element defining a margin ratio threshold which is the value above (when it's lower than initial margin ratio) or below (when it's higher than initial margin ratio) which parties agree they will not call a margin from each other.">
		[synonym FpML_5_10 value "marginRatioThreshold"]
	haircut number (0..1) <"An element defining a haircut expressed as the percentage difference between the Market Value of the collateral and the Purchase Price of the repo and calculated as 100 multiplied by a ratio of the difference between the Market Value of the collateral and the Purchase Price of the repo to the Market Value of the collateral. Haircut is alternative way to adjust the value of collateral sold in a repurchase agreement to initial margin ratio. Because an initial margin is a percentage of the Purchase Price, while a haircut is a percentage of the Market Value of collateral, the arithmetic of initial margins and haircuts is slightly different. For example, an initial margin of 102% is not equivalent to a haircut of 2%, but to 1.961% (ie 100/102%). See GMRA 2011 paragraph 2(aa).">
		[synonym FpML_5_10 value "haircut"]
	haircutThreshold number (0..2) <"An element defining a haircut percentage threshold which is the value above (when it's lower than initial haircut) or below (when it's higher than initial haircut) which parties agree they will not call a margin from each other.">
		[synonym FpML_5_10 value "haircutThreshold"]

	condition Choice:
		required choice marginRatio, haircut

/*
 * TO DO ON SECURITY PAYOUT:

 * Move all implementation of SecurityPayout to a dedicated file

 * type rules to add for security payout:
 * - underliers are the same in each collateral leg
 * - number of collateral legs (2)?
 * - one leg is a buyer and the other is a seller
 * - the underlying security reference in SecurityValuation matches either the Bond or Equity reference in the further SecurityValuationModel

 * Have appropriate synonyms vs the repo model in FpML
 */
type PayoutBase: <" Base class that all payout types should extend. Use case is that some validation rules may need to apply across all payout types, for which the data rule can be written at the base class level">

	payoutQuantity ResolvablePayoutQuantity (1..1) <"Each payout leg must implement the quantity concept as a 'resolvable' type, which allows for different payout legs to be linked to each other (e.g. in the case of cross-curreny products).">
		// For Equity Swap:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notional"]
		[synonym FpML_5_10 value "rateOfReturn"]
		// For Swap Stream:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalSchedule" path "calculationPeriodAmount->calculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fxLinkedNotionalSchedule" path "calculationPeriodAmount->calculation"]
		// For CDS:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount" path "periodicPayment->fixedAmountCalculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount" path "periodicPayment->floatingAmountCalculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fixedAmount"]
		// For FX:
		[synonym FpML_5_10 hint "paymentAmount"]
		// For Repo:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "settlementAmount" path "nearLeg"]
		// For BRL CDI swaps:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculation" path "calculationPeriodAmount"]
		// For CDS Option:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "notionalReference"]
		// For Bond Option:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalAmount"]

type Payout: <" A class to represent the set of future cashflow methodologies in the form of specific payout class(es) that can be associated for the purpose of specifying a financial product. For example, two interest rate payouts can be combined to specify an interest rate swap, or one interest rate payout can be combined with a credit default payout to specify a credit default swap.">

	interestRatePayout InterestRatePayout (0..*) <"All of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg).">
		// For Swap Stream
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "swapStream"]
		// For CapFloor:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "capFloorStream"]
		// For FRA:
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value "fra" mapper "FRAIRPSplitter"]
		// For CDS:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "generalTerms", "feeLeg" set when "feeLeg->periodicPayment" exists]
		// For Equity Swap
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "interestLeg"]
		// For Repo:
		[synonym FpML_5_10 value "repo"]
	creditDefaultPayout CreditDefaultPayout (0..1) <"The credit default payout, which provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms.">
	equityPayout EquityPayout (0..*) <"The equity payout, which encompasses the equity price returns, dividend returns, volatility and variance return provisions.">
		[synonym FpML_5_10 value "returnLeg"]
		[synonym CME_SubmissionIRS_1_0 value "ignore"]
	optionPayout OptionPayout (0..*) <"The option payout.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "swaption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "creditDefaultSwapOption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "bondOption"]
	forwardPayout ForwardPayout (0..*)
		[synonym FpML_5_10 value "fxSingleLeg"]
		[synonym CME_SubmissionIRS_1_0 value "ignore"]
	securityPayout SecurityPayout (0..*) <"The security payout when the product involves some form of securities, such as collateral in a securities financing transaction">
		[synonym FpML_5_10 value "repo"]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value "ignore"]
	cashflow Cashflow (0..*) <"A cashflow between the parties to the trade. For interest rate and equity products, this corresponds to the FpML additionalPayment element. For credit default swaps, this corresponds to the FpML initialPayment element and the singlePayment element of the fee leg. For option products, it represents the FpML premium element.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "additionalPayment"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "initialPayment" path "feeLeg"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "singlePayment" path "feeLeg"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "singlePayment"]
		// TODO - The below 2 attributes are not properly mapped.  This needs to be addressed as part of this Trello card https://trello.com/c/488uoZcS
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "paymentDelay"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "payerReceiver"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "premium" path "swaption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "premium" path "bondOption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "premium" path "creditDefaultSwapOption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "otherPartyPayment"]

	condition LastRegularPaymentDate: <"FpML specifies that lastRegularPaymentDate must only be included if there is a final stub. As part of the CDM, this data rule has been adjusted to specify that it only applies to interest rate swaps, as the credit derivatives products can have a specified lastRegularPaymentDate while the stub is typically not applicable to those.">
		if interestRatePayout -> paymentDates -> lastPaymentDate -> lastRegularPaymentDate exists
			and interestRatePayout -> stubPeriod -> finalStub exists
		then interestRatePayout count = 2

//	condition Payout_quantity: <"There must be at least 1 anchor quantity defined in absolute across all payout legs, that other legs can reference. Currently only implemented for interest rate or equity payout. As an additional constraint the (initial) value should be 1.0, which means payout is defined for a single unit. This constraint may be relaxed in future where the initial value could be used as a unit divider, to facilitate the step notional case where using large numbers is more readable.">
//	 	if equityPayout exists
//	 		or interestRatePayout exists
//	 	then ( equityPayout -> payoutQuantity -> quantitySchedule exists
//	 			and equityPayout -> payoutQuantity -> quantitySchedule -> amount = 1.0 )
//	  		or ( interestRatePayout -> payoutQuantity -> quantitySchedule exists
//	 and interestRatePayout -> payoutQuantity -> quantitySchedule -> amount = 1.0 )

	condition PayRelativeTo: <"FpML specifies a required payRelativeTo element as part of the PaymentDates. As standardized CDS don't have such payRelativeTo provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
			and interestRatePayout -> paymentDates exists
		then interestRatePayout -> paymentDates -> payRelativeTo exists

	condition PaymentDatesAdjustments: <"FpML specifies a required paymentDatesAdjustments element as part of the PaymentDates. As standardized CDS don't have such paymentDatesAdjustments provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
			and interestRatePayout -> paymentDates exists
		then interestRatePayout -> paymentDates -> paymentDatesAdjustments exists

	condition PaymentFrequency: <"FpML specifies a required paymentFrequency element as part of the PaymentDates. As standardized CDS may not have such paymentFrequency provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
			and interestRatePayout -> paymentDates exists
		then interestRatePayout -> paymentDates -> paymentFrequency exists

	condition Quantity: <"When there an InterestRatePayout but no creditDefaultPayout nor optionPayout, the notional must be specified. The notional of a credit default swap is expressed as part of the protection terms.">
		if interestRatePayout exists
			and creditDefaultPayout is absent
			and optionPayout is absent
		then interestRatePayout -> payoutQuantity exists

	condition DayCountFraction: <"FpML specifies a required dayCountFraction element as part of the swapStream/calculationPeriodAmount/calculation. As standardized CDS don't have such specified day count fraction, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
		then interestRatePayout -> dayCountFraction exists

	condition PaymentDates: <"FpML specifies a required paymentDates element as part of the swapStream. As standardized CDS may not have specified payment dates, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
		if interestRatePayout count = 2
		then interestRatePayout -> dayCountFraction exists

	condition MarketPrice: <"FpML specifies that marketFixedRate and marketPrice only have meaning in a credit index trade">
		if creditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
		then creditDefaultPayout -> transactedPrice -> marketFixedRate is absent
			and creditDefaultPayout -> transactedPrice -> marketPrice is absent

type Product: <" A class to represent a financial product. With respect to contractual products, this class specifies the pre-execution product characteristics (the ContractualProduct class). This class is used as underlying for the option exercise representation, which makes use of the contractualProduct attribute to support the swaption use case, with the exercise into a swap. In a complete workflow, the swaption contract itself then needs to be superseded by a swap contract underpinned by the exercised swap as a contractualProduct.">
	[metadata key]

	contractualProduct ContractualProduct (0..1)
		// For Equity Swap:
		[synonym FpML_5_10 value "returnSwap", "equitySwapTransactionSupplement"]
		// For Swap Stream:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "swap"]
		// For Swaption:
		[synonym FpML_5_10 value "swaption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "swaption"]
		// For CapFloor:
		[synonym FpML_5_10 value "capFloor"]
		// For FRA:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "fra"]
		// For Bond Options:
		[synonym FpML_5_10 hint "bondOption"]
		// For CDS:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "creditDefaultSwap"]
		// For CDS Option
		[synonym FpML_5_10 hint "creditDefaultSwapOption"]
		// For FX:
		[synonym FpML_5_10 hint "fxSingleLeg"]
		// For Repo:
		[synonym FpML_5_10 hint "repo"]
		// To handle the case when addition payments are part of the trade - TODO: should be part of the event,  not the contract
		[synonym FpML_5_10 hint "otherPartyPayment"]
	index Index (0..1)
		[synonym FpML_5_10 value "index"]
	loan Loan (0..1)
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "loan"]
	foreignExchange ForeignExchange (0..1)
	security Security (0..1)
	condition: one-of

type TradableProduct: <"Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this product plus an (optional) mechanism for any potential future quantity adjustment.">
	product Product (1..1) <"The underlying product to be included in a contract or execution.">
	// TODO: Make quantity and price notations non optional, once migration complete
	quantityNotation QuantityNotation (1..*) <"Quantity of the underlying product to be included in a contract or execution. Products, including contractual products, are defined as a unit in CDM, with quantity schedule and cross-referencing mechanisms handled as part of the underlying payout legs, so that the overall quantity can be abstracted away from the product definition. Multiple quantity notations can be specified, as in the case of cross-currency products. Each quantity notation includes a tag (e.g. asset identifier) that can referenced by the underlying payout legs to resolve that product by fetching the actual amount from the appropriate quantity notation. The synonym paths to FpML will tend to be quite deep, as we need to extact those values from where they are embedded within the product definition.">
		// For Equity Swap:
		[synonym FpML_5_10 value "notional" path "returnSwap->returnLeg", "notional" path "equitySwapTransactionSupplement->returnLeg"]
		[synonym FpML_5_10 value "underlyer" path "returnSwap->returnLeg", "underlyer" path "equitySwapTransactionSupplement->returnLeg"]
		// For Swap Stream, incl. Swaption and CapFloor:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalSchedule" path "swap->swapStream->calculationPeriodAmount->calculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalSchedule" path "capFloor->capFloorStream->calculationPeriodAmount->calculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalSchedule" path "swaption->swap->swapStream->calculationPeriodAmount->calculation"]
		// For BRL CDI swaps
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "futureValueNotional" path "swap->swapStream->calculationPeriodAmount->calculation"]
		// For FRA:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fra"]
		// For CDS
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "protectionTerms" path "creditDefaultSwap"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fixedAmountCalculation" path "creditDefaultSwap->feeLeg->periodicPayment"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingAmountCalculation" path "creditDefaultSwap->feeLeg->periodicPayment"]
		// For CD Swaption
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "protectionTerms" path "creditDefaultSwapOption->creditDefaultSwap"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fixedAmountCalculation" path "creditDefaultSwapOption->creditDefaultSwap->feeLeg->periodicPayment"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingAmountCalculation" path "creditDefaultSwapOption->creditDefaultSwap->feeLeg->periodicPayment"]
		// For FX:
		[synonym FpML_5_10 value "exchangedCurrency1" path "fxSingleLeg"]
		[synonym FpML_5_10 value "exchangedCurrency2" path "fxSingleLeg"]
		[synonym Workflow_Event value "cashflow"]
		// For Repo:
		[synonym FpML_5_10 value "nearLeg" path "repo"]
		// For Bond Option:
		[synonym FpML_5_10 value "notionalAmount" path "bondOption"]
	priceNotation PriceNotation (0..*) <"Price of the underlying product to be included in a contract or execution. Contractual products are defined as price-less in the CDM, with the actual price number(s) abstracted away from the product definition. Multiple price notations can be specified and the notation specifies the tags (e.g. asset identifier) allowing price to be then appropriately positioned in the contractual product. The synonym paths to FpML will tend to be quite deep, as we are extacting those values from where they are embedded within the product definition.">
		// For Swap Streams:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "swapStream" path "swap"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "additionalPayment" path "swap"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "capFloorStream" path "capFloor"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "otherPartyPayment"]
		// For Equity Swaps
		[synonym FpML_5_10 value "returnLeg" path "returnSwap"]
		[synonym FpML_5_10 value "returnLeg" path "equitySwapTransactionSupplement"]
		[synonym FpML_5_10 value "interestLeg" path "returnSwap"]
		// For Swaptions:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "premium" path "swaption"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "swapStream" path "swaption->swap"]
		// For CD Index and CDS
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "initialPayment" path "creditDefaultSwap->feeLeg"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "singlePayment" path "creditDefaultSwap->feeLeg"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "periodicPayment" path "creditDefaultSwap->feeLeg"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "periodicPayment" path "creditDefaultSwapOption->creditDefaultSwap->feeLeg"]
		// For FRA:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fra"]
		// For CD Swaption:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "premium" path "creditDefaultSwapOption"]
		// For Bond Options:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "premium" path "bondOption"]
		// For FX
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fxSingleLeg"]
		// For Repo:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "repo"]

	// TBD: make quantity and price notation optional, and only validate that it exists as part of an execution / contract?
	// TBD: positioning of future DateNotation (Effective Date, Termination Date) - only applicable to contractual products. In EconomicTerms?
	// TBD: positioning of future PartyNotation - as part of this type, or higher-up in the Execution / Contract?
	// The latter would align the concept of TradeableProduct across securities and contractual products (securities do not require any party specification to be "tradeable")
	adjustment NotionalAdjustmentEnum (0..1) <"Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfolio rebalancing etc. It is typically used in the context of Equity Swaps.">
		[synonym FpML_5_10 value "notionalAdjustments" path "returnSwap->returnLeg", "notionalAdjustments" path "equitySwapTransactionSupplement->returnLeg"]

	condition PriceQuantityTriangulation:
		PriceQuantityTriangulation( priceNotation, quantityNotation ) = True

type ProductIdentification: <" A class to combine the CDM product qualifier with other product qualifiers, such as the FpML ones. While the CDM product qualifier is derived by the CDM from the product payout features, the other product identification elements are assigned by some external sources and correspond to values specified by other data representation protocols.">

	productQualifier productType (0..1) <"The CDM product qualifier, which corresponds to the outcome of the isProduct qualification logic. This value is derived by the CDM from the product payout features.">
	primaryAssetdata AssetClassEnum (0..1) <" A classification of the most important risk class of the trade. FpML defines a simple asset class categorisation using a coding scheme.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "primaryAssetClass" meta "assetClassScheme"]
	secondaryAssetdata AssetClassEnum (0..*) <" A classification of additional risk classes of the trade, if any. FpML defines a simple asset class categorisation using a coding scheme.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "secondaryAssetClass" meta "assetClassScheme"]
	productType string (0..*) <"A classification of the type of product. FpML defines a simple product categorisation using a coding scheme.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "productType" meta "productTypeScheme"]

	productId string (0..*) <"A product reference identifier. The product Id is an identifier that describes the key economic characteristics of the trade type, with the exception of concepts such as size (notional, quantity, number of units) and price (fixed rate, strike, etc.) that are negotiated for each transaction. It can be used to hold identifiers such as the 'UPI' (universal product identifier) required by certain regulatory reporting rules. It can also be used to hold identifiers of benchmark products or product temnplates used by certain trading systems or facilities. FpML does not define the domain values associated with this element. Note that the domain values for this element are not strictly an enumerated list.">
		[metadata scheme]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "productId" meta "productIdScheme"]


type QuantityNotation: <"Specification of a product's quantity as a single, non-negative amount. The asset identifier qualifies the quantity being specified and can be used as a referencing mechanism in the underlying payout legs to 'resolve' the product, by fetching the actual amount from the appropriate quantity notation. For some product cases, several quantity notations can be associated with a single product: e.g. for an Equity Swap, both the notional and (optionally) the number of securities can be specified, with a validation to check that they are consistent in relation to the equity price. ">

	quantity NonNegativeQuantity (1..1) <"The quantity as a non-negative amount.">
		// For Swap Streams:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalStepSchedule"]
		// For Swap Streams, Equity Swaps and Bond Options:
		[synonym FpML_5_10 value "notionalAmount"]
		// For BRL CDI swaps:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "amount"]
		// For Equity Swaps:
		[synonym FpML_5_10 value "singleUnderlyer"]
		// For FRA:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notional"]
		// For CDS:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount"]
		// For FX:
		[synonym FpML_5_10 value "paymentAmount"]
		// For Repo:
		[synonym FpML_5_10 value "settlementAmount"]
	assetIdentifier AssetIdentifier (1..1) <"identifier for the asset being quantified, allowing it to be positioned in the product definition.">
		// For Swap Stream:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalStepSchedule"]
		// For Swap Streams, Equity Swaps and Bond Options:
		[synonym FpML_5_10 value "notionalAmount"]
		// For BRL CDI swaps:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "currency"]
		// For Equity Swaps
		[synonym FpML_5_10 value "singleUnderlyer" set when "singleUnderlyer->openUnits" exists]
		// For FRA and CDS single fee:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notional"]
		// For CDS:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount"]
		// For FX:
		[synonym FpML_5_10 value "paymentAmount"]
		// For Repo:
		[synonym FpML_5_10 value "settlementAmount"]

	condition CurrencyAmount: <"When quantity type is specified as a currency amount, the quantity must be specified without unit.">
		if assetIdentifier -> currency exists then quantity -> unit is absent


type PriceNotation: <"Object to specify the price of a product as a single number, which can be negative in some cases, and asset identifier so that it can be positioned in the product. For some product cases, several price notations can be associated with a single product: e.g. for an Equity Swap, both the initial equity price and the rate spread can be specified, which allows factoring of the product definition.">

	price Price (1..1) <"Price expressed as a number.">
	assetIdentifier AssetIdentifier (0..1) <"Identifier for the asset being priced.">
		// For fixedRate:
		// For Swap Streams etc
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalStepSchedule" path "calculationPeriodAmount->calculation->notionalSchedule" set when "calculationPeriodAmount->calculation->fixedRateSchedule" exists]
		// For Equity Swaps
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "singleUnderlyer" path "underlyer"]
		// For CDS
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount" path "fixedAmountCalculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fixedAmount"]
		// For FRA
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notional"]

		// For floatingRate:
		// For Swap Streams etc
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRateCalculation" path "calculationPeriodAmount->calculation"
			set when "calculationPeriodAmount->calculation->floatingRateCalculation->floatingRate" exists,
			set when "calculationPeriodAmount->calculation->floatingRateCalculation->initialRate" exists,
			set when "calculationPeriodAmount->calculation->floatingRateCalculation->spreadSchedule" exists,
			set when "calculationPeriodAmount->calculation->floatingRateCalculation->capRateSchedule" exists,
			set when "calculationPeriodAmount->calculation->floatingRateCalculation->floorRateSchedule" exists]
		// For Equity Swaps
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRateCalculation" path "interestCalculation" set when "interestCalculation->floatingRateCalculation->spreadSchedule" exists]
		// For Repo
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRateCalculation" set when "floatingRateCalculation->spreadSchedule" exists]
		// For CD Index
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingAmountCalculation" set when "floatingAmountCalculation->floatingRate" exists]

	condition CurrencyAssetIdentifier: <"The asset identifier for a fixed interest rate must be a currency.">
		if price -> fixedInterestRate exists
		then assetIdentifier -> currency only exists

	condition RateOptionAssetIdentifier: <"The asset identifier for an interest rate spread must be a rate option.">
		if price -> interestRateSpread exists
		then assetIdentifier -> rateOption only exists


// TODO: Create "RateSpecificationBase" and position "assetIdentifier" as an attribute, then each of the 3 rate specifications below should inherit from it.
// NOTE: floating rates will no longer inherit from "FloatingRateOption", instead the rate option will be contained in "assetIdentifier"
// Then implement data rules to verify that we have the right type of "AssetIdentifier" for a fixed or floating rate
type RateSpecificationBase:
	assetIdentifier AssetIdentifier (0..1)
		// For fixedRate:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notionalStepSchedule" path "notionalSchedule"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "currency"]
		// For floatingRate:
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "floatingRateIndex"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "indexTenor"]


type RateSpecification: <" A class to specify the fixed interest rate, floating interest rate or inflation rate.">

	fixedRate FixedRateSpecification (0..1) <"The fixed rate or fixed rate specification expressed as explicit fixed rates and dates.">
		// For Swap Streams etc
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculation" path "calculationPeriodAmount" set when "calculationPeriodAmount->calculation->fixedRateSchedule" exists]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationAmount" path "periodicPayment->fixedAmountCalculation"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "fixedRate" path "periodicPayment->fixedAmountCalculation"]
		// For FRA
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "notional"]
	floatingRate FloatingRateSpecification (0..1) <"The floating interest rate specification, which includes the definition of the floating rate index. the tenor, the initial value, and, when applicable, the spread, the rounding convention, the averaging method and the negative interest rate treatment.">
		// For Swap Streams etc
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRateCalculation" path "calculationPeriodAmount->calculation"]
		// For Equity Swaps
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRateCalculation" path "interestCalculation"]
		// For Repo
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRateCalculation"]
		// For CD Index
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "floatingRate" path "periodicPayment->floatingAmountCalculation"]
		// For FRA
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "floatingRateIndex"]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 hint "indexTenor"]
	inflationRate InflationRateSpecification (0..1) <"An inflation rate calculation definition.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "inflationRateCalculation" path "calculationPeriodAmount->calculation"]
	condition: one-of

type StubPeriod: <" A class defining how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or final stub calculation period may be the linear interpolation of two different tenors for the floating rate index specified in the calculation period amount component, e.g. A two month stub period may used the linear interpolation of a one month and three month floating rate. The different rate tenors would be specified in this component. Note that a maximum of two rate tenors can be specified. If a stub period uses a single index tenor and this is the same as that specified in the calculation period amount component then the initial stub or final stub component, as the case may be, must not be included.">
	[synonym FpML_5_10 value "StubCalculationPeriodAmount"]

	calculationPeriodDatesReference CalculationPeriodDates (1..1) <"A pointer style reference to the associated calculation period dates component defined elsewhere in the document.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "calculationPeriodDatesReference" meta "href"]
	initialStub StubValue (0..1) <"Specifies how the initial stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "initialStub"]
	finalStub StubValue (0..1) <"Specifies how the final stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "finalStub"]

/*
 * QUESTION TO CDM GROUP
 * TODO - FpML sample credit trades don't include examples that specify those attributes
 * Would be great if we could confirm the actual usage though sample transactions
 * See Trello card https://trello.com/c/VLtPwoek
 */
type TransactedPrice: <" A class to represent the transacted price attributes that are positioned as part of the FpML FeeLeg.">

	marketFixedRate number (0..1) <"An optional element that only has meaning in a credit index trade. This element contains the credit spread ('fair value') at which the trade was executed. Unlike the fixedRate of an index, the marketFixedRate varies over the life of the index depending on market conditions. The marketFixedRate is the price of the index as quoted by trading desks.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "marketFixedRate" path "feeLeg"]
	initialPoints number (0..1) <"An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints value of 5% would be represented as 0.05. The initialPoints element is an alternative to marketFixedRate in quoting the traded level of a trade. When initialPoints is used, the traded level is the sum of fixedRate and initialPoints. The initialPoints is one of the items that are factored into the initialPayment calculation and is payable by the Buyer to the Seller. Note that initialPoints and marketFixedRate may both be present in the same document when both implied values are desired.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "initialPoints" path "feeLeg"]
	marketPrice number (0..1) <"An optional element that only has meaning in a credit index trade. This element contains the price at which the trade was executed and is used instead of marketFixedRate on credit trades on certain indicies which are quoted using a price rather than a spread.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "marketPrice" path "feeLeg"]
	quotationStyle QuotationStyleEnum (0..1) <"An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints value of 5% would be represented as 0.05. The initialPoints element is an alternative to marketFixedRate in quoting the traded level of a trade. When initialPoints is used, the traded level is the sum of fixedRate and initialPoints. The initialPoints is one of the items that are factored into the initialPayment calculation and is payable by the Buyer to the Seller. Note that initialPoints and marketFixedRate may both be present in the same document when both implied values are desired.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "quotationStyle" path "feeLeg"]


/************************
 * Portfolio Aggregation *
 ************************/
type Position: <" A Position describes how much of a given Product is being held and constitutes the atomic element of a Portfolio.">

	product Product (1..1) <"The product underlying the position, which can either be a contractual product or securities.">
	quantity Quantity (1..1) <"The quantity of the product, which can be a negative number in case of a short position.">
	cashBalance Money (0..1) <"The aggregate cost of proceeds">
	positionStatus PositionStatusEnum (1..1) <"Qualifier for the state of the Position, to distinguish if just executed, formed, already settled, closed etc.">
	contractReference Contract (0..1) <"Reference to the Contract, in case product is contractual and the contract has been formed">
		[metadata reference]

	condition ContractFormed: <"When the position status indicates that contract has been formed, a contract must exists">
		if positionStatus = PositionStatusEnum -> Formed
		then contractReference exists

/*
 * 	TODO: implement this extra check based on a comparison function for EconomicTerms
 * 		and product -> contractualProduct -> = contract -> contractualProduct -> EconomicTerms
 */
enum PositionStatusEnum: <"Enumeration to describe the different (risk) states of a Position, whether executed, settled, matured...etc">
	Executed <"The position has been executed, which is the point at which risk has been transferred.">
	Formed <"Contract has been formed, in case position is on a contractual product.">
	Settled <"The position has settled, in case product is subject to settlement after execution, such as securities.">
	Cancelled <"The position has been cancelled, in case of a cancellation event following an execution.">

type PortfolioState: <" State-full representation of a Portfolio that describes all the positions held at a given time, in various states which can be either traded, settled, etc., with lineage information to the previous state">
	[metadata key]
	positions Position (0..*) <"The list of positions, each containing a Quantity and a Product.">
	lineage Lineage (1..1) <"Pointer to the previous PortfolioState and new Event(s) leading to the current (new) state. Previous PortfolioState in the Lineage can be Null in case this is the start of the chain of Events.">

	condition Initialisation: <"When the PortfolioState is the starting state of the Portfolio, as identified by a Null state in the Lineage, Positions must be empty and the reference to the latest Event is also empty. This is how a Portfolio gets initialised.">
		if PortfolioState exists and lineage -> portfolioStateReference is absent
		then positions is absent
			and lineage -> eventReference is absent

type AggregationParameters: <" Parameters to be used to filter events that are relevant to a given portfolio in order to calculate the state of this portfolio. The attributes correspond to all the possible aggregation criteria that can be used and these criteria can be combined. All the attributes are optional.">

	dateTime zonedDateTime (1..1) <"To aggregate as of a particular date">
	totalPosition boolean (0..1) <"Specifies whether to calculate total position to given date, or only daily position for the given date.">
	// Just a subset of possible aggregation parameters, for illustration to initiate the build-up of that class
	positionStatus PositionStatusEnum (0..1) <"To aggregate based on position status (EXECUTED, SETTLED etc)">
	party Party (0..*) <"To aggregate based on a selection of party(ies) / legal entity(ies).">
		[metadata reference]
	product Product (0..*) <"To aggregate based on a selection of products.">
	productQualifier productType (0..*) <"To aggregate based on a selection of product type(s).">
	contractReference Contract (0..*) <"To aggregate based only on given Contract(s).">
		[metadata reference]
	executionReference Execution (0..*) <"To aggregate based only on given Execution(s).">
		[metadata reference]

// TO DO: add more possible aggregation attributes, and more complex filtering/aggregation rules such as exclusion instead of just inclusion, etc.
// TBD: include the time dimension here to filter relevant events in a given period?
type Portfolio: <" A Portfolio represents an aggregation of multiple Positions, by describing the parameters that this Portfolio should be aggregated based on. The resulting PortfolioState is calculated using these aggregation parameters as inputs, by aggregating all the Events that are relevant to this Portfolio. The concept of Portfolio works at all levels in the model: from the highest for a given LegalEntity for instance, to the lowest to account for security substitutions in a secutity financing transaction. As such, Portfolio can be used either above or below the Contract level.">

	aggregationParameters AggregationParameters (1..1) <"Describes the portfolio by describing how to aggregate all its relevant Events.">
	portfolioState PortfolioState (1..1) <"Describes the state of the Portfolio as a list of Positions resulting from the aggregation.">

// TO ADD: PortfolioState calculation based on EventEffect

/***********************
 * Product Qualification
 */
func CreditDefaultSwap: <"This product qualification is temporary until such time that the ISDA Credit Group specifies a proper taxonomy for credit derivatives that is based upon economic terms.">
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> creditDefaultPayout exists
		and ( economicTerms -> payout -> interestRatePayout
			or economicTerms -> payout -> cashflow ) exists
		and economicTerms -> payout -> equityPayout is absent
		and economicTerms -> payout -> optionPayout is absent

func CreditDefaultSwaption: <"This product qualification is temporary until such time that the ISDA Credit Group specifies a proper taxonomy for credit derivatives that is based upon economic terms.">
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
        economicTerms -> payout -> optionPayout exists
        and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
        and ( economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> interestRatePayout
            or economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> cashflow ) exists
        and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> equityPayout is absent
        and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> optionPayout is absent

func EquitySwap_PriceReturnBasicPerformance_SingleName: <"The Price Return Basic Performance equity swap specified in the ISDA taxonomy V2.0 corresponds to the price and total return swaps.">
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_SingleName"]
	assign-output is_product:
        economicTerms -> payout -> interestRatePayout exists
        and ( economicTerms -> payout -> equityPayout -> returnType = ReturnTypeEnum -> Price
            or economicTerms -> payout -> equityPayout -> returnType = ReturnTypeEnum -> Total )
        and ( economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> equity
            or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> exchangeTradedFund
            or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> mutualFund
            or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> warrant
            ) exists

func EquitySwap_ParameterReturnDividend_SingleName: <"The Parameter Return Dividend equity swap specified in the ISDA taxonomy V2.0 corresponds to the dividend return swap.">
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnDividend_SingleName"]
	assign-output is_product:
        economicTerms -> payout -> interestRatePayout exists
        and economicTerms -> payout -> equityPayout -> returnType = ReturnTypeEnum -> Dividend
        and ( economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> equity
            or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> exchangeTradedFund
            or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> mutualFund
            or economicTerms -> payout -> equityPayout -> underlier -> underlyingProduct -> security -> warrant
            ) exists

func InterestRate_IRSwap_Basis:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Basis"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent

func InterestRate_IRSwap_FixedFloat_PlainVanilla: <"This product qualification doesn't represent the exact terms of the ISDA Taxonomomy V2.0 for the plain vanilla swaps, as some of those cannot be represented as part of the CDM syntax (e.g. the qualification that there is no provision for early termination which uses an off-market valuation), while some other are deemed missing in the ISDA taxonomy and have been added as part of the CDM (absence of cross-currency settlement provision, absence of fixed rate and notional step schedule, absence of stub). ">
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
        economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
        and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
        and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
        and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
        and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> settlementProvision is absent
        and economicTerms -> payout -> optionPayout is absent
        and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule -> step is absent
        and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> step is absent
        and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floatingRateMultiplierSchedule is absent
        and economicTerms -> payout -> interestRatePayout -> payoutQuantity -> quantitySchedule -> stepSchedule -> step is absent
        and economicTerms -> payout -> interestRatePayout -> stubPeriod is absent
        and economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> stubPeriodType is absent
	/*
	 * TODO - Cannot compare the below because in FpML the period associated with the reset frequency is of type PeriodExtendedEnum, which includes 'T'
	 * Need to adjust the implementation once a proper implementation approach has been firmed out
	 */
//	and economicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period =
//		economicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> indexTenor -> period
		and economicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier =
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> assetIdentifier -> rateOption -> indexTenor -> periodMultiplier
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period <> PeriodExtendedEnum -> T
		and economicTerms -> payout -> interestRatePayout -> compoundingMethod is absent
	// TODO comment out data rules that should only apply to qualification (and not be applied as part of general validation)
//	and Vanilla_AnnualPaymentDifferentResetFrequency, Vanilla_SemiAnnualPayment_QuarterlyReset, Vanilla_QuarterlyPayment_MonthlyReset apply

/*
 * TODO Address the below data rule
 */
//data rule Vanilla_SamePaymentResetFrequency
//	when payout -> interestRatePayout -> resetDates exists
//	then payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier

// TODO comment out data rules that should only apply to qualification (and not be applied as part of general validation)
//condition Vanilla_AnnualPaymentDifferentResetFrequency: <"One of the provision to qualify a plain vanilla swap according to the ISDA Taxonomy V2.0 is that when the payment frequency is annual, the reset frequency is semi-annual or quarterly.">
//	when payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> Y
//	then payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum -> M
//	and ( payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 6
//		or payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3 )

// TODO comment out data rules that should only apply to qualification (and not be applied as part of general validation)
//condition Vanilla_SemiAnnualPayment_QuarterlyReset: <"One of the provision to qualify a plain vanilla swap according to the ISDA Taxonomy V2.0 is that when the payment frequency is semi-annual, the reset frequency is quarterly.">
//	when payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> M
//		and payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 6
//	then payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum -> M
//		and payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3

// TODO comment out data rules that should only apply to qualification (and not be applied as part of general validation)
//condition Vanilla_QuarterlyPayment_MonthlyReset: <"One of the provision to qualify a plain vanilla swap according to the ISDA Taxonomy V2.0 is that when the payment frequency is quarterly, the reset frequency is monthly.">
//	when payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> M
//		and payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 6
//	then payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum -> M
//		and payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3

func InterestRate_IRSwap_FixedFloat:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
	economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period <> PeriodExtendedEnum -> T
		and ( economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule -> step exists
			or economicTerms -> payout -> interestRatePayout -> payoutQuantity -> quantitySchedule -> stepSchedule -> step exists
			or economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floatingRateMultiplierSchedule exists
			or economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> step exists
			or economicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier <>
			economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> assetIdentifier -> rateOption -> indexTenor -> periodMultiplier
			or economicTerms -> payout -> interestRatePayout -> compoundingMethod exists
			or economicTerms -> payout -> interestRatePayout -> stubPeriod exists
			or economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> stubPeriodType exists
			or economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> settlementProvision exists )
		and economicTerms -> payout -> interestRatePayout -> paymentDates exists

func InterestRate_IRSwap_FixedFixed:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFixed"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent

func InterestRate_CrossCurrency_Basis:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_Basis"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists
		and economicTerms -> payout -> optionPayout is absent

func InterestRate_CrossCurrency_FixedFloat:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists
		and economicTerms -> payout -> optionPayout is absent

func InterestRate_CrossCurrency_FixedFixed:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFixed"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists
		and economicTerms -> payout -> optionPayout is absent

func InterestRate_IRSwap_FixedFloat_ZeroCoupon:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T

/*
 * TODO Adjust the Xtext grammar to support enumeration styles
 */
func InterestRate_IRSwap_FixedFloat_OIS:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> assetIdentifier -> rateOption -> floatingRateIndex = FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND

func InterestRate_IRSwap_Basis_OIS:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Basis"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 2
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> assetIdentifier -> rateOption -> floatingRateIndex = FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND


func InterestRate_InflationSwap_FixedFloat_YearOn_Year:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> Y

func InterestRate_InflationSwap_FixedFloat_ZeroCoupon:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T

func InterestRate_InflationSwap_Basis_YearOn_Year:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> Y

func InterestRate_InflationSwap_Basis_ZeroCoupon:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate count = 1
		and economicTerms -> payout -> interestRatePayout -> rateSpecification -> fixedRate is absent
		and economicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges is absent
		and economicTerms -> payout -> optionPayout is absent
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
		and economicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T

func InterestRate_Option_Swaption:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_Option_Swaption"]
	assign-output is_product:
        economicTerms -> payout -> optionPayout exists
        and economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 2

func InterestRate_Option_DebtOption:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_DebtOption"]
	assign-output is_product:
        economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> security -> bond exists
        or economicTerms -> payout -> optionPayout -> underlier -> underlyingProduct -> security -> convertibleBond exists

func InterestRate_CapFloor:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_CapFloor"]
	assign-output is_product:
		economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> capRateSchedule exists
		or economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floorRateSchedule exists

func InterestRate_Fra:
	[qualification product]
	inputs: eTerms EconomicTerms(1..1)
	output: result boolean(1..1)
		[synonym ISDA_Taxonomy_v1 value "InterestRate_Fra"]

	assign-output result:
		eTerms -> payout -> interestRatePayout count = 2
		and eTerms -> payout -> creditDefaultPayout is absent
		and eTerms -> payout -> cashflow is absent
		and EffectiveDateContainsPaymentDate(eTerms) = True

func ForeignExchange:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_Forward"]
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_Spot"]
	assign-output is_product:
        economicTerms -> payout -> forwardPayout -> underlier -> underlyingProduct -> foreignExchange exists and
        economicTerms -> payout -> forwardPayout -> settlementTerms -> fxSettlementTerms is absent

func ForeignExchange_NDF:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
		[synonym ISDA_Taxonomy_v1 value "ForeignExchange_NDF"]
	assign-output is_product:
		economicTerms -> payout -> forwardPayout -> settlementTerms -> fxSettlementTerms exists

func RepurchaseAgreement:
	[qualification product]
	inputs: economicTerms EconomicTerms (1..1)
	output: is_product boolean (1..1)
	assign-output is_product:
		economicTerms -> payout -> securityPayout -> securityLeg count >= 1 and
		economicTerms -> payout -> interestRatePayout count = 1

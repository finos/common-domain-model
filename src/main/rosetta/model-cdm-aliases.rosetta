namespace "org.isda.cdm"
version "${project.version}"

/***************************************************************
 * Aliases (other than those embedded in the calculation syntax)
 */
func ForwardFX:
	inputs:
		forwardPayout ForwardPayout(1..1)
	output: result ForeignExchange (1..1)
	assign-output result: forwardPayout -> underlier -> singleUnderlier -> underlyingProduct -> foreignExchange

func EffectiveDate:
	inputs:
		economicTerms EconomicTerms(1..1)
	output: result ListOfDates(1..1)
	assign-output result -> dates: [
			economicTerms -> effectiveDate -> adjustableDate -> adjustedDate,
			economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate,
			economicTerms -> effectiveDate -> relativeDate -> adjustedDate,
			economicTerms -> payout -> interestRatePayout only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			economicTerms -> payout -> interestRatePayout only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			economicTerms -> payout -> interestRatePayout only-element-> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate,
			economicTerms -> payout -> equityPayout only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			economicTerms -> payout -> equityPayout only-element-> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			economicTerms -> payout -> equityPayout only-element-> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate
	]

// TODO - Providing the ability to embed aliases would provide the ability to ensure consistency between this alias and the effectiveDate one, while also simplify the syntax
// See Trello card https://trello.com/c/89Lv8rAn
func NovatedContractEffectiveDate:
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: result ListOfDates(1..1)

	alias eTerms: workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> contractualProduct -> economicTerms
	alias effectiveDate: eTerms only-element -> effectiveDate
	alias interestRatePayoutDate: eTerms only-element-> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate
	alias equityPayoutDate: eTerms only-element-> payout -> equityPayout -> calculationPeriodDates -> effectiveDate

	assign-output result -> dates: [
			effectiveDate -> adjustableDate -> adjustedDate,
			effectiveDate -> adjustableDate -> unadjustedDate,
			effectiveDate -> relativeDate -> adjustedDate,
			interestRatePayoutDate -> adjustableDate -> adjustedDate,
			interestRatePayoutDate -> adjustableDate -> unadjustedDate,
			interestRatePayoutDate -> relativeDate -> adjustedDate,
			equityPayoutDate -> adjustableDate -> adjustedDate,
			equityPayoutDate -> adjustableDate -> unadjustedDate,
			equityPayoutDate -> relativeDate -> adjustedDate
	]

func PaymentDate: // Scope limited to interestPayout until such time that we position it to the economicTerms level
	inputs: economicTerms EconomicTerms(1..1)
	output: result date(0..1)
	assign-output result: economicTerms -> payout -> interestRatePayout only-element -> paymentDate -> adjustedDate


type ListOfDates:
	dates date(0..*)

type QuantityGroups:
	quantityGroups QuantityGroup(0..*)



type QuantityGroup:
	currency string(0..1)
	amount number(0..*)

alias quantityAfterQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) after a quantity change primitive.">


alias quantityBeforeQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	( WorkflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualQuantity -> quantityNotation group by assetIdentifier -> currency ) -> quantity -> amount

func QuantityChange: <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	inputs:
		contract Contract(1..*)
	output:
		quantityChange QuantityGroups(1..1)

	// TODO - Support group by structures.
	assign-output quantityChange -> quantityGroups -> amount: [
		( contract -> contractualQuantity -> quantityNotation group by assetIdentifier -> currency ) -> quantity -> amount
	]

func QuantityIncreased:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output: result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> contract)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> contract)

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		afterQuantity > beforeQuantity

func QuantityDecreased:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output: result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> contract)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> contract)

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		afterQuantity < beforeQuantity and afterQuantity > 0

func QuantityDecreasedToZero:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output: result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> contract)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> contract)

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		beforeQuantity > 0 and afterQuantity = 0


func NoQuantityChange:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output:
		result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> contract)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> contract)

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		beforeQuantity = afterQuantity

func TerminationDate: // Scope limited to interestPayout until such time that we position it to the economicTerms level
	inputs: economicTerms EconomicTerms(1..1)
	output: result ListOfDates(1..1)
	alias interestRateTerminationDate: economicTerms -> payout -> interestRatePayout only-element -> calculationPeriodDates -> terminationDate
	alias equityPayoutTerminationDate: economicTerms -> payout -> equityPayout only-element -> calculationPeriodDates -> terminationDate

	assign-output result -> dates:
		[
			economicTerms -> terminationDate -> adjustableDate -> adjustedDate,
			economicTerms -> terminationDate -> adjustableDate -> unadjustedDate,
			economicTerms -> terminationDate -> relativeDate -> adjustedDate,
			interestRateTerminationDate -> adjustableDate -> adjustedDate,
			interestRateTerminationDate -> adjustableDate -> unadjustedDate,
			interestRateTerminationDate -> relativeDate -> adjustedDate,
			equityPayoutTerminationDate -> adjustableDate -> adjustedDate,
			equityPayoutTerminationDate -> adjustableDate -> unadjustedDate,
			equityPayoutTerminationDate -> relativeDate -> adjustedDate
		]

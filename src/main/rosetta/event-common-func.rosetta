namespace cdm.event.common
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.product.template.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*

import cdm.legalagreement.contract.*
import cdm.legalagreement.common.*
import cdm.legalagreement.contract.*
import cdm.legalagreement.master.*

import cdm.event.workflow.*
import cdm.event.position.*

isEvent root BusinessEvent;
// TODO - Providing the ability to embed aliases would provide the ability to ensure consistency between this alias and the effectiveDate one, while also simplify the syntax
// See Trello card https://trello.com/c/89Lv8rAn
func NovatedContractEffectiveDate:
	inputs:
		businessEvent BusinessEvent(1..1)
	output:
		result DateGroup(1..1)

	alias eTerms: businessEvent -> primitives -> contractFormation -> after -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms
	alias effectiveDate: eTerms only-element -> effectiveDate
	alias interestRatePayoutDate: eTerms only-element-> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate
	alias equityPayoutDate: eTerms only-element-> payout -> equityPayout -> calculationPeriodDates -> effectiveDate

	assign-output result -> dates: [
			effectiveDate -> adjustableDate -> adjustedDate,
			effectiveDate -> adjustableDate -> unadjustedDate,
			effectiveDate -> relativeDate -> adjustedDate,
			interestRatePayoutDate -> adjustableDate -> adjustedDate,
			interestRatePayoutDate -> adjustableDate -> unadjustedDate,
			interestRatePayoutDate -> relativeDate -> adjustedDate,
			equityPayoutDate -> adjustableDate -> adjustedDate,
			equityPayoutDate -> adjustableDate -> unadjustedDate,
			equityPayoutDate -> relativeDate -> adjustedDate
	]

func QuantityChange: <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	inputs:
		trade Trade (1..*)
	output:
		quantityChange QuantityGroups(1..1)

	// TODO - Support group by structures.
	assign-output quantityChange -> quantityGroups -> amount: [
		( trade -> tradableProduct -> quantityNotation group by assetIdentifier -> currency ) -> quantity -> amount
	]

func QuantityIncreased:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output: result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> trade)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> trade)

	assign-output result:
		ListsCompare(CompareOp -> Greater, afterQuantity -> quantityGroups -> amount, beforeQuantity -> quantityGroups -> amount, empty)

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		afterQuantity > beforeQuantity

func QuantityDecreased:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output: result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> trade)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> trade)

	assign-output result:
		ListsCompare(CompareOp -> Greater, beforeQuantity -> quantityGroups -> amount, afterQuantity -> quantityGroups -> amount, empty) = True
		and ListsCompare(CompareOp -> Greater, afterQuantity -> quantityGroups -> amount, empty, 0.0) = True

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		afterQuantity < beforeQuantity and afterQuantity > 0

func QuantityDecreasedToZero:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output: result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> trade)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> trade)

	assign-output result:
		ListsCompare(CompareOp -> Greater, beforeQuantity -> quantityGroups -> amount, empty, 0.0) = True
		and ListsCompare(CompareOp -> Equal, afterQuantity -> quantityGroups -> amount, empty, 0.0) = True

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		beforeQuantity > 0 and afterQuantity = 0

func NoQuantityChange:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive(1..*)
	output:
		result boolean(1..1)

	alias beforeQuantity:
		QuantityChange(quantityChangePrimitive -> before -> trade)
	alias afterQuantity:
		QuantityChange(quantityChangePrimitive -> after -> trade)

	assign-output result:
		ListsCompare(CompareOp -> Equal, beforeQuantity -> quantityGroups -> amount, beforeQuantity -> quantityGroups -> amount, empty) = True

	// TODO - Support operators for groupings.
	//	assign-output result:
	//		beforeQuantity = afterQuantity

func Qualify_Allocation: <"The qualification of allocation event from the fact that (i) the only primitives are split and contract formation (ii) the number of split executions and the number of contract formations are equal.  Note that SplitPrimitive type has a condition to check that the post-split quantities sum to the pre-split quantity.  Also note that it is expected that an allocation can result in a single contract.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> split exists
		and businessEvent -> primitives -> contractFormation exists
		and businessEvent -> primitives -> split -> after -> splitTrades -> trade count = businessEvent -> primitives -> contractFormation count

/*
 * Temporary event qualification until such time that we firm out the proper qualification and the way to infer it
 */
func Qualify_CashflowCalculationNotification:
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> transfer -> cashTransfer -> transferCalculation exists
		and businessEvent -> primitives -> transfer -> identifier -> scheme = "DTCCCashflowId"

func Qualify_CashTransfer: <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> transfer exists
		and businessEvent -> primitives -> transfer -> cashTransfer exists
		and businessEvent -> primitives -> transfer -> securityTransfer is absent
		and businessEvent -> primitives -> transfer -> commodityTransfer is absent
		and businessEvent -> primitives -> transfer -> identifier -> scheme <> "DTCCCashflowId"

func Qualify_CashAndSecurityTransfer: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> transfer -> cashTransfer exists
		and businessEvent -> primitives -> transfer -> securityTransfer exists
		and businessEvent -> primitives -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference
		-> reference = businessEvent -> primitives -> transfer -> securityTransfer -> transferorTransferee -> transferorPartyReference -> reference
		and businessEvent -> primitives -> transfer -> commodityTransfer is absent

// Simple Agency model for clearing
func Qualify_ClearedTrade:
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 5
		and businessEvent -> primitives -> quantityChange count = 1
		and QuantityDecreasedToZero(businessEvent -> primitives -> quantityChange) = True
		and businessEvent -> primitives -> execution count = 2
		and businessEvent -> primitives -> contractFormation count = 2
		and businessEvent -> primitives -> execution -> after = businessEvent -> primitives -> contractFormation -> before
		// TODO - Add this back in when we correctly map the ClearingOrganization
		and businessEvent -> primitives -> contractFormation -> after -> trade -> partyRole -> role contains PartyRoleEnum -> ClearingOrganization

func Qualify_ClearingRejection: <"The rejection of an alpha trade submission by a CCP, which is qualified by the fact that (i) termsChange is the only primitive, the workflow status is `rejected`, and (iii) the CCP is positioned as a partyRole to the execution or contract in the after state, while it didn't exist in the before state.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> termsChange exists
		and businessEvent -> workflowEventState -> workflowStatus = WorkflowStatusEnum -> Rejected
		and (businessEvent -> primitives -> termsChange -> before -> trade -> partyRole is absent
			or businessEvent -> primitives -> termsChange -> before -> trade -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization
			or businessEvent -> primitives -> termsChange -> before -> trade -> partyRole is absent
			or businessEvent -> primitives -> termsChange -> before -> trade -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization)
		and (businessEvent -> primitives -> termsChange -> after -> trade -> partyRole -> role = PartyRoleEnum -> ClearingOrganization
			or businessEvent -> primitives -> termsChange -> after -> trade -> partyRole -> role = PartyRoleEnum -> ClearingOrganization)
		and NoQuantityChange(businessEvent -> primitives -> quantityChange) = True

func Qualify_ClearingSubmission: <"The submission of a contract to a CCP, which is qualified by the fact that (i) the termsChange is the only primitive, and (ii) the CCP is positioned as a partyRole to the execution or contract in the after state, while it didn't exist in the before state.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> termsChange exists
		and businessEvent -> workflowEventState -> workflowStatus = WorkflowStatusEnum -> Submitted
		and (
			businessEvent -> primitives -> termsChange -> before -> trade -> partyRole is absent
			or businessEvent -> primitives -> termsChange -> before -> trade -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization
			or businessEvent -> primitives -> termsChange -> before -> trade -> partyRole is absent
			or businessEvent -> primitives -> termsChange -> before -> trade -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization
		)
		and (
			businessEvent -> primitives -> termsChange -> after -> trade -> partyRole -> role = PartyRoleEnum -> ClearingOrganization
			or businessEvent -> primitives -> termsChange -> after -> trade -> contractDetails -> partyContractInformation -> relatedParty -> role = PartyRoleEnum -> ClearingOrganization
			or businessEvent -> primitives -> termsChange -> after -> trade -> partyRole -> role = PartyRoleEnum -> ClearingOrganization
		)

func Qualify_Compression: <"The qualification of a compression event from the fact that (i) the quantityChange primitive exists, and (ii) there are multiple contracts (or contract references) specified in the before state.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> quantityChange exists
		and businessEvent -> primitives -> quantityChange -> before -> trade multiple exists

func Qualify_DerivedObservation: <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> observation only multiple exists
		and businessEvent -> functionCall exists

func Qualify_Exercise: <"The qualification of an exercise event from the fact that (i) the only primitive is the exercise, and (ii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> exercise exists

func Qualify_Increase: <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		(businessEvent -> intent is absent or businessEvent -> intent = IntentEnum -> Increase)
		and (
			businessEvent -> primitives count = 1
			and businessEvent -> primitives -> quantityChange exists
			or (businessEvent -> primitives -> quantityChange exists
				and businessEvent -> primitives -> transfer -> cashTransfer exists
			))
		and QuantityIncreased(businessEvent -> primitives -> quantityChange) = True
		and businessEvent -> primitives -> quantityChange -> after -> state -> closedState is absent

func Qualify_MultipleTransfers: <"The qualification an event that combines multiple transfers from the fact that multiple transfer primitives exist.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> transfer multiple exists

func Qualify_Novation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and a contract formation exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> quantityChange exists
		and businessEvent -> primitives -> contractFormation exists
		and QuantityDecreasedToZero(businessEvent -> primitives -> quantityChange) = True
		and businessEvent -> primitives -> quantityChange -> after -> state -> closedState -> state = ClosedStateEnum -> Novated
		and businessEvent -> primitives -> contractFormation -> after -> trade -> tradeIdentifier <> businessEvent -> primitives -> quantityChange -> before -> trade -> tradeIdentifier
		and businessEvent -> eventDate = businessEvent -> primitives -> contractFormation -> after -> trade -> tradeDate
		and businessEvent -> effectiveDate = NovatedContractEffectiveDate(businessEvent) -> dates only-element
		//and originalContractParties <> newContractParties

func Qualify_Observation: <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> observation only single exists

func Qualify_PartialNovation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and contractFormation exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> quantityChange exists
		and businessEvent -> primitives -> contractFormation exists
		and businessEvent -> primitives -> contractFormation -> after -> trade -> tradeIdentifier <> businessEvent -> primitives -> quantityChange -> before -> trade -> tradeIdentifier
		and businessEvent -> eventDate = businessEvent -> primitives -> contractFormation -> after -> trade -> tradeDate
		and businessEvent -> effectiveDate = NovatedContractEffectiveDate(businessEvent) -> dates
		and QuantityDecreased(businessEvent -> primitives -> quantityChange) = True
		//and originalContractParties <> newContractParties

func Qualify_PartialTermination: <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		(businessEvent -> intent is absent or businessEvent -> intent = IntentEnum -> PartialTermination)
		and (businessEvent -> primitives count = 1
		and businessEvent -> primitives -> quantityChange exists
			or (businessEvent -> primitives -> quantityChange exists
				and businessEvent -> primitives -> transfer -> cashTransfer exists
			))
		and QuantityDecreased(businessEvent -> primitives -> quantityChange) = True
		and businessEvent -> primitives -> quantityChange -> after -> state -> closedState is absent

func Qualify_Reset: <"The qualification of a reset event from the fact that the only primitive is the reset.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> reset exists

func Qualify_SecurityTransfer: <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1
		and businessEvent -> primitives -> transfer exists
		and businessEvent -> primitives -> transfer -> securityTransfer exists
		and businessEvent -> primitives -> transfer -> cashTransfer is absent
		and businessEvent -> primitives -> transfer -> commodityTransfer is absent

func Qualify_SecuritySettlement: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> transfer -> cashTransfer exists
		and businessEvent -> primitives -> transfer -> securityTransfer exists
		and businessEvent -> primitives -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference -> reference = businessEvent -> primitives -> transfer -> securityTransfer -> transferorTransferee -> transfereePartyReference -> reference
		and businessEvent -> primitives -> transfer -> commodityTransfer is absent

func Qualify_Termination: <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		(businessEvent -> intent is absent or businessEvent -> intent = IntentEnum -> Termination)
		and (businessEvent -> primitives count = 1
		and businessEvent -> primitives -> quantityChange exists
			or (businessEvent -> primitives -> quantityChange exists
				and businessEvent -> primitives -> transfer -> cashTransfer exists)
			)
		and QuantityDecreasedToZero(businessEvent -> primitives -> quantityChange) = True
		and businessEvent -> primitives -> quantityChange -> after -> state -> closedState -> state = ClosedStateEnum -> Terminated

func Qualify_TradeWarehousePositionNotification:
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> contractFormation exists
		and businessEvent -> tradeWarehouseWorkflow exists

func Qualify_Execution: <"The qualification of an execution event from the fact that the only component is an execution.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1 and businessEvent -> primitives -> execution exists

func Qualify_ContractFormation: <"The qualification of a contractFormation event from the fact that the only component is a contractFormation.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives count = 1 and businessEvent -> primitives -> contractFormation exists
		and businessEvent -> tradeWarehouseWorkflow is absent

func Qualify_StockSplit: <"The qualification of StockSplit business event based on (i) an unchanged before/after currency amount (ii) the same adjustment ratio applied to the before/after cash price and number of units.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent (1..1)
	output: is_event boolean (1..1)

	alias beforeQuantityNotation:
		businessEvent -> primitives -> quantityChange -> before -> trade -> tradableProduct -> quantityNotation
	
	alias beforeNoOfUnits:
		if beforeQuantityNotation exists
		then NoOfUnits( beforeQuantityNotation )
	
	alias afterQuantityNotation:
		businessEvent -> primitives -> quantityChange -> after -> trade -> tradableProduct -> quantityNotation
	
	alias afterNoOfUnits:
		if afterQuantityNotation exists
		then NoOfUnits( afterQuantityNotation )
	
	alias beforeCurrencyAmount: 
		if beforeQuantityNotation exists
		then CurrencyAmount( beforeQuantityNotation, empty )
	
	alias afterCurrencyAmount:
		if afterQuantityNotation exists
		then CurrencyAmount( afterQuantityNotation, empty )
	
	alias beforeCashPrices:
		businessEvent -> primitives -> termsChange -> before -> trade -> tradableProduct -> priceNotation -> price -> cashPrice -> netPrice -> amount
	
	alias beforeCashPrice:
		beforeCashPrices only-element 
	alias afterCashPrices:
		businessEvent -> primitives -> termsChange -> after -> trade -> tradableProduct -> priceNotation -> price -> cashPrice -> netPrice -> amount
	
	alias afterCashPrice:
		afterCashPrices only-element
	alias currencyAmountUnchanged:
		if ( beforeCurrencyAmount and afterCurrencyAmount ) exists
		then beforeCurrencyAmount = afterCurrencyAmount
		else False
	
	alias noOfUnitsChanged:
		if ( beforeNoOfUnits and afterNoOfUnits ) exists
		then afterNoOfUnits <> beforeNoOfUnits
		else False
	
	alias cashPriceChanged:
		if ( beforeCashPrice and afterCashPrice ) exists
		then beforeCashPrice <> afterCashPrice
		else False
	
	alias adjustmentRatioMatches:
		if ( beforeNoOfUnits and afterNoOfUnits and beforeCashPrice and afterCashPrice ) exists
		then afterNoOfUnits / beforeNoOfUnits = beforeCashPrice / afterCashPrice
		else False
	
	assign-output is_event:
		// TODO: check product type is equity?
		businessEvent -> primitives count = 2
		and currencyAmountUnchanged = True
		and noOfUnitsChanged = True
		and cashPriceChanged = True 
		and adjustmentRatioMatches = True

/**
 * Function specifications that are used in the Equity Reset process
 */
func ResolveEquityTradeState: <"Specifies how the updated contract should be constructed in a Equity Reset event.">
	inputs:
		tradeState TradeState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		resetTradeState TradeState (1..1)

	alias price:
		observation -> observation

	alias equityPayout:
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias updatedEquityPayout:
		resetTradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias periodEndDate:
		CalculationPeriod( equityPayout -> calculationPeriodDates, date ) -> endDate

	alias equityPerformance:
		EquityPerformance(tradeState -> trade, observation -> observation, periodEndDate)

	condition IsEquityContract:
		equityPayout exists

	assign-output updatedEquityPayout -> priceReturnTerms -> valuationPriceFinal -> netPrice -> amount:
		if CalculationPeriod( equityPayout -> calculationPeriodDates, periodEndDate ) -> isLastPeriod then price

	assign-output updatedEquityPayout -> priceReturnTerms -> valuationPriceInterim -> netPrice -> amount:
		if CalculationPeriod( equityPayout -> calculationPeriodDates, periodEndDate ) -> isLastPeriod = False then price

	// TODO: In Phase 2, move the performance number into TradeState -> observationHistory
	assign-output resetTradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> performance:
		<"Reset primitive after state must be correctly populated with the equity payout including the performance.">
		equityPerformance

	assign-output resetTradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> payoutQuantity -> quantityMultiplier -> multiplierValue:
		<"Using the Rate of Return we 'reset' the multiplier, which is used to resolve the ultimate notional amount for the equity swap.">  
		1 + equityPerformance / 100

func EquityCashSettlementAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount.">
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)

	output:
		equityCashSettlementAmount Money (1..1)

	alias equityPayout:
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout

	condition:
		tradeState -> trade -> tradableProduct -> quantityNotation -> assetIdentifier -> productIdentifier = equityPayout -> underlier -> underlyingProduct -> security -> productIdentifier

	assign-output equityCashSettlementAmount -> amount: <"Equity Cash Settlement Amount is defined here as Abs( Equity Performance ). Per the ISDA Definitions: Equity Performance = (Rate Of Return) × Equity Notional Amount and Equity Cash Settlement Amount = ABS(Rate Of Return) × Equity Notional Amount; so the calculation for Equity Cash Settlement Amount in the CDM is mathematically equivalent, with the added benefit that Rate of Return does not need to be recomputed, since it was already computed in the Reset Event.">
		Abs(tradeState -> observationHistory -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element -> performance)

	assign-output equityCashSettlementAmount -> currency: <"Does not handle the cross currency case, currently.">
		ResolveEquityInitialPrice( equityPayout only-element -> underlier, tradeState -> trade -> tradableProduct -> priceNotation ) -> netPrice -> currency

func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return) × Equity Notional Amount.">
	inputs:
		trade Trade (1..1)
		observation number (1..1)
		date date (1..1)

	output:
		equityPerformance number (1..1)

	alias equityPayout:
		trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout only-element

	alias periodStartPrice:
		ResolveEquityPeriodStartPrice(equityPayout, trade -> tradableProduct -> priceNotation, date)

	alias periodEndPrice:
		observation

	alias assetIdentifier:
		equityPayout -> payoutQuantity -> assetIdentifier

	alias numberOfSecurities:
		ExtractQuantityByAsset( trade -> tradableProduct -> quantityNotation, assetIdentifier ) -> quantity -> amount

	alias rateOfReturn:
		RateOfReturn(periodStartPrice, periodEndPrice)

	alias notionalAmount:
		EquityNotionalAmount(numberOfSecurities, periodEndPrice)

	assign-output equityPerformance:
		rateOfReturn * notionalAmount

func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
	inputs:
		initialPrice number (1..1)
		finalPrice number (1..1)

	output:
		rateOfReturn number (1..1)

	assign-output rateOfReturn:
		(finalPrice - initialPrice) / initialPrice

func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
	inputs:
		numberOfSecurities number (1..1)
		price number (1..1)

	output:
		equityNotionalAmount number (1..1)

	assign-output equityNotionalAmount:
		numberOfSecurities * price

func StockSplit: <"Function specification to create the fully-formed business event which represents the impact of a stock split (or a reverse stock split) on an Equity Derivatives contract on a certain date.  The function uses the defined adjustmentRatio to adjust the quantity and price as represented in two business events: QuantityChange and termsChange. ">
	inputs:
		instruction StockSplitInstruction (1..1)

	output:
		businessEvent BusinessEvent (1..1)

	alias preSplitNumberOfShares:
		NoOfUnits(instruction -> tradeState -> trade -> tradableProduct -> quantityNotation)

	alias postSplitNumberOfShares: <"The adjustment ratio is be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.">
		preSplitNumberOfShares * instruction -> adjustmentRatio

	alias preSplitPrices:
		instruction -> tradeState -> trade -> tradableProduct -> priceNotation -> price -> cashPrice -> netPrice -> amount

	alias postSplitPrice: <"The pre-split price is be divided by the adjustment ratio to determine the post-split price.">
		preSplitPrices only-element / instruction -> adjustmentRatio

	condition:
		instruction -> tradeState -> trade -> contractDetails exists

	assign-output businessEvent -> primitives -> quantityChange: <"Build QuantityChangePrimitive and add to WorkflowStep.">
		Create_QuantityChangePrimitive(instruction -> tradeState, empty, postSplitNumberOfShares)

	assign-output businessEvent -> primitives -> termsChange: <"Build TermsChangePrimitive (for price) and add to WorkflowStep.">
		Create_PriceChangePrimitive(instruction -> tradeState, postSplitPrice)

func Create_Execution: <"Specifies a function to create an execution business event, representing the instantiation of a transaction between two parties on a financial product for a given price, quantity and settlement terms. The business event is constructed to contain a single execution primitive event, and no other primitive event.">
	[creation BusinessEvent]
	inputs:

		product Product (1..1) <"Defines the financial product to be executed and contract formed.">
		quantityNotation QuantityNotation (1..*) <"Defines the quantities (e.g. currency amount, no. shares) associated with the constituents of the transacted product.">
		priceNotation PriceNotation (1..*) <"Defines the prices (e.g. spread, equity price, FX rate) associated with the constituents of the transacted product.">
		counterparty  Counterparty (2..2) <"Maps two defined parties to counterparty enums for the transacted product.">
		ancillaryParty AncillaryParty (0..*) <"Maps any ancillary parties, e.g. parties involved in the transaction that are not one of the two principal parties.">
		parties Party (2..*) <"Defines all parties to that execution, including agents and brokers.">
		partyRoles PartyRole (0..*) <"Defines the role(s) that party(ies) may have in relation to the execution.">
		settlementTerms SettlementTerms (0..*) <"Specifies the settlement terms for the execution e.g. initial fee, broker fee, up-front cds payment or option premium settlement">
		executionType ExecutionTypeEnum (1..1) <"Specifies the type of execution, e.g. via voice, or electronically.">
		tradeDate date (1..1) <"Denotes the trade/execution date.">
		identifier Identifier (1..*) <"Denotes one or more identifiers associated with the transaction.">

	output:
		executionEvent BusinessEvent (1..1) <"Qualified execution business event containing a single execution primitive event, and no other primitive event.">

	assign-output executionEvent -> primitives -> execution: <"Create and assign the execution primitive event to the execution business event, using the corresponding primitive event creation function.">
		Create_ExecutionPrimitive(product, quantityNotation, priceNotation, counterparty, ancillaryParty, parties, partyRoles, settlementTerms, executionType, tradeDate, identifier)

	assign-output executionEvent -> eventEffect -> trade: <"The trade object, i.e. the after state of the execution primitive event, is the single event effect of the business event.">
    		executionEvent -> primitives -> execution -> after

func Create_ExecutionPrimitive: <"Specifies the function to compose an execution based on a minimum required set of inputs: product, quantity, parties, etc.">
	[creation PrimitiveEvent]
	inputs:
		product Product (1..1) <"Defines the financial product to be executed and contract formed.">
		quantityNotation QuantityNotation (1..*) <"Defines the quantities (e.g. currency amount, no. shares) associated with the constituents of the transacted product.">
		priceNotation PriceNotation (1..*) <"Defines the prices (e.g. spread, equity price, FX rate) associated with the constituents of the transacted product.">
		counterparty Counterparty (2..2) <"Maps two defined parties to counterparty enums for the transacted product.">
		ancillaryParty AncillaryParty (0..*) <"Maps any ancillary parties, e.g. parties involved in the transaction that are not one of the two principal parties.">
		parties Party (2..*) <"Defines all parties to that execution, including agents and brokers.">
		partyRoles PartyRole (0..*) <"Defines the role(s) that party(ies) may have in relation to the execution.">
		settlementTerms SettlementTerms (0..*) <"Specifies the settlement terms for the execution e.g. initial fee, broker fee, up-front cds payment or option premium settlement.">
		executionType ExecutionTypeEnum (1..1) <"Specifies the type of execution, e.g. via voice or electronically.">
		tradeDate date (1..1) <"Denotes the trade/execution date.">
		identifier Identifier (1..*) <"Denotes one or more identifiers associated with the transaction.">

	output:
		executionPrimitive ExecutionPrimitive (1..1) <"Execution primitive event with absent before state and an after state containing the tradable product, parties, associated party roles and the known settlement terms.">

	assign-output executionPrimitive -> after -> trade -> tradableProduct -> product: <"Assign the product input to the tradable product of the execution object.">
		product

	assign-output executionPrimitive -> after -> trade -> tradableProduct -> priceNotation: <"Assign the prices input to the tradable product of the execution object.">
		priceNotation

	assign-output executionPrimitive -> after -> trade -> tradableProduct -> quantityNotation: <"Assign the quantities input to the tradable product of the execution object.">
		quantityNotation

	assign-output executionPrimitive -> after -> trade -> tradableProduct -> counterparty: <"Assign the counterparty input to the tradable product of the execution object.">
		counterparty

	assign-output executionPrimitive -> after -> trade -> tradableProduct -> ancillaryParty: <"Assign the ancillaryRole input to the tradable product of the execution object.">
		ancillaryParty

	assign-output executionPrimitive -> after -> trade -> party: <"Assign the parties input to the execution object.">
		parties

	assign-output executionPrimitive -> after -> trade -> partyRole: <"Assign the party roles input to the execution object.">
 		partyRoles

	assign-output executionPrimitive -> after -> trade -> settlementTerms: <"Assign the settlement terms input to the execution object.">
		settlementTerms

	assign-output executionPrimitive -> after -> trade -> executionDetails -> executionType: <"Assign the settlement terms input to the execution object.">
		executionType

	assign-output executionPrimitive -> after -> trade -> tradeDate: <"Assign the tradeDate input to the execution object.">
		tradeDate
	
	assign-output executionPrimitive -> after -> trade -> tradeIdentifier: <"Assign the identifier input to the execution object.">
		identifier

	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		executionPrimitive -> before is absent

func Create_ContractFormation: <"Function specification to create the business event, representing the affirmation (or confirmation) of an executed transaction between two parties. The formed contract can reference a legal agreement for instance a master agreement, by using the optional legalAgreement input.">
	[creation BusinessEvent]
	inputs:
		executionEvent BusinessEvent (1..1) <"Qualified execution business event containing a execution primitive.">
		legalAgreement LegalAgreement (0..1) <"Optional legal agreement associated to the contract being formed, for instance a master agreement.">

	output:
		contractFormationEvent BusinessEvent (1..1) <"Qualified contract formation business event.">

	alias trade:
		executionEvent -> primitives -> execution -> after -> trade

	condition : <"Input event must be an execution must be on a contractual product.">
		trade exists and
		trade -> tradableProduct -> product -> contractualProduct exists

	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided.">
		if legalAgreement exists then legalAgreement -> contractualParty contains trade -> party

	assign-output contractFormationEvent -> primitives -> contractFormation: <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		Create_ContractFormationPrimitive(executionEvent -> primitives only-element -> execution -> after -> trade, legalAgreement)

	assign-output contractFormationEvent -> eventEffect -> trade: <"The event effect of the business event points to the contract object, i.e. the after state of the contract formation primitive event.">
		contractFormationEvent -> primitives -> contractFormation -> after

	assign-output contractFormationEvent -> eventEffect -> effectedTrade: <"The event effect of the business event points to the execution object, i.e. the before state of the contract formation primitive event.">
		contractFormationEvent -> primitives -> contractFormation -> before

	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		contractFormationEvent -> eventEffect -> productIdentifier is absent
		and contractFormationEvent -> eventEffect -> transfer is absent

func Create_ContractFormationPrimitive: <"Function specification to create the primitive event that represents an executed trade for a contractual product that has been affirmed (or confirmed) by the two parties. The formed contract can reference a legal agreement for instance a master agreement, by using the optional legalAgreement input.">
	[creation PrimitiveEvent]
	inputs:
		execution Trade (1..1) <"Execution consisting of the economic terms which are agreed between the parties.">
		legalAgreement LegalAgreement (0..1) <"Optional legal agreement associated to the contract being formed, for instance a master agreement.">

	output:
		contractFormation ContractFormationPrimitive (1..1) <"Primitive event containing the execution as its before state and the contract as the after state.">

	alias trade:
		contractFormation -> after -> trade

	assign-output contractFormation -> before -> trade: <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		execution

	assign-output trade -> tradableProduct: <"Assign the tradable product input to the execution object.">
		execution -> tradableProduct

	assign-output trade -> tradeIdentifier: <"Assign the contract identifier input to the execution object.">
		execution -> tradeIdentifier

	assign-output trade -> tradeDate: <"Assign the trade date input to the execution object.">
		execution -> tradeDate

	assign-output trade -> partyRole: <"Assign the party role input to the execution object.">
		execution -> partyRole

	assign-output trade -> party: <"Assign the party input to the execution object.">
		execution -> party

	assign-output trade -> contractDetails -> documentation -> legalAgreement: <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists
		then Create_LegalAgreementWithPartyReference(legalAgreement -> agreementTerms, legalAgreement -> agreementDate, legalAgreement -> effectiveDate, legalAgreement -> identifier, /*legalAgreement -> lineage,*/ legalAgreement -> agreementType, legalAgreement -> contractualParty, legalAgreement -> otherParty)

func Create_Exercise: <"Constructs the business event that represents the exercise of an option in a pre-existing contractual product.">
	[creation BusinessEvent]
	inputs:
		previousEvent BusinessEvent (1..1) <"Specifies the previous business event representing the state of a previously formed contractual product with an option payout. It is required that the description of the contractual product be contained within the previous business event, i.e. its lineage must contain the formation of a contractual product.">
		exerciseInstruction ExerciseInstruction (1..1) <"Specifies the information required to communicate the choices made by the exercising party in accordance with the economic terms of the contractual product.">
	
	output:
		exerciseEvent BusinessEvent(1..1) <"Produces the business event composed of primitive events describing the transfer, termination, or formation of new contracts as a result of the input exercise instruction.">
	
	alias tradeState: <"Extracts the original state of the contractual product prior to executing the exercise decision.">
		ExtractTradeState( previousEvent )
	
	alias tradableProduct: <"Extracts the originally traded product.">
		tradeState -> trade -> tradableProduct
		
	alias optionPayout: <"Extracts the option payout.">
		tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
	
	alias exerciseTerms: <"Extracts the exercise terms provided as part of the original contract. Requires that the original contract contains an option payout.">
		optionPayout -> exerciseTerms
	
	alias underlier: <"Extracts the underlying financial product, upon which the option decision is contingent. Requires that the original contract contains an option payout.">
		optionPayout -> underlier -> underlyingProduct
	
	alias execution: <"Creates the execution primitive describing the exchange of the underlying product, either as a cash transfer or as the formation of a new contractual product between parties.">
		Create_ExecutionPrimitive( underlier,
			tradableProduct -> quantityNotation, 
			tradableProduct -> priceNotation, 
			tradableProduct -> counterparty, 
			tradableProduct -> ancillaryParty,
			tradeState -> trade -> party,
			tradeState -> trade -> partyRole,
			empty, /*settlementTerms*/
			empty, /*executionType*/
			tradeState -> trade -> tradeDate,
			tradeState -> trade -> tradeIdentifier ) -> after
	
	condition: <"Requires that the original contract must contain a state corresponding to a contractual product.">
		tradeState exists
	
	condition: <"Requires that the original contract contains an option payout.">
		optionPayout exists
	
	assign-output exerciseEvent -> primitives -> quantityChange -> before: <"Creates a quantity change primitive indicating that the original contract's optionality has been exhausted. Note that this currently assumes there is a single option in the contractual product that is fully exercised.">
		tradeState
	
	assign-output exerciseEvent -> primitives -> quantityChange -> after: <"Creates a new contract within the quantity change primitive's after state equivalent to the original contract with the quantity set to zero, assuming there's a single option in the original financial contract that is fully exercised.">
		TerminateContract( tradeState )
	
	assign-output exerciseEvent -> primitives -> contractFormation: <"Creates a new contract formation primitive delivering the underlying financial product to the exercising party if physical settlement was mandated by the contract.">
		if exerciseTerms -> settlement -> physicalSettlementTerms exists then
			Create_ContractFormationPrimitive( execution -> trade, empty  /*legalAgreement*/ )
	
	assign-output exerciseEvent -> primitives -> transfer: <"Creates a transfer primitive delivering the underlying financial product to the exercising party if cash settlement was mandated by the contract.">
		if exerciseTerms -> settlement -> cashSettlementTerms exists then
			Create_TransferPrimitive( execution -> trade )

func Create_Reset:
	[creation BusinessEvent]
	inputs:
		previousEvent BusinessEvent (1..1)
		observationEvent BusinessEvent (1..1)
		date date (1..1)

	output:
		resetEvent BusinessEvent (1..1)

	alias tradeState: <"Extract the Contract State from the Event.">
		ExtractTradeState(previousEvent)

	alias observation:
		observationEvent -> primitives  only-element -> observation

	condition: <"ExtractTradeState could result in nothing (empty), check we have something.">
		tradeState exists

	condition: <"The observation primitive must be part of the observation event">
		observation exists

	assign-output resetEvent -> primitives -> reset:
		Create_ResetPrimitive(tradeState, observation, date)

	assign-output resetEvent -> eventEffect -> effectedTrade:
		tradeState as-key

	post-condition:
		resetEvent -> eventEffect -> effectedTrade is absent
		and resetEvent -> eventEffect -> trade is absent
		and resetEvent -> eventEffect -> productIdentifier is absent

func Create_ResetPrimitive: <"Specifies how a Reset Primitive should be constructed.">
	[creation PrimitiveEvent]
	inputs:
		tradeState TradeState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		resetPrimitive ResetPrimitive (1..1)

	assign-output resetPrimitive -> before:
		tradeState

	assign-output resetPrimitive -> after:
		tradeState

	assign-output resetPrimitive -> after -> observationHistory: <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedTrade(tradeState, observation, date)

func ResolveUpdatedTrade: <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms.">
	inputs:
		tradeState TradeState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		updatedContract TradeState (1..1) <"An object that follows the structure of the Contract with only the updated values are set.">

	alias payout:
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout


	assign-output updatedContract:
		if payout -> equityPayout exists then ResolveEquityTradeState(tradeState, observation, date)

func Create_CashTransfer: <"Function specification to build a transfer event following a reset on a contract">
	[creation BusinessEvent]
	inputs:
		resetEvent BusinessEvent (1..1)
	output:
		transferEvent BusinessEvent (1..1)

	alias tradeState:
		resetEvent -> primitives -> reset -> after

	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> primitives -> reset exists

	assign-output transferEvent -> primitives -> transfer:
		Create_CashTransferPrimitive(tradeState only-element, resetEvent -> eventDate)

	assign-output transferEvent -> eventEffect -> effectedTrade:
	    tradeState

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> primitives -> transfer only exists

	post-condition: <"Event effect must include the contract generating the cashflow.">
		transferEvent -> eventEffect -> productIdentifier is absent

func Create_CashTransferPrimitive: <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	[creation PrimitiveEvent]
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)

	output:
		transfer TransferPrimitive (1..1)

	alias cashflow:
		ResolveCashflow(tradeState, date)

	alias counterparties:
		tradeState -> trade -> tradableProduct -> counterparty

	alias ancillaryParties:
		tradeState -> trade -> tradableProduct -> ancillaryParty

	assign-output transfer -> status:
		TransferStatusEnum -> Instructed

	assign-output transfer -> cashTransfer -> amount:
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver -> payerPartyReference:
		if cashflow -> payerReceiver -> payer exists
		then ExtractCounterpartyByRole( counterparties, cashflow -> payerReceiver -> payer ) -> partyReference
		else ExtractAncillaryPartyByRole( ancillaryParties, cashflow -> payerReceiver -> payerAncillaryRole ) -> partyReference only-element

	assign-output transfer -> cashTransfer -> payerReceiver -> receiverPartyReference:
		if cashflow -> payerReceiver -> receiver exists
		then ExtractCounterpartyByRole( counterparties, cashflow -> payerReceiver -> receiver ) -> partyReference
		else ExtractAncillaryPartyByRole( ancillaryParties, cashflow -> payerReceiver -> receiverAncillaryRole ) -> partyReference only-element

	assign-output transfer -> settlementDate:
		cashflow -> cashflowDate

func ResolveCashflow: <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs:
		tradeState TradeState (1..1)
		date date (1..1)

	output:
		cashflow Cashflow (1..1)

	assign-output cashflow -> cashflowAmount:
		if tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout exists
		then EquityCashSettlementAmount(tradeState, date)

	assign-output cashflow -> cashflowDate -> adjustedDate:
		ResolveCashSettlementDate(tradeState)

func ResolveCashSettlementDate: <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: tradeState TradeState (1..1)
	output: date date (1..1)

func Create_Allocation: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	[creation BusinessEvent]
	inputs:
		trade Trade (1..1) <"Block trade to be allocated.">
		allocationInstruction AllocationInstruction (1..1) <"Allocation instructions to be applied.">

	output:
		businessEvent BusinessEvent (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	alias splitPrimitive:
		Create_SplitPrimitive(trade, allocationInstruction -> breakdowns -> quantity)

//	assign-output businessEvent -> primitives -> split:
//		splitPrimitive
	/*
	 * TODO: Requires DSL support so implemented in Java:
	 *
	 * Proposed syntax changes:
	 * Option 1 - loop through split executions to create contract formation primitive for each one:
	 *  - for loop syntax support required to create contract formation primitive for each split execution
	 *  - list append syntax support required to add each contract formation primitive to the list of primitives
	 *  Option 2 - create function that creates list of contract formation primitives
	 *  - syntax support for returning lists from functions
	 *  - syntax support for list add all (to add function result to list of primitives)
	 */
//	add-output businessEvent -> primitives -> contractFormation for-each splitPrimitive -> after -> splitTrades -> execution:
//		then Create_ContractFormationPrimitive( it, empty )
	post-condition: <"Both split and contract formation primitives should be created.">
		businessEvent -> primitives -> split exists and businessEvent -> primitives -> contractFormation exists

	post-condition: <"The split outcome must result in execution state of 'Allocated' for an execution.">
		if businessEvent -> primitives -> split -> after -> originalTrade -> trade exists
		then businessEvent -> primitives -> split -> after -> originalTrade -> state -> closedState -> state = ClosedStateEnum -> Allocated

func Create_SplitPrimitive: <"Function specification to create the Split primitive based by splitting the trade into separate trades with the qualities specified in the split instructions.">
	[creation PrimitiveEvent]
	inputs:
		trade Trade (1..1) <"Block trade to be split.">
		splitInstructions QuantityNotation (1..*) <"Split instructions to be applied.">

	output:
		primitive SplitPrimitive (1..1) <"Split primitive containing both the original block trade (with the status set to Split) and the set of split trades.">

func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	// TODO Never referenced in CDM
	inputs:
		trade Trade (1..1) <"Execution to be settled.">
		previousEvent WorkflowStep (1..1) <"Previous event for lineage purposes.">

	output:
		transferEvent WorkflowStep (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		trade -> tradableProduct -> product -> security exists

	assign-output transferEvent -> businessEvent -> primitives -> transfer:
		Create_TransferPrimitive(trade)

	assign-output transferEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output transferEvent -> lineage -> tradeReference:
		trade as-key

func Create_TransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	[creation PrimitiveEvent]
	inputs:
		trade Trade (1..1)

	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	assign-output transferPrimitive -> status:
		TransferStatusEnum -> Instructed

	post-condition:
		if trade -> tradableProduct -> product -> security exists and trade -> settlementTerms -> transferSettlementType = TransferSettlementEnum -> DeliveryVersusPayment
		then transferPrimitive -> cashTransfer exists
			and transferPrimitive -> securityTransfer exists
			and transferPrimitive -> commodityTransfer is absent

func Create_QuantityChangePrimitive: <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	[creation PrimitiveEvent]
	inputs:
		tradeState TradeState (1..1)
		currencyAmount number (0..1)
		noOfUnits number (0..1)
	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	condition:
		(currencyAmount or noOfUnits) exists

	assign-output quantityChangePrimitive -> before:
		tradeState as-key

	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> trade -> executionDetails exists then quantityChangePrimitive -> after -> trade -> executionDetails exists
			and if quantityChangePrimitive -> before -> trade -> contractDetails exists then quantityChangePrimitive -> after -> trade -> contractDetails exists

func Create_PriceChangePrimitive:
	[creation PrimitiveEvent]
	inputs:
		tradeState TradeState (1..1)
		cashPrice number (1..1)

	output:
		termsChangePrimitive TermsChangePrimitive (1..1)

func Create_TerminationQuantityChangePrimitive: <"A specification for terminating a contract. A QuantityChangePrimitive is created with the after set with quantity of 0, and the closed state to be Terminated.">
	[creation PrimitiveEvent]
	inputs:
		contract TradeState (1..1)

	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	assign-output quantityChangePrimitive -> before: <"Correctly populate the before attributes on the Primitive Event">
		contract

	assign-output quantityChangePrimitive -> after: <"Correctly populate the after attributes on the Primitive Event">
		TerminateContract(contract)

func TerminateContract: <"Function specification for a contract termination where the 'ClosedStateEnum' is set to Terminated and the quantity amount is set to 0.">
	inputs:
		tradeState TradeState (1..1) <"Formed contract in non-terminated state.">

	output:
		terminatedContract TradeState (1..1) <"Contract in terminated state with quantity amount set to 0.">

	assign-output terminatedContract -> trade -> tradeIdentifier:
		tradeState -> trade -> tradeIdentifier
	assign-output terminatedContract -> trade -> tradeDate:
		tradeState -> trade -> tradeDate
	assign-output terminatedContract -> trade -> clearedDate:
		tradeState -> trade -> clearedDate
	assign-output terminatedContract -> trade -> tradableProduct -> product:
		tradeState -> trade -> tradableProduct -> product
	assign-output terminatedContract -> trade -> tradableProduct -> priceNotation:
		tradeState -> trade -> tradableProduct -> priceNotation
	assign-output terminatedContract -> trade -> collateral:
		tradeState -> trade -> collateral
	assign-output terminatedContract -> trade -> contractDetails -> documentation:
		tradeState -> trade -> contractDetails -> documentation
	assign-output terminatedContract -> trade -> contractDetails -> governingLaw:
		tradeState -> trade -> contractDetails -> governingLaw
	assign-output terminatedContract -> trade -> party:
		tradeState -> trade -> party
	assign-output terminatedContract -> trade -> account:
		tradeState -> trade -> account
	assign-output terminatedContract -> trade -> partyRole:
		tradeState -> trade -> partyRole
	assign-output terminatedContract -> trade -> contractDetails -> partyContractInformation:
		tradeState -> trade -> contractDetails -> partyContractInformation

	assign-output terminatedContract -> state -> closedState -> state: <"Set the closed state on the terminatedContract">
		ClosedStateEnum -> Terminated

	assign-output terminatedContract -> trade -> tradableProduct -> quantityNotation -> quantity -> amount: <"Set the quantity amount to 0">
        0.0

func NewExecutionPrimitiveEvent: <"Constructs a primitive event from a fully formed execution primitive.">
	inputs:
		executionPrimitive ExecutionPrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> execution:
	executionPrimitive

func NewContractFormationPrimitiveEvent: <"Constructs a primitive event from a fully formed contract formation primitive.">
	inputs:
		contractFormation ContractFormationPrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> contractFormation:
	contractFormation

func NewQuantityChangePrimitiveEvent: <"Constructs a primitive event from a fully formed quantity change primitive event.">
	inputs:
		quantityChangePrimitive QuantityChangePrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> quantityChange:
	quantityChangePrimitive

func Create_ClearedTrade: <"Function supporting direct principal and agency clearing model that takes the clearing instruction as an input and results in the cleared trade BusinessEvent. Direct clearing is when the risk party to the trade is facing the CCP, either through its own account or its clearing member acting as agent. In the direct clearing agency model, the party facing the CCP is acting as clearing member for another party. If the clearing instructions contains clearerParty1 or clearerParty2, then it should be used as the party facing the CCP in the beta or gamma contracts respectively. The resulting beta and gamma trades should have the same tradable product as the alpha referencing the risk parties however, the current state of the model does not allow parties to be aliased efficiently which will be resolved by Trello task https://trello.com/c/q8S3w2Rz.">
	[creation BusinessEvent]
	inputs:
		clearingInstruction ClearingInstruction(1..1) <"Clearing Instruction with all party information required to clear the trade.">
		tradeDate date (1..1) <"Denotes the trade/execution date.">
		identifier Identifier (1..1) <"Denotes one or more identifiers associated with the transaction.">

	output:
		clearedEvent BusinessEvent (1..1) <"Business event qualified as a cleared trade consisting of five primitive events; terminated alpha contract, new beta execution, beta contract formation, new gamma execution and gamma contract formation">

	alias alphaTerminated: <"Terminated alpha primitive event represented as a quantity change event with the after quantity set to 0. The before state is a reference to the original alpha contract.">
		Create_TerminationQuantityChangePrimitive(clearingInstruction -> alphaContract)
	alias alphaTerminatedPrimitives: NewQuantityChangePrimitiveEvent(alphaTerminated)

	alias clearerRole: <"The clearing party (CCP) role set to ClearingOrganization.">
		Create_PartyRole(clearingInstruction -> clearingParty, PartyRoleEnum -> ClearingOrganization)

	alias clearerCounterparty:
		Create_Counterparty(clearingInstruction -> clearingParty, CounterpartyRoleEnum -> Party2)

	alias betaParty: <"Beta party is the clearerParty1 when acting as a clearing member or else is party1 when it is clearing for its own account.">
		if clearingInstruction -> clearerParty1 exists
		then clearingInstruction -> clearerParty1
		else clearingInstruction -> party1

	alias betaCounterparty:
		Create_Counterparty(betaParty, CounterpartyRoleEnum -> Party1)

	alias betaExecution: <"Execution between the CCP and the beta party.">
		Create_ExecutionPrimitive(clearingInstruction -> alphaContract -> trade -> tradableProduct -> product,
		    clearingInstruction -> alphaContract -> trade -> tradableProduct -> quantityNotation,
		    clearingInstruction -> alphaContract -> trade -> tradableProduct -> priceNotation,
		    [betaCounterparty, clearerCounterparty],
		    clearingInstruction -> alphaContract -> trade -> tradableProduct -> ancillaryParty,
		    [betaParty, clearingInstruction -> clearingParty],
		    [clearerRole],
		    empty,
            ExecutionTypeEnum -> OffFacility,
            tradeDate,
            [identifier])
	alias betaExecutionPrimitives: NewExecutionPrimitiveEvent(betaExecution)

	alias betaContract: <"Contract between the CCP and the beta party.">
		Create_ContractFormationPrimitive(betaExecution -> after -> trade, empty)
	alias betaContractPrimitives: NewContractFormationPrimitiveEvent(betaContract)

	alias gammaParty: <"Gamma party is the clearerParty2 when acting as a clearing member or else is party1 when it is clearing for its own account.">
		if clearingInstruction -> clearerParty2 exists
		then clearingInstruction -> clearerParty2
		else clearingInstruction -> party2

	alias gammaCounterparty:
		Create_Counterparty(gammaParty, CounterpartyRoleEnum -> Party1)

	alias gammaExecution: <"Execution between the CCP and the gamma party">
		Create_ExecutionPrimitive(clearingInstruction -> alphaContract -> trade -> tradableProduct -> product,
		    clearingInstruction -> alphaContract -> trade -> tradableProduct -> quantityNotation,
		    clearingInstruction -> alphaContract -> trade -> tradableProduct -> priceNotation,
		    [gammaCounterparty, clearerCounterparty],
		    clearingInstruction -> alphaContract -> trade -> tradableProduct -> ancillaryParty,
		    [gammaParty, clearingInstruction -> clearingParty],
		    [clearerRole],
		    empty,
            ExecutionTypeEnum -> OffFacility,
            tradeDate,
            [identifier])
	alias gammaExecutionPrimitives: NewExecutionPrimitiveEvent(gammaExecution)

	alias gammaContract: <"Contract between the CCP and the gamma party.">
		Create_ContractFormationPrimitive(gammaExecution -> after -> trade, empty)
	alias gammaContractPrimitives: NewContractFormationPrimitiveEvent(gammaContract)

	condition: <"The alpha contract being terminated must include the party1 contained in the clearing instruction.">
		clearingInstruction -> alphaContract -> trade -> party includes clearingInstruction -> party1
	condition: <"The alpha contract being terminated must include the party2 contained in the clearing instruction.">
		clearingInstruction -> alphaContract -> trade -> party includes clearingInstruction -> party2

	condition: <"The alpha contract being terminated must include the party role of the clearing member (clearerParty1) if it has been specified.">
		if clearingInstruction -> clearerParty1 exists
		then clearingInstruction -> alphaContract -> trade -> partyRole -> partyReference includes clearingInstruction -> clearerParty1

	condition: <"The alpha contract being terminated must include the party role of the clearing member (clearerParty2) if it has been specified.">
		if clearingInstruction -> clearerParty2 exists
		then clearingInstruction -> alphaContract -> trade -> partyRole -> partyReference includes clearingInstruction -> clearerParty2

	assign-output clearedEvent -> primitives: <"Create the event made up of five primitives; alpha terminated, beta execution, beta contract, gamma execution and gamma contract. Each beta and gamma contracts contain references to the respective executions.">
		[
			alphaTerminatedPrimitives,
			betaExecutionPrimitives,
			betaContractPrimitives,
			gammaExecutionPrimitives,
			gammaContractPrimitives
	]

func ExtractTradeState: <"Extracts a single Contract State, given an Event. This function navigates all the possible paths to product and extracts a single value.">
	inputs: event BusinessEvent (1..1)
	output: tradeState TradeState (1..1)
	alias primitive: event -> primitives  only-element
	assign-output tradeState:
		if primitive -> contractFormation exists then primitive -> contractFormation -> after
		else if primitive -> reset exists then primitive -> reset -> after

func ContractStateFromTradeState:
	inputs:
		contractState TradeState (1..1)
	output:
		tradeState ContractState (1..1)

func TradeStateFromContractState:
	inputs:
		contractState ContractState (1..1)
	output:
		tradeState TradeState (1..1)

/*
 * Function Specifications for Equity Swap product creation
 *
 * These should be implementation-specific, and exist in implementors' "private" extensions of the CDM rather than the public CDM
 * They are positioned here for illustration of the equity workflow as part of the CDM, until such time when they could be deemed to be moved
 *
 */
func NewEquitySwapProduct: <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement. The inputs represent the minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">
	inputs:
		security Security (1..1) <"The underlying Equity asset for the swap.">
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1) <"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">

	output:
		product Product (1..1)

	alias payout:
		product -> contractualProduct -> economicTerms -> payout

	condition: <"Security must be equity (single name).">
		security -> securityType = SecurityTypeEnum -> Equity


	assign-output product -> contractualProduct -> economicTerms -> payout -> equityPayout:
		NewSingleNameEquityPayout(security, masterConfirmation)

	assign-output product -> contractualProduct -> economicTerms -> payout -> interestRatePayout: <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications">
		if masterConfirmation exists then NewFloatingPayout(masterConfirmation)

	post-condition: <"Other payout types must be absent.">
		if masterConfirmation is absent then payout -> interestRatePayout is absent
			and payout -> cashflow is absent
			and payout -> creditDefaultPayout is absent
			and payout -> forwardPayout is absent
			and payout -> optionPayout is absent

	post-condition: <"Non-contractual product types must be absent.">
		product -> contractualProduct only exists

func NewSingleNameEquityPayout: <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs:
		security Security (1..1)
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)

	output:
		equityPayout EquityPayout (1..1)

	condition: <"Security must be equity (single name).">
		security -> securityType = SecurityTypeEnum->Equity //= underlier

	assign-output equityPayout -> returnType: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> typeOfSwapElection

	assign-output equityPayout -> calculationPeriodDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> equityCalculationPeriod

	assign-output equityPayout -> paymentDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> equityCashSettlementDates

	assign-output equityPayout -> settlementTerms: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
		masterConfirmation -> settlementTerms


func NewFloatingPayout: <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
	inputs: masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output: interestRatePayout InterestRatePayout (1..1)

	post-condition: <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">
		if masterConfirmation exists
		then interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod
			and interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates

		
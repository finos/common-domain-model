namespace "org.isda.cdm"
version "${project.version}"

import cdm.base.maths.*

// TODO: paragraph 2
// Scenario A: trading relationship ceases, security interest released all collateral return (even if under MTA)
// Scenario B: trading relationship falls below 50M IM threshold, security interest released all collateral return (even if under MTA)

func DeliveryAmount:
	[calculation]

	inputs:
		postedCreditSupportItems PostedCreditSupportItem (0..*)
		priorDeliveryAmountAdjustment Money (1..1)
		priorReturnAmountAdjustment Money (1..1)
		disputedPostedCreditSupportAmount Money (1..1)
		marginAmount Money (1..1)
		threshold Money (1..1)
		marginApproach MarginApproachEnum (1..1)
		marginAmountIA Money (0..1)
		minimumTransferAmount Money (1..1)
		rounding CollateralRounding (1..1)
		disputedDeliveryAmount Money (1..1)
		baseCurrency string (1..1)

	output:
		result Money (1..1)

	alias undisputedAdjustedPostedCreditSupportAmount:
		UndisputedAdjustedPostedCreditSupportAmount( postedCreditSupportItems, priorDeliveryAmountAdjustment, priorReturnAmountAdjustment, disputedPostedCreditSupportAmount, baseCurrency )

	alias creditSupportAmount:
		CreditSupportAmount( marginAmount, threshold, marginApproach, marginAmountIA, baseCurrency )

	alias deliveryAmount:
		Max( creditSupportAmount -> amount - undisputedAdjustedPostedCreditSupportAmount -> amount, 0.0 )

	alias undisputedDeliveryAmount:
		Max( deliveryAmount - disputedDeliveryAmount -> amount, 0.0 )

	condition:
		( baseCurrency = minimumTransferAmount -> currency )
		and ( baseCurrency = disputedDeliveryAmount -> currency )

	assign-output result -> amount:
		if undisputedDeliveryAmount >= minimumTransferAmount -> amount
		then RoundToNearest( undisputedDeliveryAmount, rounding -> deliveryAmount, RoundingModeEnum -> Up )
		else 0.0

	assign-output result -> currency:
		baseCurrency


func ReturnAmount:
	[calculation]

	inputs:
		postedCreditSupportItems PostedCreditSupportItem (0..*)
		priorDeliveryAmountAdjustment Money (1..1)
		priorReturnAmountAdjustment Money (1..1)
		disputedPostedCreditSupportAmount Money (1..1)
		marginAmount Money (1..1)
		threshold Money (1..1)
		marginApproach MarginApproachEnum (1..1)
		marginAmountIA Money (0..1)
		minimumTransferAmount Money (1..1)
		rounding CollateralRounding (1..1)
		disputedReturnAmount Money (1..1)
		baseCurrency string (1..1)

	output:
		result Money (1..1)

	alias undisputedAdjustedPostedCreditSupportAmount:
		UndisputedAdjustedPostedCreditSupportAmount( postedCreditSupportItems, priorDeliveryAmountAdjustment, priorReturnAmountAdjustment, disputedPostedCreditSupportAmount, baseCurrency )

	alias creditSupportAmount:
		CreditSupportAmount( marginAmount, threshold, marginApproach, marginAmountIA, baseCurrency )

	alias returnAmount:
		Max( undisputedAdjustedPostedCreditSupportAmount -> amount - creditSupportAmount -> amount, 0.0 )

	alias undisputedReturnAmount:
		Max( returnAmount - disputedReturnAmount -> amount, 0.0 )

	condition:
		( baseCurrency = minimumTransferAmount -> currency )
		and ( baseCurrency = disputedReturnAmount -> currency )

	assign-output result -> amount:
		if undisputedReturnAmount >= minimumTransferAmount -> amount
		then RoundToNearest( undisputedReturnAmount, rounding -> returnAmount, RoundingModeEnum -> Down )
		else 0.0

	assign-output result -> currency:
		baseCurrency


func CreditSupportAmount:
	[calculation]

	inputs:
		marginAmount Money (1..1)
		threshold Money (1..1)
		marginApproach MarginApproachEnum (1..1)
		marginAmountIA Money (0..1)
		baseCurrency string (1..1)

	output:
		result Money (1..1)

	alias creditSupportAmountCalc:
		Max( marginAmount -> amount - threshold -> amount, 0.0 )

	condition:
		( baseCurrency = marginAmount -> currency )
		and ( baseCurrency = threshold -> currency )
		and ( if marginAmountIA exists then baseCurrency = marginAmountIA -> currency else True )

	condition:
		if marginApproach = MarginApproachEnum -> Distinct or marginApproach = MarginApproachEnum -> Allocated
		then marginAmountIA is absent
		else if marginApproach = MarginApproachEnum -> GreaterOf
		then marginAmountIA exists

	assign-output result -> amount:
		if marginApproach = MarginApproachEnum -> Distinct or marginApproach = MarginApproachEnum -> Allocated
		// TODO if allocated the CreditSupportAmount is used in further calculations for the marginAmountIA
		then creditSupportAmountCalc
		else if marginApproach = MarginApproachEnum -> GreaterOf
		then Max( creditSupportAmountCalc, marginAmountIA -> amount )

	assign-output result -> currency:
		baseCurrency


func UndisputedAdjustedPostedCreditSupportAmount:
	[calculation]

	inputs:
		postedCreditSupportItems PostedCreditSupportItem (0..*)
		priorDeliveryAmountAdjustment Money (1..1)
		priorReturnAmountAdjustment Money (1..1)
		disputedPostedCreditSupportAmount Money (1..1)
		baseCurrency string (1..1)

	output:
		result Money (1..1)
		
	alias totalPostedCreditSupportAmount:
		SumPostedCreditSupportItemAmounts( postedCreditSupportItems, baseCurrency )

	alias adjustedPostedCreditSupportAmount:
		totalPostedCreditSupportAmount -> amount + priorDeliveryAmountAdjustment -> amount - priorReturnAmountAdjustment -> amount

	condition:
		( baseCurrency = priorDeliveryAmountAdjustment -> currency )
		and ( baseCurrency = priorReturnAmountAdjustment -> currency )
		and ( baseCurrency = disputedPostedCreditSupportAmount -> currency )
	
	assign-output result -> amount:
		adjustedPostedCreditSupportAmount - disputedPostedCreditSupportAmount -> amount
	
	assign-output result -> currency:
		baseCurrency


func SumPostedCreditSupportItemAmounts:
	[calculation]

	inputs:
		postedCreditSupportItems PostedCreditSupportItem (1..*)
		baseCurrency string (1..1)

	output:
		result Money (1..1)


func PostedCreditSupportItemAmount:
	[calculation]

	inputs:
		item PostedCreditSupportItem (1..1)
		baseCurrency string (1..1)

	output:
		result Money (1..1)

	alias cashOrSecurityValue:
		item -> cashOrSecurityValue -> amount

	alias valuationPercentage:
		item -> valuationPercentage

	alias fxHaircutPercentage:
		item -> fxHaircutPercentage

	alias postedCreditSupportAmount:
		cashOrSecurityValue * ( valuationPercentage - fxHaircutPercentage ) / 100.0

	alias undisputedPostedCreditSupportAmount:
		postedCreditSupportAmount - item -> disputedCashOrSecurityValue -> amount

	condition:
		( baseCurrency = item -> cashOrSecurityValue -> currency ) 
		and ( baseCurrency = item -> disputedCashOrSecurityValue -> currency )

	assign-output result -> amount:
		undisputedPostedCreditSupportAmount

	assign-output result -> currency:
		baseCurrency


type PostedCreditSupportItem:
	cashOrSecurityValue Money (1..1)
	valuationPercentage number (1..1)
	fxHaircutPercentage number (1..1)
	disputedCashOrSecurityValue Money (1..1)


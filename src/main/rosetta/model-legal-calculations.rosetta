namespace "org.isda.cdm"
version "${project.version}"

// TODO: paragraph 2
// Scenario A: trading relationship ceases, security interest released all collateral return (even if under MTA)
// Scenario B: trading relationship falls below 50M IM threshold, security interest released all collateral return (even if under MTA)

func DeliveryAmountIM:
	[calculation]
	
	inputs:
		marginAmount Money (1..1)
		threshold Money (1..1)
		marginApproach MarginApproachEnum (1..1)
		marginAmountIA Money (0..1)
		postedCreditSupportAmounts PostedCreditSupportAmount (1..*)
		priorDeliveryAmountAdjustment Money (1..1) // add doc wording
		priorReturnAmountAdjustment Money (1..1) // add doc wording
		minimumTransferAmount Money (1..1)
		rounding CollateralRounding (1..1)
		baseCurrency string (1..1)
		
	output:
		result Money (1..1)

	alias postedCreditSupportAmount:
		SumPostedCreditSupportAmountsIM( postedCreditSupportAmounts, baseCurrency )

	alias creditSupportAmount:
		CreditSupportAmountIM( marginAmount, threshold, marginApproach, marginAmountIA, baseCurrency )
 
	alias adjustedPostedCreditSupportAmount: 
		postedCreditSupportAmount -> amount + priorDeliveryAmountAdjustment -> amount - priorReturnAmountAdjustment -> amount

	alias deliveryAmount:
		Max( creditSupportAmount -> amount - adjustedPostedCreditSupportAmount, 0.0 )

	condition:
		baseCurrency = 
			( marginAmount -> currency
				and threshold -> currency
				and creditSupportAmount -> currency 
				and postedCreditSupportAmounts -> cashOrSecurityValue -> currency 
				and priorDeliveryAmountAdjustment -> currency
				and priorReturnAmountAdjustment -> currency
				and minimumTransferAmount -> currency )

	assign-output result -> amount:
		if deliveryAmount >= minimumTransferAmount -> amount
		then RoundToNearest( deliveryAmount, rounding -> deliveryAmount, RoundingModeEnum -> Up )
		else 0.0
	
	assign-output result -> currency:
		baseCurrency


func ReturnAmountIM: 
	[calculation]
	
	inputs:
		marginAmount Money (1..1)
		threshold Money (1..1)
		marginApproach MarginApproachEnum (1..1)
		marginAmountIA Money (0..1)
		postedCreditSupportAmounts PostedCreditSupportAmount (1..*)
		priorDeliveryAmountAdjustment Money (1..1) // add doc wording
		priorReturnAmountAdjustment Money (1..1) // add doc wording
		minimumTransferAmount Money (1..1)
		rounding CollateralRounding (1..1)
		baseCurrency string (1..1)
	
	output:
		result Money (1..1)

	alias postedCreditSupportAmount:
		SumPostedCreditSupportAmountsIM( postedCreditSupportAmounts, baseCurrency )

	alias creditSupportAmount:
		CreditSupportAmountIM( marginAmount, threshold, marginApproach, marginAmountIA, baseCurrency )
 
	alias adjustedPostedCreditSupportAmount: 
		postedCreditSupportAmount -> amount + priorReturnAmountAdjustment -> amount - priorDeliveryAmountAdjustment -> amount

	alias returnAmount:
		Max( postedCreditSupportAmount -> amount - creditSupportAmount -> amount, 0.0 )

	condition:
		baseCurrency = 
			( marginAmount -> currency
				and threshold -> currency
				and creditSupportAmount -> currency 
				and postedCreditSupportAmounts -> cashOrSecurityValue -> currency 
				and priorDeliveryAmountAdjustment -> currency
				and priorReturnAmountAdjustment -> currency
				and minimumTransferAmount -> currency )

	assign-output result -> amount:
		if returnAmount >= minimumTransferAmount -> amount
		then RoundToNearest( returnAmount, rounding -> returnAmount, RoundingModeEnum -> Down )
		else 0.0

	assign-output result -> currency:
		baseCurrency


func CreditSupportAmountIM:
	[calculation]
	
	inputs:
		marginAmount Money (1..1)
		threshold Money (1..1)
		marginApproach MarginApproachEnum (1..1)
		marginAmountIA Money (0..1)
		baseCurrency string (1..1)
	
	output: 
		result Money (1..1)

	alias creditSupportAmountCalc:
		Max( marginAmount -> amount - threshold -> amount, 0.0 )
	
	condition:
		baseCurrency = 
			( marginAmount -> currency and threshold -> currency and marginAmountIA -> currency )

	condition:
		if marginApproach = MarginApproachEnum -> Distinct or marginApproach = MarginApproachEnum -> Allocated
		then marginAmountIA is absent
		else if marginApproach = MarginApproachEnum -> GreaterOf
		then marginAmountIA exists

	assign-output result -> amount:
		if marginApproach = MarginApproachEnum -> Distinct or marginApproach = MarginApproachEnum -> Allocated 
		// TODO if allocated the CreditSupportAmount_IM is used in further calculations for the marginAmountIA
		then creditSupportAmountCalc
		else if marginApproach = MarginApproachEnum -> GreaterOf
		then Max( creditSupportAmountCalc, marginAmountIA -> amount )

	assign-output result -> currency:
			baseCurrency


func SumPostedCreditSupportAmountsIM:
	[calculation]
	
	inputs:
		postedCreditSupportAmounts PostedCreditSupportAmount (1..*)
		baseCurrency string (1..1)
		
	output:
		result Money (1..1)

	condition:
		baseCurrency = postedCreditSupportAmounts -> cashOrSecurityValue -> currency


func PostedCreditSupportAmountIM:
	[calculation]
	
	inputs:
		postedCreditSupportAmount PostedCreditSupportAmount (1..1)
		baseCurrency string (1..1)

	output:
		result Money (1..1)
	
	alias cashOrSecurityValue:
		postedCreditSupportAmount -> cashOrSecurityValue -> amount

	alias valuationPercentage:
		postedCreditSupportAmount -> valuationPercentage

	alias fxHaircutPercentage:
		postedCreditSupportAmount -> fxHaircutPercentage

	condition:
		baseCurrency = postedCreditSupportAmount -> cashOrSecurityValue -> currency

	assign-output result -> amount:
		cashOrSecurityValue * ( valuationPercentage - fxHaircutPercentage ) / 100.0

	assign-output result -> currency:
		baseCurrency


type PostedCreditSupportAmount:
	cashOrSecurityValue Money (1..1)
	valuationPercentage number (1..1)
	fxHaircutPercentage number (1..1)

	
enum MarginApproachEnum:
	Distinct
	Allocated
	GreaterOf

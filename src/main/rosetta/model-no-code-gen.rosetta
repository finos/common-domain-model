namespace "org.isda.cdm"
version "${project.version}"


/*
 * Function specification for Portfolio Aggregation
 *
 * COMMENTED-OUT FOR NOW, THIS WILL NEEDS TO BE ADJUSTED TO REFLECT THE NEW FUNCTION SPEC SYNTAX
 *
 */

/*
spec TransitionPortfolioState <"Specification to transition the state of a Portfolio based on its current state and a new set of Events. The eventList being passed on is meant to be already filtered on both time and aggregation parameters for the underlying Portfolio.">: 
	inputs:
		currentState PortfolioState (1..1)
		eventList Event (1..1)
		aggregationParams AggregationParameters (1..1)
		
	output:
		newState PortfolioState (1..1)

	pre-condition <"New set of Events must be posterior to the latest Events on the previous PortfolioState.">:
		MinDatetime( eventList -> timestamp -> dateTime ) >= MaxDatetime( currentState -> lineage -> eventReference -> timestamp );
		
	pre-condition <"Events must be pre-filtered and therefore applicable to the aggregation parameters of the Portfolio.">:
		IsApplicableEvent( eventList, aggregationParams );

//	post-condition <"Update the new positions list based on adding the PositionEffect of the new Events to the current positions list, using the further specified + operator">:
//		newState -> positions = currentState -> positions + PositionEffect( eventList );
		
	post-condition <"Event lineage of the new state pointing to the latest set of Events.">: 
		newState -> lineage -> eventReference = eventList;
		
	post-condition <"PortfolioState lineage of the new state pointing to the current, and now previous, state.">:
		newState -> lineage -> portfolioStateReference = currentState;

spec MinDatetime:
	inputs:
		datetimes zonedDateTime (1..*)
	output:
		result zonedDateTime (1..1)

spec MaxDatetime:
	inputs:
		datetimes zonedDateTime (1..*)
	output:
		result zonedDateTime (1..1)

spec IsApplicableEvent <"Specification for boolean check whether an Event is applicable to a given Portfolio as defined by its AggregationParameters">:
	inputs:
		event Event (1..1)
		aggregationParams AggregationParameters (1..1)
		 
	output:
		isApplicable boolean (1..1)

spec PositionEffect <"Specification to extract the position effect as a Delta from an Event.">:
	inputs:
		event Event (1..1)
	output:
		positionEffect Position (1..1)

	// Refactoring: move as a "method" and the Event class to extract position effects based on primitive
	post-condition:
		if event -> primitive -> inception exists then
			positionEffect = PositionEffect( event -> primitive -> inception )
		else True;


spec PositionEffect( inception Inception) -> positionEffect Position
<"Specification of PositionEffect for the inception primitive, which corresponds to creating a Position instantiated with the uderlying contractual product and quantity, the status as Formed and a reference to contract now in place..">
{
	positionEffect -> product = inception -> after -> contract -> contractualProduct
			positionEffect -> quantity = inception -> after -> contract -> quantity
			positionEffect -> contractReference = -> inception -> after -> contract
			positionEffect -> positionStatus = PositionStatusEnum.Formed
}

spec operator + ( positionA Position, positionB Position ) -> sumPosition Position
<"Operator specification to add 2 positions together.">
{
	// TBD: further define here?
}
*/


/*
 * Option 2 - A mark to market calculation for an FX Forward as provided by a member firm, but providing more transparency to the inputs of the interpolation function
 * 
 *   1. + explicit in which model elements are being passed into function calls
 *   2. - will require lots of product specific logic in a calculation that should be product agnostic
 * 
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 * TODO: (non-critical) Change to use alias, so to clearly distinguish between calculation inputs and 'syntactic sugar', enforce non-calc-inputs to be alias'
 * TODO: (non-critical) SpotRate( fx ) -> rate is unnecessary, SpotRate( fx ) should be enough, as it returns only 1 value 
 */
calculation FxMarkToMarket_2 <"Representation of sample mark to market calculation provided by a member firm, providing more transparency on the parameters used to interpolate the mark to market rate.">
{	
	: (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate
	
	where 
		// variables used in the rate InterpolateFull function call, below.
		fx:
			ForwardPayout -> foreignExchange
			
		tenor:
			fx -> tenorPeriod -> periodMultiplier
		
		today:
			Today()
			
		tenorRemaining: 
			ForwardPayout -> settlementDate + today -> time
			
		spotRate:
			SpotRate( fx ) -> rate
			
		forwardRate:
			ForwardRate( fx -> tenorPeriod, fx ) -> rate
		
		// actual calculation inputs
		interpolatedRate <"The interpolated rate.">: 
			42.0 // Interpolate( tenor - tenorRemaining, 0, tenor, spotRate, forwardRate ) -> result
			
		quotedQuantity <"The amount of the quoted currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency2 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency1 -> cashflowAmount -> amount
			
		baseQuantity <"The amount of the base currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency1 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency2 -> cashflowAmount -> amount
}

function Today() <"Returns the current date of the operating system.">
{
	date date;
	time time;
}

function Interpolate( x number,  xStart int, xEnd int, yStart number, yEnd number ) <"Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ([xStart, xEnd], [yStart, yEnd]), evaluated at x.">
{
	result number;	
}

function SpotRate( fx ForeignExchange ) <"An external market data lookup for the spot fx for the currency pair.">
{
	rate number;
}

function ForwardRate( tenor Period, fx ForeignExchange ) <"An external market data lookup for the forward fx rate for the currency pair, making use of the period specified on the Foreign Exchange contract.">
{
	rate number;
}

/* 
 * Option 3 - reference other calculations, potential to make calculations product agnostic
 * 
 *   1. + Mark to market calculation described in product-agnostic terms
 *   2. + Product specific logic (i.e. to extract price and quantity) are abstracted into other 'calculations' or functions
 *   3. + Price and quantity abstractions can be reused in Portfolio processing
 *   4. - More work involved upgrade syntax and code generators
 * 
 * TODO: requires support for referencing calculations from calculations
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 */
/*
calculation MarkToMarket_3 <"Representation of sample mark to market calculation provided by a member firm.">
{
		= tradedQuantity * (tradedPrice - marketPrice)
	
	where
		tradedPrice <"The amount of the quoted currency.">: 
			TradedPrice( EconomicTerms -> payout )
			
		tradedQuantity <"The amount of the base currency.">: 
			TradedQuantity( EconomicTerms -> payout )
			
		marketPrice:
			CalculateMarketPrice( ForwardPayout ) -> result
}

calculation TradedQuantity <"A calculation that takes a Payout and returns the traded quantity.">
{
	= 	if Payout -> forwardPayout -> foreignExchange exists 
		then 
			if ForeignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForeignExchange -> exchangedCurrency1 -> cashflowAmount -> amount 
			else ForeignExchange -> exchangedCurrency2 -> cashflowAmount -> amount
		else if  
			if Payout -> interestRatePayout -> exists 
			then Payout -> interestRatePayout -> ... -> notionalAmount
			else 0.0
		else if 
			...
}

calculation TradedPrice
{
	= 	if Payout -> forwardPayout -> foreignExchange exists 
			then Payout -> forwardPayout -> foreignExchange -> exchangeRate -> rate
		else if Payout -> interestRatePayout exists
			then 
				... 
}

calculation CalculateMarketPrice
{
	= Interpolate(x, xStart, xEnd, yStart, yEnd)
	
	where 
		tenorRemaining: 
			EconomicTerms -> payout -> forwardPayout -> settlementDate - Today() -> date
			
		tenor:
			Tenor( EconomicTerms )
			
		x: 
			tenor - tenorRemaining
			
		xStart:
			0
			
		xEnd:
			tenor
			
		yStart:
			ForwardRate( ForwardPayout -> foreignExchange -> tenorPeriod, ForwardPayout -> foreignExchange ) -> rate
			
		yEnd:
			SpotRate( ForwardPayout -> foreignExchange ) -> rate
}
*/
namespace "org.isda.cdm"
version "${project.version}"

/*
<<<<<<< HEAD
=======
 * Function Specifications to process Equity Swap lifecycle events (beyond execution)
 *
 * The sequence of business events being demonstrated will do the following:
 * 1) Create a new contract file that corresponds to an Equity Swap (Ingestion)
 * 2) Create a new MCA which attributes match the relevant terms of that Equity Swap (method TBD)
 * 3) Create a new contract event using the NewContractEvent function, that takes its inputs (product, parties, legal agreement) as references from the above
 * 4) Create a new observation event for the equity price
 * 5) Create a new reset event based on that observation
 * 6) Create a new transfer event based on that reset
 */


/*
 * Function Specifications for Equity Swap product creation
 *
 * These should be implementation-specific, and exist in implementors' "private" extensions of the CDM rather than the public CDM
 * They are positionned here for illustration of the equity workflow as part of the CDM, until such time when they could be deemed to be moved
 *
*/

spec NewEquitySwapProduct <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement.">:
	inputs: /*<"The minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">*/
		underlier Equity (1..1) /*<"The underlying Equity asset for the swap.">*/
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1) /*<"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">*/
	output:
		product Product (1..1)

	post-condition <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications, and other payout types must be absent.">:
		if masterConfirmation exists then
			product -> contractualProduct -> economicTerms -> payout -> equityPayout = NewSingleNameEquityPayout( underlier, masterConfirmation ) and
			product -> contractualProduct -> economicTerms -> payout -> interestRatePayout = NewFloatingPayout( masterConfirmation )
		else
			product -> contractualProduct -> economicTerms -> payout -> equityPayout = NewSingleNameEquityPayout( underlier, Null() );
	// TODO: add once we have the 'is absent' syntax available
		/*product -> contractualProduct -> economicTerms -> payout -> cashflow is absent;
		product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout is absent;
		product -> contractualProduct -> economicTerms -> payout -> forwardPayout is absent;
		product -> contractualProduct -> economicTerms -> payout -> optionPayout is absent;*/
	/*post-condition <"Non-contractual product types must be absent.">:
		product -> foreignExchange is absent;
		product -> index is absent;
		product -> loan is absent;
		product -> security is absent;*/
		
spec NewSingleNameEquityPayout <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">:
	inputs:
		underlier Equity (1..1)
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output:
		equityPayout EquityPayout (1..1)

	post-condition <"Equity payout must inherit terms from the Master Confirmation Agreement when it exists.">:
		if masterConfirmation exists then
			equityPayout -> returnType = masterConfirmation -> typeOfSwapElection and
			equityPayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod and
			equityPayout -> paymentDates = masterConfirmation -> equityCashSettlementDates and
			equityPayout -> settlementTerms = masterConfirmation -> settlementTerms
		else True;
	post-condition <"Equity payout must be single name on the provided equity underlier.">:
		equityPayout -> underlier -> singleUnderlier -> underlyingProduct -> security -> equity = underlier;
		

spec NewFloatingPayout <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">:
	inputs:
		masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
	output:
		interestRatePayout InterestRatePayout (1..1)

	post-condition <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">:
		if masterConfirmation exists then
			interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod and
			interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates
		else True;

// Temporary mechanism to pass null into functions that have optional arguments
function Null() 
{
	result string;
}

/*
 * Function specification for Portfolio Aggregation
 *
 * COMMENTED-OUT FOR NOW, THIS WILL NEEDS TO BE ADJUSTED TO REFLECT THE NEW FUNCTION SPEC SYNTAX
 *
 */

/*
spec TransitionPortfolioState( currentState PortfolioState, eventList Event, aggregationParams AggregationParameters ) -> newState PortfolioState
<"Specification to transition the state of a Portfolio based on its current state and a new set of Events. The eventList being passed on is meant to be already filtered on both time and aggregation parameters for the underlying Portfolio.">
{
	pre condition:
		min( eventList -> timestamp ) >= max( currentState -> lineage -> eventReference -> timestamp ) <"New set of Events must be posterior to the latest Events on the previous PortfolioState.">
		IsApplicableEvent( eventList, aggregationParams ) <"Events must be pre-filtered and therefore applicable to the aggregation parameters of the Portfolio.">

	post condition:
		newState -> positionList = currentState -> positionList + PositionEffect( eventList ) <"Update the new positions list based on adding the PositionEffect of the new Events to the current positions list, using the further specified + operator">
		newState -> lineage -> eventReference = eventList <"Event lineage of the new state pointing to the latest set of Events.">
		newState -> lineage -> portfolioStateReference = currentState <"PortfolioState lineage of the new state pointing to the current, and now previous, state.">
}

spec IsApplicableEvent( event Event, aggregationParams AggregationParameters ) -> isApplicable boolean
<"Specification for boolean check whether an Event is applicable to a given Portfolio as defined by its AggregationParameters">
{
	//TBD: further define here based on content of aggregationParams? e.g.:
	// when aggregationParams -> party exists and event -> party exists then aggregationParams -> party = event -> party
}

spec PositionEffect( event Event ) -> positionEffect Position
<"Specification to extract the position effect as a Delta from an Event.">
{
	// Refactoring: move as a "method" and the Event class to extract position effects based on primitive
	post condition:
		if event -> primitive -> inception exists
			positionEffect = PositionEffect( event -> primitive -> inception )
}

spec PositionEffect( inception Inception) -> positionEffect Position
<"Specification of PositionEffect for the inception primitive, which corresponds to creating a Position instantiated with the uderlying contractual product and quantity, the status as Formed and a reference to contract now in place..">
{
	positionEffect -> product = inception -> after -> contract -> contractualProduct
			positionEffect -> quantity = inception -> after -> contract -> quantity
			positionEffect -> contractReference = -> inception -> after -> contract
			positionEffect -> positionStatus = PositionStatusEnum.Formed
}

spec operator + ( positionA Position, positionB Position ) -> sumPosition Position
<"Operator specification to add 2 positions together.">
{
	// TBD: further define here?
}
*/


/*
 * Business Event Function Specifications
 */

spec NewContractEvent <"Function specification to create the fully-formed business event of entering into a new contract, as a combination of an execution primitive and a contract formation primitive, when there is no allocation involved and the contractual parties are the execution parties. This specification is meant to replace the 'Inception' primitive that previously co-mingled these 2 primitives.">:
	inputs:
		product Product (1..1)
		partyA Party (1..1)
		partyB Party (1..1)
		legalAgreement LegalAgreement (0..1)
	output:
		event Event (1..1)
	
	post-condition <"Event must contain an execution primitive that corresponds to the product being contracted.">:
		event -> primitive -> execution = NewExecutionFromProduct( product, partyA, partyB );
	post-condition <"Event must contain a contract formation primitive based on the execution primitive and (optionally) the legal agreement.">:
		if legalAgreement exists then
			event -> primitive -> contractFormation = NewContractFormationFromExecution( event -> primitive -> execution -> after, partyA, partyB, legalAgreement )
		else
			event -> primitive -> contractFormation = NewContractFormationFromExecution( event -> primitive -> execution -> after, partyA, partyB, Null() );
	// TODO: add once syntax becomes available as part of Function Spec
	/*post-condition <"When they exist, the parties on the event must match the party inputs.">:
		if event -> party exists then event -> party count = 2 and event -> party contains partyA and event -> party contains partyB else True;*/
	post-condition <"Event effect must point to the new execution and contract, and exclude other effects.">:
		event -> eventEffect -> contract = event -> primitive -> contractFormation -> after -> contract;
		event -> eventEffect -> execution = event -> primitive -> execution -> after -> execution;
		event -> eventEffect -> effectedExecution = event -> primitive -> contractFormation -> before -> execution;
		/*event -> eventEffect -> effectedContract is absent;
		event -> eventEffect -> productIdentifier is absent;
		event -> eventEffect -> transfer is absent;*/

/*
 * Primitive Event Function Specifications 
 */

// spec EquityReset <"Function specification for resetting an equity payout following a price observation, which means calculating the equity performance and resetting the equity notional.">:
// 	inputs:
// 		equityPayout EquityPayout (1..1)
// 		observation number (1..1)
// 	output:
// 		reset ResetPrimitive (1..1)

spec EquityPriceObservation <"Function specification for the observation of an equity price, based on the attributes of the 'EquityValuation' class.">:
	inputs:
		equity Equity (1..1)
		valuationDate AdjustableOrRelativeDate (1..1)
		valuationTime BusinessCenterTime (0..1)
		timeType TimeTypeEnum (0..1)
		determinationMethod DeterminationMethodEnum (1..1)
	output:
		observation ObservationPrimitive (1..1)

	// TODO: add once syntax becomes available as part of Function Spec
	/*pre-condition <"Optional choice between directly passing a time or a timeType, which has to be resolved into a time based on the determination method.">:
		if valuationTime exists then timeType is absent
		else if timeType exists then valuationTime is absent
		else False;*/
	
	post-condition <"The date and time must be properly resolved as attributes on the output.">:
		observation -> date = ToAdjustedDate( valuationDate ) -> adjustedDate;
		if valuationTime exists then
			observation -> time = TimeZoneFromBusinessCenterTime( valuationTime ) -> time
		else
			observation -> time = ResolveTimeZoneFromTimeType( timeType, determinationMethod ) -> time;
	post-condition <"The number recorded in the observation must match the number fetched from the source.">:
		observation -> observation = EquitySpot( equity, observation -> date, observation -> time ) -> spot;

function EquitySpot( equity Equity, date date, time TimeZone ) <"An external market data lookup for the spot equity price of the reference asset based on a determination method.">
{
	spot number;
}

function TimeZoneFromBusinessCenterTime ( time BusinessCenterTime ) <"Function to resolve a time passed as BusinessCenterTime into a TimeZone time.">
{
	time TimeZone;
}

function ResolveTimeZoneFromTimeType( timeType TimeTypeEnum, determinationMethod DeterminationMethodEnum ) <"Function to resolve a TimeType into a TimeZone based on a determination method.">
{
	time TimeZone;
}

spec NewExecutionFromProduct <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">:
	inputs:
		product Product (1..1) /*<"The financial product, either contractual or fungible, that is the subject of the execution.">*/
		partyA Party (1..1) /*<"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">*/
		partyB Party (1..1) /*<"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">*/
		// quantity Quantity (1..1) /*<"The quantity of the financial product being executed.">*/
	output:
		execution ExecutionPrimitive (1..1)
	
	pre-condition <"Parties must be different, and match the contractual parties to the legal agreement when the latter exists.">:
		partyA <> partyB;
	
	// TODO: add condition once 'is absent' syntax available.
	/* post-condition:
		execution -> before is absent;*/
	
	post-condition <"Ensuring that the execution attributes are correctly populated on the output.">:
		// TODO: replace that with directly using the 'Product' attribute on the execution once the corresponding Primitive refactoring is in Prod.
		execution -> after -> execution -> contractualProduct = product -> contractualProduct;
		// TODO: add once syntax becomes available as part of Function Spec
		/*if execution -> after -> execution -> party exists then
			execution -> after -> execution -> party count = 2 and
			execution -> after -> execution -> party contains partyA and
			execution -> after -> execution -> party contains partyB
		else True;*/

spec NewContractFormationFromExecution <"Function specification to create a fully-formed contract following execution on a contractual product. The contract can optionally reference a further legal agreement (such as a CSA or a Master Confirmation).">:
	inputs:
		execution ExecutionState (1..1)
		partyA Party (1..1)
		partyB Party (1..1)
		legalAgreement LegalAgreement (0..1)
		// TODO: remove 'legalAgreementreference' from the 'Execution' class, now that the tie-in to the contract happens as part of this Function Spec
	output:
		contractFormation ContractFormation (1..1)
	
	pre-condition <"Parties must be different, and match the contractual parties to the legal agreement when those exists, and the parties to the execution when those exist.">:
		partyA <> partyB;
		// TODO: add once syntax becomes available as part of Function Spec
		// if legalAgreement exists then
		// 	legalAgreement -> contractualParty contains partyA and
		// 	legalAgreement -> contractualParty contains partyB
		// else True;
		// if execution -> execution -> party exists then 
		// 	execution -> execution -> party contains partyA and
		// 	execution -> execution -> party contains partyB
		// else True;

	// TODO: add once we've switched from 'ContractualProduct' to 'Product' on the 'Execution' class
	/*pre-condition <"Execution must be on a contractual product.">:
		execution -> execution -> product -> contractualProduct exists;*/

	post-condition <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">:
		contractFormation -> before = execution;
		contractFormation -> after -> contract -> contractualProduct = execution -> execution -> contractualProduct;
	post-condition <"When an overlaying legal agreement exists, the contract must reference it.">:
		if legalAgreement exists then contractFormation -> after -> contract -> documentation -> legalAgreement = legalAgreement else True;

spec QuantityChange <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">:
	inputs:
		trade Trade (1..1)
		quantityChange ContractualQuantity (1..1)
	
	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)
	
	pre-condition <"Non-zero quantity change">:
		GreaterThan(quantityChange, 0);

	post-condition <"Correctly populate the before attributes on the Primitive Event">:
		quantityChangePrimitive -> before = trade;
	
	post-condition <"The resulting quantity must equal the original quantity plus the quantity change.">:
		ExtractQuantity( quantityChangePrimitive -> after ) = Plus( ExtractQuantity( trade ), quantityChange );
	 
	post-condition <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution">:
		if quantityChangePrimitive -> after -> execution exists then quantityChangePrimitive -> before /* -> execution */ exists else False;
	
	post-condition:
		if quantityChangePrimitive -> after -> contract exists then quantityChangePrimitive -> after -> contract exists else False;  // should be included as part of the previous post-condition, but currently held back by grammar limitation

		
spec ExtractQuantity <"A function that abstracts away the details of how to retrieve quantity from a given product">:
	inputs:
		trade Trade (1..1)
	output:
		quantity ContractualQuantity (1..1) 
	 
// TODO: turn these functions into language level operators i.e. '+'
spec Plus:
	inputs:
		q1 ContractualQuantity (1..1)
		q2 ContractualQuantity (1..1)
	output:
		result ContractualQuantity (1..1)

// TODO: turn these functions into language level operators i.e. '='
spec Equals:
	inputs:
		contractualQuantity ContractualQuantity (1..1)
		scalar number (1..1)
	output:
		result number (1..1)

// TODO: turn these functions into language level operators i.e. '>'
spec GreaterThan:
	inputs:
		contractualQuantity ContractualQuantity (1..1)
		scalar number (1..1)
	output:
		result number (1..1)
		
// TODO: turn these functions into language level operators i.e. '>='
spec GreaterThanEquals:
	inputs:
		contractualQuantity ContractualQuantity (1..1)
		scalar number (1..1)
	output:
		result number (1..1)

/*
>>>>>>> origin/master
 * Option 2 - A mark to market calculation for an FX Forward as provided by a member firm, but providing more transparency to the inputs of the interpolation function
 * 
 *   1. + explicit in which model elements are being passed into function calls
 *   2. - will require lots of product specific logic in a calculation that should be product agnostic
 * 
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 * TODO: (non-critical) Change to use alias, so to clearly distinguish between calculation inputs and 'syntactic sugar', enforce non-calc-inputs to be alias'
 * TODO: (non-critical) SpotRate( fx ) -> rate is unnecessary, SpotRate( fx ) should be enough, as it returns only 1 value 
 */
calculation FxMarkToMarket_2 <"Representation of sample mark to market calculation provided by a member firm, providing more transparency on the parameters used to interpolate the mark to market rate.">
{	
	: (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate
	
	where 
		// variables used in the rate InterpolateFull function call, below.
		fx:
			ForwardPayout -> foreignExchange
			
		tenor:
			fx -> tenorPeriod -> periodMultiplier
		
		today:
			Today()
			
		tenorRemaining: 
			ForwardPayout -> settlementDate + today -> time
			
		spotRate:
			SpotRate( fx ) -> rate
			
		forwardRate:
			ForwardRate( fx -> tenorPeriod, fx ) -> rate
		
		// actual calculation inputs
		interpolatedRate <"The interpolated rate.">: 
			42.0 // Interpolate( tenor - tenorRemaining, 0, tenor, spotRate, forwardRate ) -> result
			
		quotedQuantity <"The amount of the quoted currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency2 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency1 -> cashflowAmount -> amount
			
		baseQuantity <"The amount of the base currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency1 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency2 -> cashflowAmount -> amount
}

function Today() <"Returns the current date of the operating system.">
{
	date date;
	time time;
}

function Interpolate( x number,  xStart int, xEnd int, yStart number, yEnd number ) <"Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ([xStart, xEnd], [yStart, yEnd]), evaluated at x.">
{
	result number;	
}

function SpotRate( fx ForeignExchange ) <"An external market data lookup for the spot fx for the currency pair.">
{
	rate number;
}

function ForwardRate( tenor Period, fx ForeignExchange ) <"An external market data lookup for the forward fx rate for the currency pair, making use of the period specified on the Foreign Exchange contract.">
{
	rate number;
}

/* 
 * Option 3 - reference other calculations, potential to make calculations product agnostic
 * 
 *   1. + Mark to market calculation described in product-agnostic terms
 *   2. + Product specific logic (i.e. to extract price and quantity) are abstracted into other 'calculations' or functions
 *   3. + Price and quantity abstractions can be reused in Portfolio processing
 *   4. - More work involved upgrade syntax and code generators
 * 
 * TODO: requires support for referencing calculations from calculations
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 */
/*
calculation MarkToMarket_3 <"Representation of sample mark to market calculation provided by a member firm.">
{
		= tradedQuantity * (tradedPrice - marketPrice)
	
	where
		tradedPrice <"The amount of the quoted currency.">: 
			TradedPrice( EconomicTerms -> payout )
			
		tradedQuantity <"The amount of the base currency.">: 
			TradedQuantity( EconomicTerms -> payout )
			
		marketPrice:
			CalculateMarketPrice( ForwardPayout ) -> result
}

calculation TradedQuantity <"A calculation that takes a Payout and returns the traded quantity.">
{
	= 	if Payout -> forwardPayout -> foreignExchange exists 
		then 
			if ForeignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForeignExchange -> exchangedCurrency1 -> cashflowAmount -> amount 
			else ForeignExchange -> exchangedCurrency2 -> cashflowAmount -> amount
		else if  
			if Payout -> interestRatePayout -> exists 
			then Payout -> interestRatePayout -> ... -> notionalAmount
			else 0.0
		else if 
			...
}

calculation TradedPrice
{
	= 	if Payout -> forwardPayout -> foreignExchange exists 
			then Payout -> forwardPayout -> foreignExchange -> exchangeRate -> rate
		else if Payout -> interestRatePayout exists
			then 
				... 
}

calculation CalculateMarketPrice
{
	= Interpolate(x, xStart, xEnd, yStart, yEnd)
	
	where 
		tenorRemaining: 
			EconomicTerms -> payout -> forwardPayout -> settlementDate - Today() -> date
			
		tenor:
			Tenor( EconomicTerms )
			
		x: 
			tenor - tenorRemaining
			
		xStart:
			0
			
		xEnd:
			tenor
			
		yStart:
			ForwardRate( ForwardPayout -> foreignExchange -> tenorPeriod, ForwardPayout -> foreignExchange ) -> rate
			
		yEnd:
			SpotRate( ForwardPayout -> foreignExchange ) -> rate
}
*/
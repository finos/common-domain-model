namespace cdm.base.datetime : <"Basic date and time concepts: relative date, date range, offset, business centre etc.">
version "${project.version}"

func TimeZoneFromBusinessCenterTime: <"Function to resolve a time passed as BusinessCenterTime into a TimeZone time.">
	inputs: time BusinessCenterTime (1..1)
	output: result TimeZone (1..1)

func ResolveAdjustableDate:
	inputs: terminationDate AdjustableOrRelativeDate (1..1)
	output: adjustedDate date (1..1)

func ToDateTime:
	inputs: date date (1..1)
	output: datetime zonedDateTime (1..1)

func ConvertToAdjustableOrRelativeDate: <"Utility function to convert from AdjustableOrAdjustedOrRelativeDate to AdjustableOrRelativeDate">
	inputs:
		adjustableOrAdjustedOrRelativeDate AdjustableOrAdjustedOrRelativeDate (0..1)

	output:
		adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

	alias relativeDate:
		adjustableOrAdjustedOrRelativeDate -> relativeDate

	assign-output adjustableOrRelativeDate -> adjustableDate -> adjustedDate:
		adjustableOrAdjustedOrRelativeDate -> adjustedDate

	assign-output adjustableOrRelativeDate -> adjustableDate -> unadjustedDate:
		adjustableOrAdjustedOrRelativeDate -> unadjustedDate

	assign-output adjustableOrRelativeDate -> adjustableDate -> dateAdjustments:
		adjustableOrAdjustedOrRelativeDate -> dateAdjustments

	assign-output adjustableOrRelativeDate -> relativeDate -> adjustedDate:
		if relativeDate exists then relativeDate -> adjustedDate

	assign-output adjustableOrRelativeDate -> relativeDate -> businessCenters:
		if relativeDate exists then relativeDate -> businessCenters

	assign-output adjustableOrRelativeDate -> relativeDate -> businessDayConvention:
		if relativeDate exists then relativeDate -> businessDayConvention

	assign-output adjustableOrRelativeDate -> relativeDate -> dateRelativeTo:
		if relativeDate exists then relativeDate -> dateRelativeTo

	assign-output adjustableOrRelativeDate -> relativeDate -> dayType:
		if relativeDate exists then relativeDate -> dayType

	assign-output adjustableOrRelativeDate -> relativeDate -> period:
		if relativeDate exists then relativeDate -> period

	assign-output adjustableOrRelativeDate -> relativeDate -> periodMultiplier:
		if relativeDate exists then relativeDate -> periodMultiplier

func Now: <"Current date time.">
	output: now zonedDateTime (1..1)

func Today: <"Current date.">
	output: today date (1..1)


/* added by BALynn to support calculated rates */
// the following are primitive functions that need to be implemented by an implementation
func CombineBusinessCenters: <"Creates a BusinessCenters object that includes the union of business centers in the two supplied lists">
	inputs:
		list1 BusinessCenters(1..1) <"first list of business centers">
		list2 BusinessCenters(1..1) <"second list of business centers">
	output: combinedList BusinessCenters(1..1) <" resulting merged list of business centers">

func InitializeBusinessCenterHolidays:  <"Allows a user to supply a list of holidays for a business center for subesquent use.  This is provided primarily for testing.">
	inputs:
		businessCenter BusinessCenterEnum(1..1)  <"The business center for which holidays are being supplied">
		holidays date(0..*)	<"The list of holidays for that business center">
		applicableDates DateRange(0..1) <"The earliest and latest dates for which this list is effective; used for error checking if supplied">
	output:
		success boolean(1..1)	<"was the holiday list successfully loaded?">

func RetrieveBusinessCenterHolidays: <"Returns a merged list of holidays for the supplied business centers">
	inputs:
		businessCenters BusinessCenters(1..1) <"The business centers for which the holiday list is required">
	output:
		holidays date(0..*)	<"The combined list of holidays in all of the supplied business centers">


func DayOfWeek: <"returns the day of week corresponding to the supplied date">
	inputs:
		date	date(1..1) <"The date for which the weekday is needed">
	output:
		dayOfWeek DayOfWeekEnum(1..1) <"The day of the week as an enumerated value">

func AddDays: <"adds the specified number of calendar days to the supplied date.  A negative number will generate a date before the supplied date.">
	inputs:
		inputDate	date(1..1) <"The base date for the calculation">
		numDays int(1..1) <"The number of days to add">
	output:
		resultDate date(1..1)  <"The date shifted by the specified number of days">

func DateDifference: <"subtracts the two supplied dates to return the number of calendar days between them .  A negative number implies right is after left.">
	inputs:
		leftDate	date(1..1) <"The left side of the subtraction.   ">
		rightDate  date(1..1) <"The right side of the subtraction">
	output:
		difference int(1..1)  <"The number of calendar days leftDate date is after rightDate.  Negative means leftDate is before rightDate.">

func SelectDate: <"Select a date from a list of dates based on index.  If not found return nothing.">
	inputs:
		dateList date(0..*)  <"list to select from">
		position int(1..1)	<"index to look up">
	output:
		date date(0..1)  <"the selected date">
	
func AppendDateToList: <"Add a date to a list of dates">
	inputs:
		dateList date(0..*) <"list of dates">
		newDate date(1..1)	<"date to add to the list">
	output:
		newList date(1..*)	<"the newly increased list">
		
func PopOffDateList:  <"Remove last element from a list of dates">
	inputs:
		dateList date(0..*) <"list of dates">
	output:
		newList date(0..*)	<"the newly created list, omitting the last element of the original list">
		
// the following are implemented in Rosetta based on the above primitives
func IsWeekend: <"returns whether the supplied date is a weekend.  This assumes a 5 day week with Saturday and Sunday as holidays.  A more sophisticated implementation might use the business centers to determine which days are weekends, but most jurisdictions where derivatives are traded follow this convention.">
	[calculation]
	inputs:
		date	date(1..1) <"The date for which the weekday is needed">
		businessCenters BusinessCenters(0..1) <"not needed for the current implementation so ignored, but kept for future extensibility">
	output:
		isWeekend boolean(1..1)
	alias dayOfWeek : DayOfWeek(date)  // determine the day of the week
	// output whether the date is on a weekend by comparing against SAT or SUN
	assign-output isWeekend : dayOfWeek = DayOfWeekEnum->SAT or dayOfWeek = DayOfWeekEnum->SUN

func IsHoliday: <"Returns whether a day is a holiday for the specified business centers">
	[calculation]
	inputs:
		checkDate	date(1..1) <"The date being tested">
		businessCenters BusinessCenters(1..1) <"The business centers for which the test is required">
	output:
		isHoliday boolean(1..1) <"true if the supplied date is a holiday">
	// get the combined list of holidays for the supplied business centers	
	alias holidays : RetrieveBusinessCenterHolidays(businessCenters)
	
	// check if the supplied date is contained in the holiday list
	assign-output isHoliday : holidays contains checkDate

func IsBusinessDay: <"returns an indicator of whether the supplied date is a good business date given the supplied business centers.  True => good date, i.e. not a weekend or holiday. False means that it is either a weekend or a holiday">
	[calculation]
	inputs:
		date date(1..1)	<"The date for which we want to determine whether it's a good business day">
		businessCenters BusinessCenters(1..1)	<"The list of business centers to use">
	output:
		isGoodBusinessDay boolean(1..1)  <"True if a good business day, false if a weekend or holiday">
	// determine if a weekend or holiday
	alias weekend : IsWeekend(date, businessCenters)
	alias holiday : IsHoliday(date, businessCenters)
	// return whether it's a good business day
	assign-output isGoodBusinessDay : if weekend or holiday then False else True

func AddBusinessDays: <"Returns a good business date that has been offset by the given number of business days given the supplied business centers.  A negative value implies an earlier date (before the supplied originalDate), and a positive value a later date (after the supplied date).">
	[calculation]
	inputs:
		originalDate date(1..1) <"date to be shifted.  If not a good business day, a supplied shift of 0 will shift it to the next business day">
		offsetBusinessDays  int(1..1) <"number of business days to shift the original date">
		businessCenters BusinessCenters(1..1) <"business centers to use in the shifting">
	output:
		shiftedDate date(1..1)
	alias isGoodBusinessDay :IsBusinessDay(originalDate, businessCenters)		//check if a good business day
	alias shift : if offsetBusinessDays < 0 then -1 else 1					// determine the direction of shifting, earlier or later
	// calculate the new offset:  if we're at a good business day, reduce by one, else keep it  //
	alias newOffset : if offsetBusinessDays = 0 then 0 else if isGoodBusinessDay then offsetBusinessDays - shift else offsetBusinessDays
	alias shiftedByOne : AddDays(originalDate, shift)			// add/substract one calendar day
	alias done : offsetBusinessDays = 0 and isGoodBusinessDay	// we're done if the offsetBusinessDays is 0 and it's a good business day
	// calculate the shifted date:  if we're done, return the supplied date, else recursively try after having shifted by one day (recursion because iteration isn't supported by the Rosetta DSL)
	alias newDate : if  done then originalDate else   AddBusinessDays(shiftedByOne, newOffset, businessCenters)
	assign-output shiftedDate : newDate

func GenerateDateList: <"Creates a list of good business days starting from the startDate and going to the end date, inclusive, omitting any days that are weekends or holidays according to the supplied business ceneters.">
	[calculation]
	inputs:
		startDate date(1..1) <" start of the date range to be generated">
		endDate date(1..1) <" end of the date range to be generated">
		businessCenters BusinessCenters(1..1)	<"business centers to be used to generate the list of good business days">
	output:
		dateList date(0..*) <" resulting list of good business days">
	alias active : startDate <= endDate		// do we have anyting to do?  Nothing to do if start date is after end date
	alias isGoodBusinessDay : IsBusinessDay(endDate, businessCenters)		// is endDate a good business day?
	alias priorDate : AddBusinessDays(endDate, -1, businessCenters)			// find the previous good business day before the endDate
	alias priorList : GenerateDateList(startDate, priorDate, businessCenters)	// recursively find the list of dates from the start to the prior business day
	// add the current end date to the previous list if it is a good business day  (the test handles the case when the first supplied end date is not a business day)
	alias newList : if isGoodBusinessDay then AppendDateToList(priorList, endDate) else priorList
	assign-output dateList : if  active then  newList   // else empty list
/*
func AdjustDate: <"Returns a date that has been adjusted by the supplied BusinessDayConvention with the supplied BusinessCenters">
	inputs:
		unadjustedDate date(1..1)  <" date to be adjusted">
		businessDayConvention BusinessDayConventionEnum(1..1)	<" business day convention to use in the adjustment">
		businessCenters BusinessCenters(1..1)	<" business ceneters to use in the adjustment">
	output: adjustedDate date(1..1)
*/
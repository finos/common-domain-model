namespace org.isda.cdm
version "${project.version}"

import cdm.base.*
import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.observable.*
import cdm.observable.event.*
import cdm.observable.asset.*
import cdm.observable.common.*

import cdm.synonyms.config.*

type Asian: <"As per ISDA 2002 Definitions.">

	averagingInOut AveragingInOutEnum (1..1)
	strikeFactor number (0..1) <"The factor of strike.">
	averagingPeriodIn AveragingPeriod (0..1) <"The averaging in period.">
	averagingPeriodOut AveragingPeriod (0..1) <"The averaging out period.">

type AveragingObservationList: <"An unordered list of weighted averaging observations.">

	averagingObservation WeightedAveragingObservation (1..*) <"A single weighted averaging observation.">

type AveragingPeriod: <"Period over which an average value is taken.">

	schedule AveragingSchedule (0..*) <"A schedule for generating averaging observation dates.">
	averagingDateTimes DateTimeList (0..1) <"An unweighted list of averaging observation date and times.">
	averagingObservations AveragingObservationList (0..1) <"A weighted list of averaging observation date and times.">
	marketDisruption MarketDisruptionEnum (0..1) <"The market disruption event as defined by ISDA 2002 Definitions.">
		[metadata scheme]

	condition Choice: <" Choice rule to represent an FpML choice construct between unweighted and weighted averaging date and times.">
		optional choice averagingDateTimes, averagingObservations

type AveragingSchedule: <"Class to representing a method for generating a series of dates.">

	startDate date (1..1) <"Date on which this period begins.">
	endDate date (1..1) <"Date on which this period ends.">
	averagingPeriodFrequency CalculationPeriodFrequency (1..1) <"The frequency at which averaging period occurs with the regular part of the valuation schedule and their roll date convention.">

type Barrier: <"As per ISDA 2002 Definitions.">

	barrierCap TriggerEvent (0..1) <"A trigger level approached from beneath.">
	barrierFloor TriggerEvent (0..1) <"A trigger level approached from above.">

type CalendarSpread: <"A type for defining a calendar spread feature.">

	expirationDateTwo AdjustableOrRelativeDate (1..1)

type Composite: <"Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.">

	determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which an amount or a date is determined.">
	relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">
	fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">

type FxFeature: <"A type for defining FX Features.">

	referenceCurrency string (1..1) <"Specifies the reference currency of the trade.">
		[metadata id]
		[metadata scheme]
	composite Composite (0..1) <"If 'Composite' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price – Strike Price) / (Strike Price – Settlement Price) x Multiplier provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
	/*
	 * The below quanto associated definition makes reference to the Equity definitions.  Is that right, considering the cross-assets use of this construct?
	 */
	quanto Quanto (0..1) <"If 'Quanto' is specified as the Settlement Type in the relevant Transaction Supplement, an amount, as determined by the Calculation Agent in accordance with the Section 8.2 of the Equity Definitions.">
	crossCurrency Composite (0..1) <"If 'Cross-Currency' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price – Strike Price) / (Strike Price – Settlement Price) x Multiplier x one unit of the Reference Currency converted into an amount in the Settlement Currency using the rate of exchange of the Settlement Currency as quoted on the Reference Price Source on the Valuation Date, provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
	condition Choice: <" Choice rule to represent an FpML choice construct.">
		required choice composite, quanto, crossCurrency

type Knock: <"Knock In means option to exercise comes into existence. Knock Out means option to exercise goes out of existence.">

	knockIn TriggerEvent (0..1) <"The knock in.">
	knockOut TriggerEvent (0..1) <"The knock out.">

type OptionDenomination: <"Class which corresponds to the FpML OptionDenomination.model group.">

	optionEntitlement number (1..1) <"The number of units of underlier per option comprised in the option transaction.">
	entitlementCurrency string (0..1) <"The currency in which the option is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[metadata scheme]
	numberOfOptions number (0..1) <"The number of options comprised in the option transaction.">
	condition PositiveOptionEntitlement: <" In FpML the optionEntitlement element is specified as a positive decimal.">
		if optionEntitlement exists
		then optionEntitlement >= 0.0

	condition PositiveNumberOfOptions: <" In FpML the numberOfOptions element is specified as a positive decimal.">
		if numberOfOptions exists
		then numberOfOptions >= 0.0

type OptionFeature: <"A class for defining option features.">

	fxFeature FxFeature (0..1) <"A quanto or composite FX feature.">
	strategyFeature StrategyFeature (0..1) <"A simple strategy feature.">
	asian Asian (0..1) <"An option where and average price is taken on valuation.">
	barrier Barrier (0..1) <"An option with a barrier feature.">
	knock Knock (0..1) <"A knock feature.">
	passThrough PassThrough (0..1) <"Pass-through payments from the underlier, such as dividends.">

type OptionProvision: <"A class for defining option provisions.">
	cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">
	extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">

type OptionSettlement extends SettlementTerms: <"The option settlement terms, which can either be cash, physical, or fx-based cash-settlement. This class can be used for both the settlement of options or forwards.">
	// TBD: refactor OptionCashSettlement and FxCashSettlement to be a unique class, where cash settlement can be specified in a given currency?
	cashSettlementTerms OptionCashSettlement (0..1) <"Specifies the parameters associated with the cash settlement procedure.">
	physicalSettlementTerms OptionPhysicalSettlement (0..1) <"Specifies the physical settlement terms which apply to the transaction.">
	fxSettlementTerms FxCashSettlement (0..1) <"Specifies the cash settlement of a non deliverable fx option / forward. It includes the currency to settle into together with the fixings required to calculate the currency amount">
	condition Choice: <"The option settlement cannot combine both physical and cash terms specification.">
		optional choice cashSettlementTerms, physicalSettlementTerms, fxSettlementTerms

	condition CashSettlementTerms: <"If the cash settlement terms are specified, then the settlementType can either be Cash, Election or CashOrPhysical">
		if cashSettlementTerms exists
		then settlementType <> SettlementTypeEnum -> Physical

	condition PhysicalSettlementTerms: <"If the physical settlement terms are specified, then the settlementType can either be Physical, Election or CashOrPhysical">
		if physicalSettlementTerms exists
		then settlementType <> SettlementTypeEnum -> Cash

type OptionStrike: <"A class to specify the option strike.">

	spread number (0..1) <"The strike of a credit default swap option or credit swaption when expressed as a spread per annum.">
	price number (0..1) <"The strike of a credit default swap option or credit swaption when expressed as in reference to the price of the underlying obligation(s) or index.">
	currency string (0..1) <"The currency in which the option strike is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[metadata scheme]
	percentage number (0..1) <"The price or level expressed as a percentage of the forward starting spot price.">
	strikeReference FixedRateSpecification (0..1) <"The strike of an option on a credit default swap when expressed in reference to the spread of the underlying swap (typical practice in the case of credit single name swaps).">
		[metadata reference]
	referenceSwapCurve ReferenceSwapCurve (0..1) <"The strike of an option when expressed by reference to a swap curve. (Typically the case for a convertible bond option.)">
	condition: one-of

type OptionStyle: <"The qualification of the option style: American, Bermuda or European. FpML implements those features as part of a substitution group.">

	americanExercise AmericanExercise (0..1)
	bermudaExercise BermudaExercise (0..1)
	europeanExercise EuropeanExercise (0..1)
	condition: one-of

type PassThrough: <"Type which contains pass through payments.">

	passThroughItem PassThroughItem (1..*) <"One to many pass through payment items.">

type PassThroughItem: <"Class to represent a single pass through payment.">

	payerReceiver PayerReceiver (1..1) <"This attribute doesn't exists in the FpML construct, which makes use of the PayerReceiver.model group.">
// TODO - To be developed	
//	underlier Underlier (1..1) reference <"This attribute is specified in FpML as a reference to the underlier whose payments are being passed through. In the CDM, it is specified as this actual underlier.">
//
	passThroughPercentage number (1..1) <"Percentage of payments from the underlier which are passed through.">

/*
 * The below definition originating from FpML probably needs to be updated, as it is very equity-specific.
 */
type Quanto: <"Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a currency that is different from the currency denomination of the underlier.">

	fxRate FxRate (0..*) <"Specifies a currency conversion rate.">
	fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">

type StrategyFeature: <"A class for defining option strategy features.">

	strikeSpread StrikeSpread (0..1) <"Definition of the upper strike in a strike spread.">
	calendarSpread CalendarSpread (0..1) <"Definition of the later expiration date in a calendar spread.">

type StrikeSpread: <"A class for defining a strike spread feature.">

	upperStrike OptionStrike (1..1) <"Upper strike in a strike spread.">
	upperStrikeNumberOfOptions number (1..1) <"Number of options at the upper strike price in a strike spread.">

type WeightedAveragingObservation: <"A single weighted averaging observation.">

	dateTime zonedDateTime (0..1) <"Observation date time, which should be used when literal observation dates are required. The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">
	observationNumber int (0..1) <"Observation number, which should be unique, within a series generated by a date schedule.">
	weight number (1..1) <"Observation weight, which is used as a multiplier for the observation value.">

	condition Choice: <" Choice rule to represent an FpML choice construct between date times for literal date values, and observation numbers for schedule generated observations.">
		required choice dateTime, observationNumber

	condition PositiveObservationNumber: <" FpML specifies observationNumber as a positive integer.">
		if observationNumber exists
		then observationNumber >= 0

	condition PositiveWeight: <" FpML specifies observationNumber as a non-negative decimal.">
		if weight exists
		then weight >= 0.0

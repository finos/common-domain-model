namespace cdm.observable.asset.calculatedrate : <"Support for calculated floating rates such as lookback compound or observation shift compound rate.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.staticdata.asset.rates.*

import cdm.observable.asset.*

import cdm.product.common.schedule.*
import cdm.product.asset.*
import cdm.product.asset.calculation.*
import cdm.product.asset.floatingrate.*
import cdm.observable.asset.fro.*

// =====================================================================
//
// Calculated rate functions
//
// these functions perform the necessary calculations on calculated rates,
// such as OIS Compound, lookback compound, etc.
// These calculations are described in Sectin 7 of the 2021 ISDA Definitions.
//
// ======================================================================

func EvaluateCalculatedRate: <"Evaluate a calculated rate as described in the 2021 ISDA Definitions, Section .">
	[calculation]
	inputs:
		floatingRateOption FloatingRateOption (1..1) <"The base floating rate inde.">
		calculationParameters FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
		resetDates ResetDates (0..1) <"Reset structure (needed only for fallback rates, otherwise will be empty.">
		calculationPeriod CalculationPeriodBase (1..1) <"Calculation period for which we want to determine the rate.">
		priorCalculationPeriod CalculationPeriodBase (0..1) <"The prior calculation period (needed only for set in advance observation shift rate.">
		dayCount DayCountFractionEnum (1..1) <"The day count fraction in effect on the strea.">
	output:
		results FloatingRateSettingDetails (1..1) <"detailed results of the floating rate calculation.">

	// get the FRO
	alias fro: floatingRateOption

	// work out the observation dates needed and the weight for each
	alias datesAndWeights: GenerateObservationDatesAndWeights(calculationParameters, resetDates, calculationPeriod, priorCalculationPeriod)

	// get the observations
	alias observationDates: datesAndWeights->observationDates
	alias observations: IndexValueObservationMultiple(observationDates, fro)

	// apply observation parameters (caps/floors)
	alias processedObservations: ProcessObservations(calculationParameters, observations)

	// perform the calculation (compounding or averaging)
	alias calculationMethod: calculationParameters->calculationMethod
	alias isCompounding: calculationMethod = CalculationMethodEnum->Compounding
	alias weights: datesAndWeights->weights
	alias yearFraction: YearFractionForOneDay(dayCount) // the year fraction of 1 business day (needed for compounding formula)
	alias calculationResults:
		if isCompounding
		then ApplyCompoundingFormula(processedObservations, weights, yearFraction)
		else ApplyAveragingFormula(observations, weights)

	// record the results
	assign-output results->calculationDetails: calculationResults
	assign-output results->calculationDetails->observations->observationDates: datesAndWeights->observationDates
	assign-output results->calculationDetails->observations->weights: datesAndWeights->weights
	assign-output results->calculationDetails->observations->observedRates: observations
	assign-output results->calculationDetails->observations->processedRates: processedObservations
	assign-output results->floatingRate: calculationResults->calculatedRate


func GenerateObservationDatesAndWeights: <"Apply shifts to generate the list of observation dates and weights for each of those date.">
	[calculation]
	inputs:
		calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
		resetDates ResetDates (0..1) <"Reset structure (needed only for fallback rates, otherwise will be empty.">
		calculationPeriod CalculationPeriodBase (1..1) <"Calculation period for which we want to determine the rate.">
		priorCalculationPeriod CalculationPeriodBase (0..1) <"The prior calculation period (needed only for set in advance observation shift rate.">
	output:
		results CalculatedRateObservationDatesAndWeights (1..1) <"observation dates and corresonding weight.">

	// set up some convenience accessors
	alias obsShift: calculationParams->observationShiftCalculation
	alias lockout: calculationParams->lockoutCalculation
	alias specifiedLockout: if lockout->offsetDays exists then lockout->offsetDays else 5
	alias lockoutDays: if (lockout exists) then specifiedLockout else 0
	alias businessDays: calculationParams->applicableBusinessDays

	// work out the calculation period for which the rate will actually be computed (might be the prior period or based on resetDates)
	alias calculateRelative: if obsShift->calculationBase exists then obsShift->calculationBase else ObservationPeriodDatesEnum->Standard
	alias adjustedCalculationPeriod: ComputeCalculationPeriod(calculationPeriod, priorCalculationPeriod, calculateRelative, resetDates)

	// generate the (shifted) observation period and then the observation dates
	alias observationPeriod: DetermineObservationPeriod(adjustedCalculationPeriod, calculationParams)
	alias observationDates: GenerateObservationDates(observationPeriod, businessDays, lockoutDays)

	// work out the date list for calculating weights, then calculate the weights
	alias weightingDates: DetermineWeightingDates(calculationParams, observationDates, observationPeriod, adjustedCalculationPeriod, lockoutDays)
	alias weights: GenerateWeights(weightingDates)

	// record the results
	assign-output results->observationDates: observationDates
	assign-output results->weights: weights

// possibly record some other intermediate results to aid debugging/understanding?
func ComputeCalculationPeriod: <"Determine the calculation period to use for computing the calculated rate (it may not be the same as the normal calculation period, for instance if the rate is set in advance.">
	[calculation]
	inputs:
		calculationPeriod CalculationPeriodBase (1..1) <"The current calculation period for which the rate is neede.">
		priorCalculationPeriod CalculationPeriodBase (0..1) <"The prior actual or deemed calculation period, if neede.">
		calculateRelativeTo	ObservationPeriodDatesEnum (0..1) <"How the calculation is done with respect to the base calculation perio.">
		resetDates ResetDates (0..1) <"The resetDates structure, if needed, e.g. for fallback rate.">
	output:
		result CalculationPeriodBase (1..1) <"The calculation period over which the calculated rate should be calculate.">

func ComputeCalculationPeriod(calculateRelativeTo: ObservationPeriodDatesEnum -> SetInAdvance):
	assign-output result: priorCalculationPeriod

func ComputeCalculationPeriod(calculateRelativeTo: ObservationPeriodDatesEnum -> Standard):
	assign-output result: calculationPeriod

func ComputeCalculationPeriod(calculateRelativeTo: ObservationPeriodDatesEnum -> FixingDate):
	// TODO : this should use the code in Evaluate Term Rate to do the offset calculation (needs refactoring)
	alias resetRelativeTo: resetDates->resetRelativeTo
	alias isStart: resetRelativeTo = ResetRelativeToEnum->CalculationPeriodStartDate
	alias calcPd: if (isStart) then priorCalculationPeriod else calculationPeriod
	alias fixingOffsetDays: resetDates->fixingDates->periodMultiplier
	alias endDate: AddBusinessDays(calcPd->adjustedEndDate, fixingOffsetDays, resetDates->resetDatesAdjustments->businessCenters)
	alias startDate: AddBusinessDays(calcPd->adjustedStartDate, fixingOffsetDays, resetDates->resetDatesAdjustments->businessCenters)
	assign-output result->adjustedEndDate: endDate
	assign-output result->adjustedStartDate: startDate

func DetermineObservationPeriod: <"Determine any applicable offsets/shifts for the period for observing an index, and then generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shift.">
	[calculation]
	inputs:
		adjustedCalculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being comnputed, after any adjustment.">
		calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
	output:
		observationPeriod CalculationPeriodBase (1..1) <"The resulting observation perio.">

	// convenience alias to categorize the shift types and calculate the business days to use
	alias obsShift: calculationParams->observationShiftCalculation
	alias lookback: calculationParams->lookbackCalculation
	alias businessDays: calculationParams->applicableBusinessDays
	alias additionalBusinessDays: obsShift->additionalBusinessDays
	alias allBusinessDays: CombineBusinessCenters(businessDays, additionalBusinessDays)

	// determine the shift amount
	alias shift: if (obsShift exists) then obsShift->offsetDays else if lookback exists then lookback->offsetDays else 0 // shift amount
		// default to 5 days if not specified (this is the default value from the 2021 Definitions)
	alias shiftDefaulted: if shift exists then shift else 5

		// calculate and return the shifted observation period
	alias obsPeriod: GenerateObservationPeriod(adjustedCalculationPeriod, allBusinessDays, shiftDefaulted)
	assign-output observationPeriod: obsPeriod

func GenerateObservationPeriod: <"Generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts.">
	[calculation]
	inputs:
		calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being comnpute.">
		bc BusinessCenters (1..1) <"The business centers to be used for shiftin.">
		shiftDays int (0..1) <"The amount of any shif.">
	output:
		observationPeriod CalculationPeriodBase (1..1) <"The resulting observation perio.">

	// calculate the starting and ending dates
	alias calcStart: calculationPeriod->adjustedStartDate
	alias calcEnd: calculationPeriod->adjustedEndDate
	alias obsStart: AddBusinessDays(calcStart, -1 * shiftDays, bc)
	alias obsEnd: AddBusinessDays(calcEnd, -1 * shiftDays, bc)

	// record results
	assign-output observationPeriod->adjustedStartDate: obsStart
	assign-output observationPeriod->adjustedEndDate: obsEnd

func GenerateObservationDates: <"Generate the list of observation dates given an observation perio.">
	[calculation]
	inputs:
		observationPeriod CalculationPeriodBase (1..1) <"The given observation perio.">
		bc BusinessCenters (1..1) <"The observation date.">
		lockoutDays int (0..1) <"The number of lockout date.">
	output:
		observationDates date (0..*) <"The resulting list of observation date.">

	// work out the final date of the observations  - we skip observing on the last day of the observation period
	alias days: 1 + (if (lockoutDays exists) then lockoutDays else 0)
	alias endDate: AddBusinessDays(observationPeriod->adjustedEndDate, -1 * days, bc)

	// create the list of observation dates - all business days between the start and end dates
	alias obsDates: GenerateDateList(observationPeriod->adjustedStartDate, endDate, bc)
	// return it
	assign-output observationDates: obsDates

func DetermineWeightingDates: <"Determine the dates to be used for weighting observation.">
	[calculation]
	inputs:
		calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
		observationDates date (0..*)
		observationPeriod CalculationPeriodBase (1..1) <"The resulting observation perio.">
		adjustedCalculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being comnputed, after any adjustment.">
		lockoutDays int (1..1) <"The number of lockout day.">
	output:
		weightingDates date (0..*)

	// set up some convenience aliases
	alias obsShift: calculationParams->observationShiftCalculation
	alias lookback: calculationParams->lookbackCalculation
	alias bc: calculationParams->applicableBusinessDays

	// work out the date list for calculating weights
	alias baseWeightingDates: if obsShift exists then observationDates else GenerateObservationDates(adjustedCalculationPeriod, bc, lockoutDays)
	alias wtPeriod: if (lookback exists) then adjustedCalculationPeriod else observationPeriod
	alias weightingDatesAll: AppendDateToList(baseWeightingDates, wtPeriod->adjustedEndDate) // including final date to compute weight
	assign-output weightingDates: weightingDatesAll

func ProcessObservations: <"Apply daily observation parameters to rate observation.  These are discussed in the 2021 ISDA Definitions, section 7.2.3 and 7.2.4.">
	[calculation]
	inputs:
		calculationParameters FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
		rawObservations number (0..*)
	output:
		processedObservations number (0..*)

	// set up convenience aliases
	alias params: calculationParameters->observationParameters
	alias cap: if params exists then params->observationCapRate
	alias floor: if params exists then params->observationFloorRate

	// apply the daily cap and floor rates using vector math operations
	alias cappedObservations: if cap exists then VectorScalarOperation(ArithmeticOperationEnum->Max, rawObservations, cap) else rawObservations
	alias flooredObservations: if floor exists then VectorScalarOperation(ArithmeticOperationEnum->Min, cappedObservations, floor) else cappedObservations

	// return the resulting values
	assign-output processedObservations: flooredObservations

func GenerateWeights: <"Recursively creates a list of weights based on the date difference between successive days.">
	[calculation]
	inputs:
		weightingDates date (0..*) <"A list of dates for which weightings are require.">
	output:
		weights number (0..*) <"A vector of weights, typically numbers between 1 and 3.">

	alias active: weightingDates count > 1 // do we still have more than one date in the list?
	alias refDate: LastInDateList(weightingDates) // find the last date in the supplied list of dates
	alias remainingDates: PopOffDateList(weightingDates) // determine the prior list of dates, i.e. omitting the last in the list
	alias prevDate: LastInDateList(remainingDates) // find the second to last date in the supplied list of dates
	alias diff: DateDifference(prevDate, refDate) // the weight is the date difference between the supplied ref date and the last one in the list
	alias remainingWeights: GenerateWeights(remainingDates) // recursively generate weights for earlier part of the list
	// if we have >= 1 in the list, add the date difference to the list of weights from the prior part of the list, else return nothing
	assign-output weights: if active then AppendToVector(remainingWeights, diff * 1.0) // else null (empty list)

// -----------------------------------------------
//
// Calculated rate formula processing (compounding or averaging)
//
// -----------------------------------------------

func ApplyCompoundingFormula: <"Implements the compounding formula:   Product of ( 1 + (rate * weight) / basis), then backs out the final rate. This is used to support section 7.3 of the 2021 ISDA Definitions.">
	[calculation]
	inputs:
		observations number (0..*) <"A vector of observation value.">
		weights number (0..*) <"A vector of weights (should be same size as observations, 1 weight per observation.">
		yearFrac number (1..1) <"Year fraction of a single day (i.e. 1/basis.">
	output:
		results CalculatedRateDetails (1..1) <"Details of the compounding calculation.">

	// weight the observations
	alias weightedObservations: VectorOperation(ArithmeticOperationEnum->Multiply, observations, weights)

	// scale the weighted observations based on the basis
	alias scaledAndWeightedObservations: VectorScalarOperation(ArithmeticOperationEnum->Multiply, weightedObservations, yearFrac)

	// compute series of growth factors by adding 1 to the scaled and weighted observations
	alias growthFactors: VectorScalarOperation(ArithmeticOperationEnum->Add, scaledAndWeightedObservations, 1.0)

	// compute a growth curve by successively applying the growth factors
	alias growthCurve: VectorGrowthOperation(1.0, growthFactors)

	// find the final value of the growth curve (the product of all the growth factors times)
	alias finalValue: LastInVector(growthCurve)

	// find the values to scale by to compute the rate
	alias totalWeight: Sum(weights)
	alias overallYearFrac: totalWeight * yearFrac

	// compute the final calculated rate
	alias calculatedRate: (finalValue - 1) / overallYearFrac

	// record results
	assign-output results->aggregateValue: finalValue
	assign-output results->aggregateWeight: totalWeight
	assign-output results->calculatedRate: calculatedRate
	assign-output results->compoundedGrowth: growthCurve
	assign-output results->growthFactor: growthFactors
	assign-output results->weightedRates: weightedObservations

func ApplyAveragingFormula: <"Implements the weighted arithmetic averaging formula.  Sums the weighted rates and divides by the total weight.  This is used to support section 7.4 of the 2021 ISDA Definitions.">
	[calculation]
	inputs:
		observations number (0..*) <"a vector of observation value.">
		weights number (0..*) <"a vector of weights (should be same size as observations, 1 weight per observation.">
	output:
		results CalculatedRateDetails (1..1) <"Details of the averaging calculation.">

	// weight the observations
	alias weightedObservations: VectorOperation(ArithmeticOperationEnum->Multiply, observations, weights)

	// sum the weighted observations
	alias totalWeightedObservations: Sum(weightedObservations)

	// sum the weights
	alias totalWeight: Sum(weights)

	// compute the final calculated rate
	alias calculatedRate: totalWeightedObservations / totalWeight

	// record results
	assign-output results->aggregateValue: totalWeightedObservations
	assign-output results->aggregateWeight: totalWeight
	assign-output results->calculatedRate: calculatedRate
	assign-output results->weightedRates: weightedObservations

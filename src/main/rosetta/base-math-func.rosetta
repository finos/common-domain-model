namespace cdm.base.math : <"Basic maths concepts: quantity and unit, rounding, curve / schedule, non-negativity constraint etc.">
version "${project.version}"

import cdm.observable.asset.*

func Abs:
	inputs: x number (1..1)
	output: result number (1..1)

func Sum:
	inputs: x number (0..*)
	output: sum number (1..1)

func ListsCompare:
	inputs:
		compareOp CompareOp(1..1)
		left number (1..*)
		right number(0..*)
		rightNumber number(0..1)
	output: result boolean (1..1)

func Max:
	inputs:
		a number (1..1)
		b number (1..1)
	output:
		max number (1..1)

	assign-output max:
		if a > b
		then a
		else b

func RoundToNearest:
	inputs:
		value number (1..1)
		nearest number (1..1)
		roundingMode RoundingModeEnum (1..1)

	output:
		roundedValue number (1..1)

	condition:
		nearest > 0

enum RoundingModeEnum:
	Down
	Up

func FilterQuantity: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        currency string (1..1) <"Currency unit type.">
    output:
        quantity Quantity (0..1)

func FilterQuantityByFinancialUnit: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        financialUnit FinancialUnitEnum (1..1) <"FinancialUnitEnum unit type.">
    output:
        quantity Quantity (0..1)

func UpdateAmountForEachQuantity: <"Updates all quantities on each price quantity with the new amount.">
	inputs:
		priceQuantity PriceQuantity (0..*) <"List of price quantities to update.">
		amount number (1..1) <"The new amount.">

	output:
		updatedPriceQuantity PriceQuantity (0..*) <"List of price quantities with all quantity amounts updated.">

func UpdateAmountForEachMatchingQuantity: <"Updates any quantity from the list of new quantities if the unit of amount matches.">
	inputs:
		priceQuantity PriceQuantity (0..*) <"List of price quantities to update.">
		quantity Quantity (0..*) <"The new quantities.">

	output:
		updatedPriceQuantity PriceQuantity (0..*) <"List of price quantities with quantity amounts updated.">

func DeductAmountForEachMatchingQuantity: <"Deducts the amount for any quantity from the list of new quantities if the unit of amount matches.">
	inputs:
		quantity Quantity (0..*) <"List of quantities to update.">
		quantityDeducted Quantity (0..*) <"The quantities to be deducted from the quantity input.">
	output:
		updatedQuantity Quantity (0..*) <"List of  quantities with quantity amounts updated.">

func Create_Quantity: <"Create Quantity with given amount and unit of amount.">
	inputs:
		amount number (1..1)
		unitOfAmount UnitType (1..1)
	output:
		quantity Quantity (1..1)

	assign-output quantity -> amount:
		amount

	assign-output quantity -> unitOfAmount:
		unitOfAmount

func Create_UnitType: <"Create UnitType with given currency or financial unit.">
	inputs:
		currency string (0..1)
			[metadata scheme]
		financialUnit FinancialUnitEnum (0..1)
	output:
		unitType UnitType (1..1)
	
	condition:
		( currency or financialUnit ) exists

	assign-output unitType -> currency:
		currency

	assign-output unitType -> financialUnit:
		financialUnit

namespace cdm.base.math : <"Basic maths concepts: quantity and unit, rounding, curve / schedule, non-negativity constraint etc.">
version "${project.version}"

func Abs:
	inputs: x number (1..1)
	output: result number (1..1)

// Added BALynn 
func SelectFromVector: <"selects a single value from a vector (list of numbers), i.e. result = val[index] ">
	inputs: 
		vector number (0..*)  <"input vector">
		index int(1..1)	<"index to of the value to select">
	output: result number (1..1)	<"resulting value">

func AppendToVector: <"append a single value to a vector list (list of numbers)">
	inputs: 
		vector number (0..*)  <"input vector">
		value number(1..1)	<"value to add to the vector">
	output: resultVector number (0..*)	<"resulting vector">

//func LastInVector: <"return the last value in a vector">
//	[calculation]
//	inputs:
//		vector number (0..*)  <"input vector">
//	output: lastValue number (0..1)	<"resulting value">
//	alias vectorLength : ToInt(vector count)
//	assign-output  lastValue : SelectFromVector(vector, vectorLength)

func Sum:<'generates the scalar sum (total) of all of the supplied values'>
	inputs: x number (0..*)
	output: sum number (1..1)

// Added BALynn
func Product:<'generates the scalar product of all of the supplied values'>
	inputs: x number (0..*)
	output: product number (1..1)

func ListsCompare:
	inputs:
		compareOp CompareOp(1..1)
		left number (1..*)
		right number(0..*)
		rightNumber number(0..1)
	output: result boolean (1..1)

func Max:
	inputs:
		a number (1..1)
		b number (1..1)
	output:
		max number (1..1)

	assign-output max:
		if a > b
		then a
		else b

func RoundToNearest:
	inputs:
		value number (1..1)
		nearest number (1..1)
		roundingMode RoundingModeEnum (1..1)

	output:
		roundedValue number (1..1)

	condition:
		nearest > 0

enum RoundingModeEnum:
	Down
	Up

func FilterQuantity: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        currency string (1..1) <"Currency unit type.">
    output:
        quantity Quantity (0..1)


// Added BALynn to support calculated rates
func ToInt: <"convert number to int">
	inputs: val number(1..1)
output: 
	rounded int(1..1)
func VectorOperation: <"Generates a result vector by applying the supplied arithmetic operation to each element of the supplied left and right vectors in turn.  i.e. result[n] = left[n] <op> right[n], where <op> is the arithmetic operation defined by arithmeticOp.">
	inputs:
		arithmeticOp ArithmeticOp(1..1)  <"operator">
		left number (0..*)			<"left vector">
		right number(0..*)			<"right vector">
	output: result number (0..*)	<"result vector">

func VectorScalarOperation: <"Generates a result vector by applying the supplied arithemetic operation and scalar right value to each element of the supplied left vector in turn. i.e. result[n] = left[n] <op> right, where <op> is the arithmetic operation defined by arithmeticOp.">
	inputs:
		arithmeticOp ArithmeticOp(1..1)  <"operator">
		left number (0..*)				<"left vector">
		right number(1..1)				<"scalar number, single value applied to all elements of vector">
	output: result number (0..*)		<"result vector">

func VectorGrowthOperation: <"Generates a result vector by starting with the supplied base value (typically 1), and then multiplying it in turn by each growth factor, which is typically a number just above 1.  For instance, a growth factor of 1.1 reprsents a 10% increase, and 0.9 a 10% decrease.  The results will show the successive results of applying the successive growth factors (excluding the initial base value), with the first value of the list being the supplied baseValue, and final value of the results list being the product of all of the supplied values.  i.e. result[1] = baseValue * factor[1], result[n] = result[n-1] * factor[n].  The resulting list will have the one more element than the supplied list of factors.">
	inputs:
		baseValue number (1..1)   <"original value, typically 1.0">
		factor number(0..*)		<"vector of growth factions, which are all typically slightly greater than 1.0">
    output: result number (0..*)	<"result vector, showing all of the interim growth values">
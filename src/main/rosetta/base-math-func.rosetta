namespace cdm.base.math : <"Basic maths concepts: quantity and unit, rounding, curve / schedule, non-negativity constraint etc.">
version "${project.version}"

func CompareNumbers:
	inputs:
        n1 number (1..1)
        op CompareOp (1..1)
        n2 number (1..1)
	output:
        result boolean (1..1)

	set result:
        if op = CompareOp -> GreaterThan
        then n1 > n2 = True
        else if op = CompareOp -> GreaterThanOrEquals
        then n1 >= n2 = True
        else if op = CompareOp -> Equals
        then n1 = n2 = True
        else if op = CompareOp -> LessThanOrEquals
        then n1 <= n2 = True
        else if op = CompareOp -> LessThan
        then n1 < n2 = True
        else False

func ArithmeticOperation:
	inputs:
        n1 number (1..1)
        op ArithmeticOperationEnum (1..1)
        n2 number (1..1)
	output:
        result number (1..1)

	set result:
        if op = ArithmeticOperationEnum -> Add then
            n1 + n2
        else if op = ArithmeticOperationEnum -> Subtract then
            n1 - n2
        else if op = ArithmeticOperationEnum -> Multiply then
            n1 * n2
        else if op = ArithmeticOperationEnum -> Divide then
            n1 / n2
        else if op = ArithmeticOperationEnum -> Max then
            Max( n1, n2 )
        else if op = ArithmeticOperationEnum -> Min then
            Min( n1, n2 )

func Abs: <"Returns the absolute value of a number. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned.">
	inputs:
	    arg number (1..1)
	output:
	    result number (1..1)
	set result:
	    if arg < 0 then -1 * arg else arg

func Sum: <"Returns the scalar sum (total) of all of the supplied numbers.">
	inputs:
	    args number (0..*)
	output:
	    result number (1..1)
	set result:
	    if args exists then
	        args
                reduce a, b [ a + b ]
	    else 0.0

func Max: <"Returns the greater number of two supplied numbers.">
	inputs:
		a number (1..1)
		b number (1..1)
	output:
		max number (1..1)
	set max:
		if a > b then a else b

func RoundToNearest:
	inputs:
		value number (1..1)
		nearest number (1..1)
		roundingMode RoundingModeEnum (1..1)
	output:
		roundedValue number (1..1)
	condition:
		nearest > 0

func RoundToPrecision: <"Round a rate to the supplied precision, using the supplied rounding direction">
	inputs:
		value number (1..1) <"The original (unrounded) number.">
		precision int (1..1) <"The number of decimal digits of precision.">
		roundingMode RoundingDirectionEnum (1..1) <"The method of rounding (up/down/nearest).">
	output:
		roundedValue number (1..1) <"The value to the desired precision">
	condition:
		precision >= 0

func CompareQuantityByUnitOfAmount:
    inputs:
        quantity1 Quantity (0..*)
        op CompareOp (1..1)
        quantity2 Quantity (0..*)
        unitOfAmount UnitType (1..1)
    output:
        result boolean (1..1)

    set result:
        FilterQuantity( quantity1, unitOfAmount )
            map q1 [
                FilterQuantity( quantity2, unitOfAmount )
                    map q2 [ CompareNumbers( q1 -> amount, op, q2 -> amount ) ]
            ] flatten
            all = True

func FilterQuantity: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        unitOfAmount UnitType (1..1) <"Currency unit type.">
    output:
        filteredQuantities Quantity (0..*)

    add filteredQuantities:
        quantities
            filter [ item -> unitOfAmount = unitOfAmount ]

func FilterQuantityByCurrency: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        currency string (1..1) <"Currency unit type.">
    output:
        filteredQuantities Quantity (0..*)

    add filteredQuantities:
        quantities
            filter [ item -> unitOfAmount -> currency = currency ]

func FilterQuantityByCurrencyExists: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
    output:
        filteredQuantities Quantity (0..*)

    add filteredQuantities:
        quantities
            filter [ item -> unitOfAmount -> currency exists ]

func FilterQuantityByFinancialUnit: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        financialUnit FinancialUnitEnum (1..1) <"FinancialUnitEnum unit type.">
    output:
        filteredQuantities Quantity (0..*)

    add filteredQuantities:
        quantities
            filter [ item -> unitOfAmount -> financialUnit = financialUnit ]

func Create_Quantity: <"Create Quantity with given amount and unit of amount.">
	inputs:
		amount number (1..1)
		unitOfAmount UnitType (1..1)
	output:
		quantity Quantity (1..1)

	set quantity -> amount: amount
	set quantity -> unitOfAmount: unitOfAmount

func Create_UnitType: <"Create UnitType with given currency or financial unit.">
	inputs:
		currency string (0..1)
			[metadata scheme]
		financialUnit FinancialUnitEnum (0..1)
	output:
		unitType UnitType (1..1)

	condition:
		currency exists or financialUnit exists

	set unitType -> currency: currency
	set unitType -> financialUnit: financialUnit

func SelectFromVector: <"Selects a single value from a vector (list of numbers), i.e. result = val[index].  Returns null if the supplied vector is empty or if the supplied index is out of range.  Returns the element of the vector at the supplied index.">
	inputs:
		vector number (0..*) <"Input vector.">
		index int (1..1) <"List index of the value to select.">
	output:
	    result number (1..1) <"Selected value.">

func LastInVector: <"Return the last value in a vector.">
	inputs:
		vector number (0..*) <"Input vector.">
	output:
	    lastValue number (0..1) <"Last value in the vector.">

func AppendToVector: <"Append a single value to a vector (list of numbers).">
    inputs:
    	vector number (0..*) <"Input vector.">
    	value number (1..1) <"Value to add to the vector.">
    output:
        resultVector number (0..*) <"Resulting vector.">

    add resultVector: vector
    add resultVector: value

func VectorOperation: <"Generates a result vector by applying the supplied arithmetic operation to each element of the supplied left and right vectors in turn.  i.e. result[n] = left[n] <op> right[n], where <op> is the arithmetic operation defined by ArithmeticOperationEnum.">
    inputs:
		arithmeticOp ArithmeticOperationEnum (1..1) <"operator">
		left number (0..*) <"left vector">
		right number (0..*) <"right vector">
	output:
	    result number (0..*) <"result vector">

func VectorScalarOperation: <"Generates a result vector by applying the supplied arithmetic operation and scalar right value to each element of the supplied left vector in turn. i.e. result[n] = left[n] <op> right, where <op> is the arithmetic operation defined by ArithmeticOperationEnum.">
	inputs:
		arithmeticOp ArithmeticOperationEnum (1..1) <"Arithmetic operator to be applied.">
		left number (0..*) <"Left vector.">
		right number (1..1) <"Scalar number - a single value to be applied to all elements of vector.">
	output:
	    result number (0..*) <"Result vector.">

    alias rightOrDefault:
        if right exists then
            right
        else 0.0

	add result:
        left
            map [ ArithmeticOperation( item, arithmeticOp, rightOrDefault ) ]

func VectorGrowthOperation: <"Generates a result vector by starting with the supplied base value (typically 1), and then multiplying it in turn by each growth factor, which is typically a number just above 1. For instance, a growth factor of 1.1 reprsents a 10% increase, and 0.9 a 10% decrease. The results will show the successive results of applying the successive growth factors, with the first value of the list being the supplied baseValue, and final value of the results list being the product of all of the supplied values.  i.e. result[1] = baseValue * factor[1], result[n] = result[n-1] * factor[n]. The resulting list will have the one more element than the supplied list of factors.">
    inputs:
		baseValue number (1..1) <"original value, typically 1.0">
		factor number (0..*) <"vector of growth factions, which are all typically slightly greater than 1.0">
    output:
        result number (0..*) <"result vector, showing all of the interim growth values">

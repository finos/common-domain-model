namespace cdm.observable.common
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*
import cdm.event.common.*

func ResolveTimeZoneFromTimeType: <"Function to resolve a TimeType into a TimeZone based on a determination method.">
	inputs:
		timeType TimeTypeEnum (1..1)
		determinationMethod DeterminationMethodEnum (1..1)

	output:
		time TimeZone (1..1)

func EquityPriceObservation: <"Function specification for the observation of an equity price, based on the attributes of the 'EquityValuation' class.">
	inputs:
		equity Equity (1..1)
		valuationDate AdjustableOrRelativeDate (1..1)
		valuationTime BusinessCenterTime (0..1)
		timeType TimeTypeEnum (0..1)
		determinationMethod DeterminationMethodEnum (1..1)

	output:
		observation Observation (1..1)

	alias observationDate:
		observation -> observationIdentifier -> observationDateTime -> date

	alias observationTime:
		observation -> observationIdentifier -> observationDateTime -> time

	condition: <"Optional choice between directly passing a time or a timeType, which has to be resolved into a time based on the determination method.">
		if valuationTime exists then timeType is absent
		else if timeType exists then valuationTime is absent
			else False

	post-condition: <"The date and time must be properly resolved as attributes on the output.">
		observationDate = ResolveAdjustableDate(valuationDate)
		and if valuationTime exists then
			observationTime = valuationTime -> hourMinuteTime
			else observationTime = ResolveTimeZoneFromTimeType(timeType, determinationMethod) -> time

	post-condition: <"The number recorded in the observation must match the number fetched from the source.">
		observation -> observedValue = EquitySpot(equity, observation -> observationIdentifier -> observationDateTime)

func EquitySpot: <"An external market data lookup for the spot equity price of the reference asset based on a determination method.">
	inputs:
		equity Equity (1..1)
		date zonedDateTime (1..1)

	output: spot number (1..1)

func PriceQuantityTriangulation:
	inputs:
		priceNotation PriceNotation (0..*)
		quantityNotation QuantityNotation (0..*)

	output:
		success boolean (1..1)

	assign-output success:
		if priceNotation -> price -> cashPrice exists
		then CashPriceQuantityNoOfUnitsTriangulation(priceNotation, quantityNotation)
		else if priceNotation -> price -> exchangeRate exists
			then ExchangeRateQuantityTriangulation(priceNotation, quantityNotation)
			else True

func CashPriceQuantityNoOfUnitsTriangulation: <"Data rule to check the relationship between cash price, notional and number of units.">
	inputs:
		priceNotation PriceNotation (0..*)
		quantityNotation QuantityNotation (0..*)

	output:
		success boolean (1..1)

	alias notional:
		CurrencyAmount(quantityNotation, empty)

	alias noOfUnits:
		NoOfUnits(quantityNotation)

	alias cashPrices:
		priceNotation -> price -> cashPrice -> netPrice -> amount

	alias cashPrice:
		cashPrices only-element

	assign-output success:
		if (cashPrice and noOfUnits and notional) exists
		then cashPrice * noOfUnits = notional

func ExchangeRateQuantityTriangulation:
	inputs:
		priceNotation PriceNotation (0..*)
		quantityNotation QuantityNotation (0..*)

	output:
		success boolean (1..1)

	alias exchangeRates:
		priceNotation -> price -> exchangeRate

	alias exchangeRate:
		exchangeRates only-element

	alias rate:
		if exchangeRate -> rate exists
		then exchangeRate -> rate
		else exchangeRate -> spotRate

	alias quotedCurrency:
		exchangeRate -> quotedCurrencyPair

	alias quantity1:
		CurrencyAmount(quantityNotation, quotedCurrency -> currency1)

	alias quantity2:
		CurrencyAmount(quantityNotation, quotedCurrency -> currency2)

	assign-output success:
		if (quantity1 and quantity2 and rate) exists
		then
		if quotedCurrency -> quoteBasis = QuoteBasisEnum -> Currency1PerCurrency2
			then quantity1 / quantity2 = rate
			else if quotedCurrency -> quoteBasis = QuoteBasisEnum -> Currency2PerCurrency1
				then quantity2 / quantity1 = rate

func NoOfUnits: <"Get quantity associated with product identifier.">
	inputs:
		quantityNotations QuantityNotation (0..*)

	output:
		noOfUnits number (1..1)


func CurrencyAmount: <"Get quantity associated with currency.">
	inputs:
		quantityNotations QuantityNotation (0..*)
		currency string (0..1)

	output:
		currencyAmount number (1..1)

// TODO: turn these functions into language level operators i.e. '+'
func Plus:
	inputs:
		q1 QuantityNotation (1..1)
		q2 QuantityNotation (1..1)
	output:
		result QuantityNotation (1..1)

// TODO: turn these functions into language level operators i.e. '='
func Equals:
	// TODO Never referenced in CDM
	inputs:
		quantity QuantityNotation (1..*)
		scalar number (1..1)
	output:
		result boolean (1..1)

// TODO: turn these functions into language level operators i.e. '>'
func GreaterThan:
	inputs:
		quantity QuantityNotation (1..*)
		scalar number (1..1)
	output:
		result boolean (1..1)

// TODO: turn these functions into language level operators i.e. '>='
func GreaterThanEquals:
	// TODO Never referenced in CDM
	inputs:
		quantity QuantityNotation (1..*)
		scalar number (1..1)
	output:
		result boolean (1..1)

func ExtractQuantityByAsset:
	inputs:
		quantities QuantityNotation (1..*)
		asset AssetIdentifier (1..1)
	output:
		quantity QuantityNotation (1..1)

func ExtractQuantityByCurrency:
	inputs:
		quantities QuantityNotation (1..*)
		currency string (1..1)
	output:
		quantity QuantityNotation (1..1)



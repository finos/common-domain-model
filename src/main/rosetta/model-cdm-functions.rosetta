namespace "org.isda.cdm"
version "${project.version}"


func Execute:
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
	
	output: 
		execution Event (1..1)
	
	assign-output execution -> primitive -> execution:
		NewExecutionPrimitive(product, partyA, partyB, quantity)
	
	assign-output execution -> eventEffect -> execution :  
		execution -> primitive -> execution -> after -> execution
	
	post-condition:
		execution -> lineage is absent;


func NewExecutionPrimitive: <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		
	output:
		execution ExecutionPrimitive (1..1)
		
	condition: <"Parties must be different, and match the contractual parties to the legal agreement when the latter exists.">
		partyA <> partyB;
		
	assign-output execution -> after -> execution -> product -> contractualProduct:
		product -> contractualProduct

	// TODO: update to below once rosetta-dsl issue #44 and #45 resolved
	// execution -> after -> execution -> party contains [ partyA, partyB ]
	//	
	// assign-output execution -> after -> execution -> party:
	//	[ partyA, partyB ]
		
	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		execution -> before is absent;
	
	post-condition: <"Ensuring that the execution attributes are correctly populated on the output.">
		if execution -> after -> execution -> party exists then
			execution -> after -> execution -> party count = 2 and
			execution -> after -> execution -> party contains partyA and
			execution -> after -> execution -> party contains partyB;
			

func Contractualisation : <"Function specification to create the fully-formed business event of entering into a new contract, as a combination of an execution primitive and a contract formation primitive, when there is no allocation involved and the contractual parties are the execution parties. This specification is meant to replace the 'Inception' primitive that previously co-mingled these 2 primitives.">
	inputs:
		event Event (1..1)
		legalAgreement LegalAgreement (0..1)
		
	output:
		event Event (1..1)
	
	alias execution :
		event -> primitive -> execution -> after -> execution
	
	condition : <"Input event must be an execution must be on a contractual product.">
		execution exists;
		execution -> product -> contractualProduct exists;
		
	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided."> 
		if legalAgreement exists then legalAgreement -> contractualParty contains execution -> party;
		
	assign-output event -> primitive -> contractFormation : <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		NewContractFormationPrimitive( event -> primitive -> execution -> after only-element, execution -> party , legalAgreement )
	
	assign-output event -> party : <"The parties on the output Event must match the parties on the input Execution.">
		execution -> party
		
	assign-output event -> lineage -> eventReference : <"Construct the lineage making reference to the input event">
		event
		
	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		event -> eventEffect -> contract = event -> primitive -> contractFormation -> after -> contract;
		event -> eventEffect -> effectedExecution = event -> primitive -> contractFormation -> before -> execution;
		event -> eventEffect -> effectedContract is absent;
		event -> eventEffect -> productIdentifier is absent;
		event -> eventEffect -> transfer is absent;
					
					
func NewContractFormationPrimitive : <"Function specification to create a fully-formed contract following execution on a contractual product. The contract can optionally reference a further legal agreement (such as a CSA or a Master Confirmation).">
	inputs:
		executionState ExecutionState (1..1)
		parties Party (1..*)
		legalAgreement LegalAgreement (0..1)
		
	output:
		contractFormation ContractFormation (1..1)
	
	assign-output contractFormation -> before : <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		executionState
		
	assign-output contractFormation -> after -> contract -> contractualProduct :
		executionState -> execution -> product -> contractualProduct  

	assign-output contractFormation -> after -> contract -> documentation -> legalAgreement : <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists then legalAgreement		
		
	assign-output contractFormation -> after -> contract -> party :
		parties


func Reset :
	inputs: 
		previousEvent Event (1..1)
		observationEvent Event (1..1)
			
	output: 
		reset Event (1..1)
	
	alias contractState :
		ExtractContractState( previousEvent )
		
	alias contract :
		contractState -> contract
	
	alias observation:
		observationEvent -> primitive -> observation
		
	condition: 
		contractState exists;
		
	condition: <"The observation primitive must be part of the observation event">
		observation exists;
		
	assign-output reset -> primitive -> reset : 
		NewResetPrimitive( contractState, observation )
		
	assign-output reset -> lineage -> eventReference : 
		previousEvent
	
	assign-output reset -> lineage -> contractReference :
		contract
		
	assign-output reset -> eventEffect -> effectedContract :
		contract
	
	assign-output reset -> eventEffect -> contract :
		contract
		
	post-condition: 
		reset -> eventEffect -> effectedExecution is absent;
		reset -> eventEffect -> execution is absent;
		reset -> eventEffect -> productIdentifier is absent;


func NewResetPrimitive : <"Specifies how a Reset Primitive should be constructed.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
	
	output:
		resetPrimitive ResetPrimitive (1..1)
		
	alias contract :
		contractState -> contract
	
	assign-output resetPrimitive -> before :
		contractState
		
	assign-output resetPrimitive -> after -> contract :
		contractState -> contract
		
	assign-output resetPrimitive -> after -> updatedContract : <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedContract( contractState, observation )


func ResolveUpdatedContract : <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms."> 
	inputs: 
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		
	output: 
		updatedContract Contract (1..1) <"A copy of the original contract, with updated values were applicable.">
		
	alias payout : 
		contractState -> contract -> contractualProduct -> economicTerms -> payout
	
	assign-output updatedContract -> contractualProduct -> economicTerms -> payout: 
		if payout -> equityPayout exists then ResolveEquityContract( contractState, observation )  


func TransferCash: <"Function specification to build a transfer event following a reset on a contract">
	inputs:
		resetEvent Event (1..1)
	output:
		transferEvent Event (1..1)

	alias contract :
		resetEvent -> primitive -> reset -> after -> contract
		
	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> primitive -> reset exists;
		
	assign-output transferEvent -> primitive -> transfer :
		NewCashTransferPrimitive( contract -> contractualProduct -> economicTerms -> payout )

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> primitive -> transfer only exists;

	post-condition: <"Event effect must include the contract generating the cashflow.">
        transferEvent -> eventEffect -> effectedContract = contract;
        transferEvent -> eventEffect -> contract = contract;
        transferEvent -> eventEffect -> effectedExecution is absent;
        transferEvent -> eventEffect -> execution is absent;
        transferEvent -> eventEffect -> productIdentifier is absent;

	post-condition: <"Event lineage must point to the contract that generated the cashflow and the reset event.">
		transferEvent -> lineage -> contractReference = contract;
		transferEvent -> lineage -> eventReference = resetEvent;


func NewCashTransferPrimitive : <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	inputs:
		payout Payout (1..1)
		
	output:
		transfer TransferPrimitive (1..1)
		
	alias cashflow :
		ResolveCashflow( payout )
		
	assign-output transfer -> status :
		TransferStatusEnum.Instructed
		
	assign-output transfer -> cashTransfer -> amount :
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver :
		cashflow -> payerReceiver
		
	assign-output transfer -> settlementDate :
		cashflow -> cashflowDate
				
		
func ResolveCashflow : <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs: 
		payout Payout (1..1)
	
	output: 
		cashflow Cashflow (1..1)
	
	assign-output cashflow -> cashflowAmount :
		if payout -> equityPayout exists then EquityCashSettlementAmount( payout -> equityPayout )
		
	assign-output cashflow -> cashflowDate -> adjustedDate :
		ResolveCashSettlementDate( payout ) 


func ResolveCashSettlementDate : <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: payout Payout (1..1)
	output: date date (1..1)


func Allocate: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		trade Trade (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">
		precision number (1..1) <"Precision for number comparison">

	output:
		event Event (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	post-condition:
		event -> primitive -> allocation = NewAllocationPrimitive( trade, allocationInstructions, precision );


func NewAllocationPrimitive: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		trade Trade (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">
		precision number (1..1) <"Precision for number comparison">

	output:
		primitive AllocationPrimitive (1..1) <"Allocation primitive containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	condition: <"The sum of allocation breakdown quantities must equal the block trade quantity.">
		if trade -> execution exists then 
			QuantityEquals( Sum( allocationInstructions -> breakdowns -> quantity ), trade -> execution -> quantity, precision);


func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1) <"Execution to be settled.">

	output:
		transferEvent Event (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		execution -> product -> security exists;
	
	post-condition:
		if execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum.DeliveryVersusPayment then
			transferEvent -> primitive -> transfer -> cashTransfer exists 
			and transferEvent -> primitive -> transfer -> securityTransfer exists 
			and transferEvent -> primitive -> transfer -> commodityTransfer is absent;

	post-condition:
        transferEvent -> lineage -> executionReference = execution;

	post-condition:
		transferEvent -> primitive -> transfer -> status = TransferStatusEnum.Settled;


func NewTransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1)
	
	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	post-condition:
		if execution -> product -> security exists and execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum.DeliveryVersusPayment then
			transferPrimitive -> cashTransfer exists 
			and transferPrimitive -> securityTransfer exists 
			and transferPrimitive -> commodityTransfer is absent
			and transferPrimitive -> status = TransferStatusEnum.Settled;
			
			
func NewQuantityChangePrimitive : <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	inputs:
		trade Trade (1..1)
		quantityChange ContractualQuantity (1..1)
	
	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)
	
	condition: <"Non-zero quantity change">
		GreaterThan(quantityChange, 0.0);

	assign-output quantityChangePrimitive -> before: <"Correctly populate the before attributes on the Primitive Event">
		trade

	post-condition: <"The resulting quantity must equal the original quantity plus the quantity change.">
		ExtractQuantity( quantityChangePrimitive -> after ) = Plus( ExtractQuantity( trade ), quantityChange );
	 
	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> execution exists then quantityChangePrimitive -> after -> execution exists;
		if quantityChangePrimitive -> before -> contract exists then quantityChangePrimitive -> after -> contract exists;
		

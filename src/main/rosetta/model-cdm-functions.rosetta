namespace "org.isda.cdm"
version "${project.version}"


func Execute:
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
	
	output:
		executionEvent WorkflowEvent (1..1)
	
	assign-output executionEvent -> primitives -> execution:
		NewExecutionPrimitive(product, partyA, partyB, quantity)
	
	assign-output executionEvent -> eventEffect -> execution:
		executionEvent -> primitives -> execution -> after -> execution

	assign-output executionEvent -> party:
		[ partyA, partyB ]

	post-condition:
		executionEvent -> lineage is absent


func NewExecutionPrimitive: <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		
	output:
		execution ExecutionPrimitive (1..1)
		
	condition: <"Parties must be different, and match the contractual parties to the legal agreement when the latter exists.">
		partyA <> partyB
		
	assign-output execution -> after -> execution -> product -> contractualProduct:
		product -> contractualProduct

	assign-output execution -> after -> execution -> party:
		[ partyA, partyB ] // TODO assign partyA and partyB as references when the as-key syntax support lists of values
		
	assign-output execution -> after -> execution -> executionQuantity:	
		quantity
		
	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		execution -> before is absent
			

func FormContract : <"Function specification to create the fully-formed business event of entering into a new contract, as a combination of an execution primitive and a contract formation primitive, when there is no allocation involved and the contractual parties are the execution parties. This specification is meant to replace the 'Inception' primitive that previously co-mingled these 2 primitives.">
	inputs:
		executionEvent WorkflowEvent (1..1)
		legalAgreement LegalAgreement (0..1)
		
	output:
		contractFormationEvent WorkflowEvent (1..1)
	
	alias execution :
		executionEvent -> primitives -> execution -> after -> execution
	
	condition : <"Input event must be an execution must be on a contractual product.">
		execution exists and
		execution -> product -> contractualProduct exists
		
	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided."> 
		if legalAgreement exists then legalAgreement -> contractualParty contains execution -> party
		
	assign-output contractFormationEvent -> primitives -> contractFormation : <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		NewContractFormationPrimitive( executionEvent -> primitives -> execution -> after only-element, execution -> party , legalAgreement )
	
	assign-output contractFormationEvent -> party : <"The parties on the output Event must match the parties on the input Execution.">
		execution -> party
		
	assign-output contractFormationEvent -> lineage -> eventReference: <"Construct the lineage making reference to the input event">
		executionEvent as-key
		
	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		contractFormationEvent -> eventEffect -> contract = contractFormationEvent -> primitives -> contractFormation -> after -> contract
		and contractFormationEvent -> eventEffect -> effectedExecution = contractFormationEvent -> primitives -> contractFormation -> before -> execution
		and contractFormationEvent -> eventEffect -> effectedContract is absent
		and contractFormationEvent -> eventEffect -> productIdentifier is absent
		and contractFormationEvent -> eventEffect -> transfer is absent
					
					
func NewContractFormationPrimitive : <"Function specification to create a fully-formed contract following execution on a contractual product. The contract can optionally reference a further legal agreement (such as a CSA or a Master Confirmation).">
	inputs:
		executionState ExecutionState (1..1)
		parties Party (1..*)
		legalAgreement LegalAgreement (0..1)
		
	output:
		contractFormation ContractFormationPrimitive (1..1)
		
	alias contract :
		contractFormation -> after -> contract
	
	alias execution :
		executionState -> execution
	
	assign-output contractFormation -> before : <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		executionState
		
	assign-output contract -> contractualProduct :
		execution -> product -> contractualProduct
	
	assign-output contract -> contractualQuantity :
		execution -> executionQuantity

	assign-output contract -> documentation -> legalAgreement : <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists then legalAgreement		
		
	assign-output contract -> party :
		parties


func Reset :
	inputs:
		previousEvent WorkflowEvent (1..1)
		observationEvent WorkflowEvent (1..1)
		date date (1..1)
			
	output: 
		reset WorkflowEvent (1..1)
	
	alias contractState : <"Extract the Contract State from the Event.">
		ExtractContractState( previousEvent )
		
	alias contract :
		contractState -> contract
	
	alias observation:
		observationEvent -> primitives -> observation only-element
		
	condition: <"ExtractContractState would result in nothing (empty), check we have something.">
		contractState exists
		
	condition: <"The observation primitive must be part of the observation event">
		observation exists
		
	assign-output reset -> primitives -> reset :
		NewResetPrimitive( contractState, observation, date )
		
	assign-output reset -> lineage -> eventReference : 
		previousEvent as-key
	
	assign-output reset -> lineage -> contractReference :
		contract as-key
		
	assign-output reset -> eventEffect -> effectedContract :
		contract as-key
	
	assign-output reset -> eventEffect -> contract :
		contract as-key
		
	assign-output reset -> timestamp -> dateTime:
		ToDateTime( date )
		
	post-condition: 
		reset -> eventEffect -> effectedExecution is absent
		and reset -> eventEffect -> execution is absent
		and reset -> eventEffect -> productIdentifier is absent


func NewResetPrimitive : <"Specifies how a Reset Primitive should be constructed.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)
	
	output:
		resetPrimitive ResetPrimitive (1..1)
		
	alias contract :
		contractState -> contract
	
	assign-output resetPrimitive -> before :
		contractState
		
	assign-output resetPrimitive -> after -> contract :
		contractState -> contract
		
	assign-output resetPrimitive -> after -> updatedContract : <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedContract( contractState, observation, date )


func ResolveUpdatedContract : <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms."> 
	inputs: 
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)
		
	output: 
		updatedContract Contract (1..1) <"An object that follows the structure of the Contract with only the updated values are set.">
		
	alias payout : 
		contractState -> contract -> contractualProduct -> economicTerms -> payout
	
	assign-output updatedContract :
		if payout -> equityPayout exists then ResolveEquityContract( contractState, observation, date )


func TransferCash: <"Function specification to build a transfer event following a reset on a contract">
	inputs:
		resetEvent WorkflowEvent (1..1)
	output:
		transferEvent WorkflowEvent (1..1)

	alias contractState :
		resetEvent -> primitives -> reset -> after only-element
		
	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> primitives -> reset exists
		
	assign-output transferEvent -> primitives -> transfer :
		NewCashTransferPrimitive( contractState, resetEvent -> eventDate )

	assign-output transferEvent -> lineage -> contractReference : <"Event lineage must point to the contract that generated the cashflow and the reset event.">
		contractState -> contract as-key

	assign-output transferEvent -> lineage -> eventReference : <"Event lineage must point to the contract that generated the cashflow and the .">
		resetEvent as-key

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> primitives -> transfer only exists

	post-condition: <"Event effect must include the contract generating the cashflow.">
        transferEvent -> eventEffect -> effectedContract = contractState -> contract
        and transferEvent -> eventEffect -> contract = contractState -> contract
        and transferEvent -> eventEffect -> effectedExecution is absent
        and transferEvent -> eventEffect -> execution is absent
        and transferEvent -> eventEffect -> productIdentifier is absent


func NewCashTransferPrimitive : <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)
		
	output:
		transfer TransferPrimitive (1..1)
		
	alias cashflow :
		ResolveCashflow( contractState, date )
		
	assign-output transfer -> status :
		TransferStatusEnum.Instructed
		
	assign-output transfer -> cashTransfer -> amount :
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver :
		cashflow -> payerReceiver
		
	assign-output transfer -> settlementDate :
		cashflow -> cashflowDate
				
		
func ResolveCashflow : <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs: 
		contractState ContractState (1..1)
		date date (1..1)
	
	output: 
		cashflow Cashflow (1..1)
	
	assign-output cashflow -> cashflowAmount :
		if contractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout exists 
			then EquityCashSettlementAmount( contractState, date )
		
	assign-output cashflow -> cashflowDate -> adjustedDate :
		ResolveCashSettlementDate( contractState ) 


func ResolveCashSettlementDate : <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: contractState ContractState (1..1)
	output: date date (1..1)


func Allocate: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">
		previousEvent WorkflowEvent (1..1) <"Previous event for lineage purposes.">

	output:
		allocationEvent WorkflowEvent (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	assign-output allocationEvent -> primitives -> allocation:
		NewAllocationPrimitive( execution, allocationInstructions )

    assign-output allocationEvent -> lineage -> eventReference:
        previousEvent as-key

    assign-output allocationEvent -> lineage -> executionReference:
        execution as-key
    


func NewAllocationPrimitive: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">

	output:
		primitive AllocationPrimitive (1..1) <"Allocation primitive containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">


func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	// TODO Never referenced in CDM
	inputs:
		execution Execution (1..1) <"Execution to be settled.">
		previousEvent WorkflowEvent (1..1) <"Previous event for lineage purposes.">

	output:
		transferEvent WorkflowEvent (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		execution -> product -> security exists
	
	assign-output transferEvent -> primitives -> transfer:
		NewTransferPrimitive( execution )

    assign-output transferEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output transferEvent -> lineage -> executionReference: 
		execution as-key

func NewTransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1)
	
	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	assign-output transferPrimitive -> status :
		TransferStatusEnum.Instructed
		
	post-condition:
		if execution -> product -> security exists and execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum.DeliveryVersusPayment 
			then transferPrimitive -> cashTransfer exists 
				and transferPrimitive -> securityTransfer exists 
				and transferPrimitive -> commodityTransfer is absent
			
			
func NewQuantityChangePrimitive : <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	// TODO Never referenced in CDM
	inputs:
		trade Trade (1..1)
		quantityChange ContractualQuantity (1..1)
	
	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)
	
	condition: <"Non-zero quantity change">
		GreaterThan(quantityChange, 0.0)

	assign-output quantityChangePrimitive -> before: <"Correctly populate the before attributes on the Primitive Event">
		trade

	post-condition: <"The resulting quantity must equal the original quantity plus the quantity change.">
		ExtractQuantity( quantityChangePrimitive -> after ) = Plus( ExtractQuantity( trade ), quantityChange )
	 
	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> execution exists then quantityChangePrimitive -> after -> execution exists
		and if quantityChangePrimitive -> before -> contract exists then quantityChangePrimitive -> after -> contract exists

		

func EvaluatePortfolioState: <"Function specification to evaluate a portfolio's aggregation parameters and return a new portfolio state containing aggregated positions.">
	// TODO Never referenced in CDM
	inputs:
		portfolio Portfolio (1..1) <"Portfolio containing the aggregation parameters to be used to calculate the new portfolio state.">
		
	output:
		portfolioState PortfolioState (1..1) <"Portfolio state containing the aggregated positions based on the input aggregation parameters.">
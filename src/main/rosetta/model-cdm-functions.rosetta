namespace "org.isda.cdm"
version "${project.version}"


func Execute:
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
	
	output: 
		execution Event (1..1)
	
	assign-output execution -> primitive -> execution:
		NewExecutionPrimitive(product, partyA, partyB, quantity)
	
	assign-output execution -> eventEffect -> execution :  
		execution -> primitive -> execution -> after -> execution
	
	post-condition:
		execution -> lineage is absent;


func NewExecutionPrimitive: <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		
	output:
		execution ExecutionPrimitive (1..1)
		
	condition: <"Parties must be different, and match the contractual parties to the legal agreement when the latter exists.">
		partyA <> partyB;
		
	assign-output execution -> after -> execution -> product -> contractualProduct:
		product -> contractualProduct

	assign-output execution -> after -> execution -> party:
		[ partyA, partyB ]
		
	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		execution -> before is absent;
			

func FormContract : <"Function specification to create the fully-formed business event of entering into a new contract, as a combination of an execution primitive and a contract formation primitive, when there is no allocation involved and the contractual parties are the execution parties. This specification is meant to replace the 'Inception' primitive that previously co-mingled these 2 primitives.">
	inputs:
		executionEvent Event (1..1)
		legalAgreement LegalAgreement (0..1)
		
	output:
		contractFormationEvent Event (1..1)
	
	alias execution :
		executionEvent -> primitive -> execution -> after -> execution
	
	condition : <"Input event must be an execution must be on a contractual product.">
		execution exists;
		execution -> product -> contractualProduct exists;
		
	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided."> 
		if legalAgreement exists then legalAgreement -> contractualParty contains execution -> party;
		
	assign-output contractFormationEvent -> primitive -> contractFormation : <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		NewContractFormationPrimitive( executionEvent -> primitive -> execution -> after only-element, execution -> party , legalAgreement )
	
	assign-output contractFormationEvent -> party : <"The parties on the output Event must match the parties on the input Execution.">
		execution -> party
		
	assign-output contractFormationEvent -> lineage -> eventReference : <"Construct the lineage making reference to the input event">
		executionEvent
		
	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		contractFormationEvent -> eventEffect -> contract = contractFormationEvent -> primitive -> contractFormation -> after -> contract;
		contractFormationEvent -> eventEffect -> effectedExecution = contractFormationEvent -> primitive -> contractFormation -> before -> execution;
		contractFormationEvent -> eventEffect -> effectedContract is absent;
		contractFormationEvent -> eventEffect -> productIdentifier is absent;
		contractFormationEvent -> eventEffect -> transfer is absent;
					
					
func NewContractFormationPrimitive : <"Function specification to create a fully-formed contract following execution on a contractual product. The contract can optionally reference a further legal agreement (such as a CSA or a Master Confirmation).">
	inputs:
		executionState ExecutionState (1..1)
		parties Party (1..*)
		legalAgreement LegalAgreement (0..1)
		
	output:
		contractFormation ContractFormation (1..1)
	
	assign-output contractFormation -> before : <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		executionState
		
	assign-output contractFormation -> after -> contract -> contractualProduct :
		executionState -> execution -> product -> contractualProduct  

	assign-output contractFormation -> after -> contract -> documentation -> legalAgreement : <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists then legalAgreement		
		
	assign-output contractFormation -> after -> contract -> party :
		parties


func Reset :
	inputs: 
		previousEvent Event (1..1)
		observationEvent Event (1..1)
		date date (1..1)
			
	output: 
		reset Event (1..1)
	
	alias contractState : <"Extract the Contract State from the Event.">
		ExtractContractState( previousEvent )
		
	alias contract :
		contractState -> contract
	
	alias observation:
		observationEvent -> primitive -> observation
		
	condition: <"ExtractContractState would result in nothing (empty), check we have something.">
		contractState exists;
		
	condition: <"The observation primitive must be part of the observation event">
		observation exists;
		
	assign-output reset -> primitive -> reset : 
		NewResetPrimitive( contractState, observation, date )
		
	assign-output reset -> lineage -> eventReference : 
		previousEvent
	
	assign-output reset -> lineage -> contractReference :
		contract
		
	assign-output reset -> eventEffect -> effectedContract :
		contract
	
	assign-output reset -> eventEffect -> contract :
		contract
		
	assign-output reset -> timestamp -> dateTime:
		ToDateTime( date )
		
	post-condition: 
		reset -> eventEffect -> effectedExecution is absent;
		reset -> eventEffect -> execution is absent;
		reset -> eventEffect -> productIdentifier is absent;


func NewResetPrimitive : <"Specifies how a Reset Primitive should be constructed.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)
	
	output:
		resetPrimitive ResetPrimitive (1..1)
		
	alias contract :
		contractState -> contract
	
	assign-output resetPrimitive -> before :
		contractState
		
	assign-output resetPrimitive -> after -> contract :
		contractState -> contract
		
	assign-output resetPrimitive -> after -> updatedContract : <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedContract( contractState, observation, date )


func ResolveUpdatedContract : <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms."> 
	inputs: 
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)
		
	output: 
		updatedContract Contract (1..1) <"An object that follows the structure of the Contract with only the updated values are set.">
		
	alias payout : 
		contractState -> contract -> contractualProduct -> economicTerms -> payout
	
	assign-output updatedContract :
		if payout -> equityPayout exists then ResolveEquityContract( contractState, observation, date )  


func TransferCash: <"Function specification to build a transfer event following a reset on a contract">
	inputs:
		resetEvent Event (1..1)
	output:
		transferEvent Event (1..1)

	alias contractState :
		resetEvent -> primitive -> reset -> after
		
	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> primitive -> reset exists;
		
	assign-output transferEvent -> primitive -> transfer :
		NewCashTransferPrimitive( contractState, resetEvent -> eventDate )

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> primitive -> transfer only exists;

	post-condition: <"Event effect must include the contract generating the cashflow.">
        transferEvent -> eventEffect -> effectedContract = contractState -> contract;
        transferEvent -> eventEffect -> contract = contractState -> contract;
        transferEvent -> eventEffect -> effectedExecution is absent;
        transferEvent -> eventEffect -> execution is absent;
        transferEvent -> eventEffect -> productIdentifier is absent;

	post-condition: <"Event lineage must point to the contract that generated the cashflow and the reset event.">
		transferEvent -> lineage -> contractReference = contractState -> contract;
		transferEvent -> lineage -> eventReference = resetEvent;


func NewCashTransferPrimitive : <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)
		
	output:
		transfer TransferPrimitive (1..1)
		
	alias cashflow :
		ResolveCashflow( contractState, date )
		
	assign-output transfer -> status :
		TransferStatusEnum.Instructed
		
	assign-output transfer -> cashTransfer -> amount :
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver :
		cashflow -> payerReceiver
		
	assign-output transfer -> settlementDate :
		cashflow -> cashflowDate
				
		
func ResolveCashflow : <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs: 
		contractState ContractState (1..1)
		date date (1..1)
	
	output: 
		cashflow Cashflow (1..1)
	
	assign-output cashflow -> cashflowAmount :
		if contractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout exists 
			then EquityCashSettlementAmount( contractState, date )
		
	assign-output cashflow -> cashflowDate -> adjustedDate :
		ResolveCashSettlementDate( contractState ) 


func ResolveCashSettlementDate : <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: contractState ContractState (1..1)
	output: date date (1..1)


func Allocate: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">

	output:
		event Event (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	assign-output event -> primitive -> allocation:
		NewAllocationPrimitive( execution, allocationInstructions )


func NewAllocationPrimitive: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">

	output:
		primitive AllocationPrimitive (1..1) <"Allocation primitive containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">


func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1) <"Execution to be settled.">

	output:
		transferEvent Event (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		execution -> product -> security exists;
	
	post-condition:
		if execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum.DeliveryVersusPayment then
			transferEvent -> primitive -> transfer -> cashTransfer exists 
			and transferEvent -> primitive -> transfer -> securityTransfer exists 
			and transferEvent -> primitive -> transfer -> commodityTransfer is absent;

	post-condition:
        transferEvent -> lineage -> executionReference = execution;

	post-condition:
		transferEvent -> primitive -> transfer -> status = TransferStatusEnum.Settled;


func NewTransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1)
	
	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	post-condition:
		if execution -> product -> security exists and execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum.DeliveryVersusPayment 
			then transferPrimitive -> cashTransfer exists 
				and transferPrimitive -> securityTransfer exists 
				and transferPrimitive -> commodityTransfer is absent
				and transferPrimitive -> status = TransferStatusEnum.Settled;
			
			
func NewQuantityChangePrimitive : <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	inputs:
		trade Trade (1..1)
		quantityChange ContractualQuantity (1..1)
	
	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)
	
	condition: <"Non-zero quantity change">
		GreaterThan(quantityChange, 0.0);

	assign-output quantityChangePrimitive -> before: <"Correctly populate the before attributes on the Primitive Event">
		trade

	post-condition: <"The resulting quantity must equal the original quantity plus the quantity change.">
		ExtractQuantity( quantityChangePrimitive -> after ) = Plus( ExtractQuantity( trade ), quantityChange );
	 
	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> execution exists then quantityChangePrimitive -> after -> execution exists;
		if quantityChangePrimitive -> before -> contract exists then quantityChangePrimitive -> after -> contract exists;
		

func EvaluatePortfolioState: <"Function specification to evaluate a portfolio's aggregation parameters and return a new portfolio state containing aggregated positions.">
	inputs:
		portfolio Portfolio (1..1) <"Portfolio containing the aggregation parameters to be used to calculate the new portfolio state.">
		
	output:
		portfolioState PortfolioState (1..1) <"Portfolio state containing the aggregated positions based on the input aggregation parameters.">
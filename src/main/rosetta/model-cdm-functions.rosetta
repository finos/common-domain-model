namespace org.isda.cdm
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.identifier.*

annotation creation: <"Annotation to describe the intent of a function">
    [prefix Create]
    PrimitiveEvent PrimitiveEvent (0..1) <"A primitive event function should take as an input all of the types required to construct the event and produce a new PrimitiveEvent type.">
    BusinessEvent BusinessEvent (0..1) <"A business event function should take as its inputs the after state of previous business event or in case where the is no before state, all of the inputs required to produce the outcome BusinessEvent.">
	WorkflowStep WorkflowStep (0..1) <"Create a proposed, accepted or rejected WorkflowStep with details about the message, identifiers, event timestamps, parties and accounts involved in the step and allow the action to be set to New, Correct or Cancel.">

func Create_WorkflowStep: <"Function to create a workflow step with a business event and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step. The function should be used when there is already a fully formed business event with the action set to signify that the step is new, or a correction/cancellation of a previous step. The action is constrained so that when a previous workflow step is specified, the valid actions are as follows; New -> New, New -> Correct, New -> Cancel, Correct -> Correct and Correct -> Cancel. When a previous workflow is not specified, the action must be New.">
	[creation WorkflowStep]
	inputs:
		messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header.">
		timestamp EventTimestamp (1..1) <"The dateTime and qualifier associated with this event.">
		eventIdentifier Identifier (1..1) <"The identifier that uniquely identify this lifecycle event.">
		party Party (0..*) <"The specification of the parties involved in the WorkflowStep.">
		account Account (0..*) <"Optional account information that could be associated to the event.">
		previousWorkflowStep WorkflowStep (0..1) <"Optional previous WorkflowStep that provides lineage to WorkflowStep that precedes it. If specified, the previous action is used to constrain the actions allows to the resulting workflow step.">
		action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation. When a previous workflow step is specified, the allowed actions are as follows; New -> New, New -> Correct, New -> Cancel, Correct -> Correct and Correct -> Cancel. When a previous workflow is not specified, the action must be New. Two consecutive workflow steps with action New, is valid when you have multiple steps e.g. new execution -> new contract formation">
		businessEvent BusinessEvent (0..1) <"Life cycle event for the step. The business event must be specified if the action is new or corrected, and must be absent in the case of a cancel where the previous step would provide the lineage to the the business event.">

	output:
		workflowStep WorkflowStep (1..1) <"Workflow step with a business event (in the event of action being new or correct) and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step.">

	condition: <"The previous workflow step must contain a business event. Use Create_AcceptedWorkflowStep when the previous workflow step is a proposal.">
		if (previousWorkflowStep exists)
		then previousWorkflowStep -> businessEvent exists

	condition: <"Valid action transitions are: New -> New, New -> Correct, New -> Cancel, Correct -> New, Correct -> Correct and Correct -> Cancel">
		if (previousWorkflowStep -> action = ActionEnum -> New or previousWorkflowStep -> action = ActionEnum -> Correct)
		then (action = ActionEnum -> New or action = ActionEnum -> Correct or action = ActionEnum -> Cancel)

	condition: <"You cannot create a business event on a cancelled previous step">
		previousWorkflowStep -> action <> ActionEnum -> Cancel
		
	condition: <"Action must be New if there is no previous step">
		if (previousWorkflowStep is absent or previousWorkflowStep -> action is absent)
		then (action = ActionEnum -> New)

	//condition: Handle case where the previous step has already been rejected
	
	assign-output workflowStep -> action: <"Assign the workflowStep action.">
		action

	assign-output workflowStep -> messageInformation: <"Assign the workflowStep action.">
		messageInformation

	assign-output workflowStep -> timestamp: <"Assign the the dateTime and qualifier associated with this event.">
		timestamp

	assign-output workflowStep -> eventIdentifier: <"Assign the identifier that uniquely identify this lifecycle event.">
		eventIdentifier

	assign-output workflowStep -> party: <"Assign the parties involved in the WorkflowStep.">
		party

	assign-output workflowStep -> account: <"Assign the account information that could be associated to the event.">
		account

	assign-output workflowStep -> previousWorkflowStep: <"Assign the key of the previous step to resulting step providing lineage.">
		previousWorkflowStep as-key

	assign-output workflowStep -> businessEvent: <"Assign the business event corresponding to the workflow step.">
		businessEvent


func Create_AcceptedWorkflowStep: <"Represents the acceptance of a proposed instruction that results in a workflow step containing a business event, message details, identifiers, event timestamps, parties and accounts. The previous workflow step input must exist to provide workflow lineage. The instruction from the previous workflow step should be used with a [creation BusinessEvent] function to create the input business event passed into this function e.g. AllocationInstruction from the previous step is used with Create_Allocation to produce the business event which should used as an input to this step.">
	[creation WorkflowStep]
	inputs:
		messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header.">
		timestamp EventTimestamp (1..1) <"The dateTime and qualifier associated with this event.">
		eventIdentifier Identifier (1..1) <"The identifier that uniquely identify this lifecycle event.">
		party Party (0..*) <"The specification of the parties involved in the WorkflowStep.">
		account Account (0..*) <"Optional account information that could be associated to the event.">
		previousWorkflowStep WorkflowStep (1..1) <"Required previous WorkflowStep that provides lineage to WorkflowStep that precedes it.">
		businessEvent BusinessEvent (1..1) <"Life cycle event for the step">

	output:
		acceptedWorkflowStep WorkflowStep (1..1) <"Accepted WorkflowStep populated with the business event and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step.">

	condition: <"The previous step being accepted must be a proposed step containing an instruction.">
		previousWorkflowStep -> proposedInstruction exists

	condition: <"You cannot accept a business event on a cancelled previous step.">
		previousWorkflowStep -> action <> ActionEnum -> Cancel

	condition: <"The previous step cannot be rejected.">
		previousWorkflowStep -> rejected <> True

	assign-output acceptedWorkflowStep -> messageInformation: <"Assign the workflowStep action.">
		messageInformation

	assign-output acceptedWorkflowStep -> timestamp: <"Assign the the dateTime and qualifier associated with this event.">
		timestamp

	assign-output acceptedWorkflowStep -> eventIdentifier: <"Assign the identifier that uniquely identify this lifecycle event.">
		eventIdentifier

	assign-output acceptedWorkflowStep -> party: <"Assign the parties involved in the WorkflowStep.">
		party

	assign-output acceptedWorkflowStep -> account: <"Assign the account information that could be associated to the event.">
		account

	assign-output acceptedWorkflowStep -> previousWorkflowStep: <"Set the reference to the previous WorkflowStep to provide lineage">
		previousWorkflowStep as-key

	assign-output acceptedWorkflowStep -> businessEvent: <"Assign the business event corresponding to the workflow step.">
		businessEvent


func Create_ProposedWorkflowStep: <"Represents the proposal to create a business event that results in a workflow step containing an instruction, message details, identifiers, event timestamps, parties and accounts. The optional previous workflow step input provides workflow lineage to where there has been a correction or cancellation to the proposed step. The action is constrained so that when a previous workflow step is specified, the valid actions are as follows; New -> Correct and Correct -> Cancel. When a previous workflow is not specified, the action must be New.">
	[creation WorkflowStep]
	inputs:
		messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header">
		timestamp EventTimestamp (1..1) <"The dateTime and qualifier associated with this event.">
		eventIdentifier Identifier (1..1) <"The identifier that uniquely identify this lifecycle event.">
		party Party (0..*) <"The specification of the parties involved in the WorkflowStep.">
		account Account (0..*) <"Optional account information that could be associated to the event.">
		previousWorkflowStep WorkflowStep (0..1) <"Optional previous WorkflowStep that provides lineage to WorkflowStep that precedes it.">
		action ActionEnum (1..1) <"Specifies whether the event is new or a correction. The action cannot be a cancellation or new if the previous step is also new.">
		proposedInstruction Instruction (1..1) <"The proposed instruction for the step to initiate a workflow e.g. Clearing Instruction or Allocation Instruction">

	output:
		proposedWorkflowStep WorkflowStep (1..1) <"Proposed WorkflowStep populated with the proposed instruction">

	condition: <"When the previous step is new or corrected and contains an instruction (proposed), the following action can only be correct.">
		if (previousWorkflowStep -> proposedInstruction exists and (previousWorkflowStep -> action = ActionEnum -> New or previousWorkflowStep -> action = ActionEnum -> Correct))
		then action = ActionEnum -> Correct

	condition: <"When the previous step contains a business event, the following action can only be new.">
		if (previousWorkflowStep is absent or previousWorkflowStep -> businessEvent exists)
		then action = ActionEnum -> New

	// condition: Handle case where the previous step has already been rejected

	assign-output proposedWorkflowStep -> messageInformation: <"Assign the workflowStep action.">
		messageInformation

	assign-output proposedWorkflowStep -> timestamp: <"Assign the the dateTime and qualifier associated with this event.">
		timestamp

	assign-output proposedWorkflowStep -> eventIdentifier: <"Assign the identifier that uniquely identify this lifecycle event.">
		eventIdentifier

	assign-output proposedWorkflowStep -> party: <"Assign the parties involved in the WorkflowStep.">
		party

	assign-output proposedWorkflowStep -> account: <"Assign the account information that could be associated to the event.">
		account

	assign-output proposedWorkflowStep -> previousWorkflowStep: <"Set the reference to the previous WorkflowStep to provide lineage">
		previousWorkflowStep as-key

	assign-output proposedWorkflowStep -> proposedInstruction:
		proposedInstruction

func Create_RejectedWorkflowStep: <"Represents the rejection of a proposed instruction that results in a workflow step containing the rejection flag, message details, identifiers, event timestamps, parties and accounts involved in the step. The previous workflow step input must exist to provide workflow lineage. This function will be further developed to provide the reasons for rejection.">
	[creation WorkflowStep]
	inputs:
		messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header">
		timestamp EventTimestamp (1..1) <"The dateTime and qualifier associated with this event.">
		eventIdentifier Identifier (1..1) <"The identifier that uniquely identify this lifecycle event.">
		previousWorkflowStep WorkflowStep (1..1) <"Required previous WorkflowStep that provides lineage to WorkflowStep that precedes it.">

	output:
		rejectedWorkflowStep WorkflowStep (1..1) <"Rejected WorkflowStep with lineage to the proposed step that preceded it.">

	condition: <"The previous proposed step being rejected must exist">
		previousWorkflowStep -> proposedInstruction exists
		
	// condition: Handle case where the previous step has already been rejected

	assign-output rejectedWorkflowStep -> messageInformation: <"Assign the workflowStep action.">
		messageInformation

	assign-output rejectedWorkflowStep -> timestamp: <"Assign the the dateTime and qualifier associated with this event.">
		timestamp

	assign-output rejectedWorkflowStep -> eventIdentifier: <"Assign the identifier that uniquely identify this lifecycle event.">
		eventIdentifier

	assign-output rejectedWorkflowStep -> previousWorkflowStep: <"Set the reference to the previous WorkflowStep to provide lineage">
		previousWorkflowStep as-key

	assign-output rejectedWorkflowStep -> rejected:  <"Set the rejected flag to True">
		True

func Create_Execution: <"Function specification to create an execution business event, representing the instantiation of a transaction between two parties on a financial product for a given price, quantity and settlement terms. The business event is constructed to contain a single execution primitive event, and no other primitive event.">
	[creation BusinessEvent]
	inputs:
		product Product (1..1) <"The financial product to be executed and contract formed.">
		quantityNotation QuantityNotation (1..*) <"Quantities (e.g. currency amount, no. shares) associated with the constituents of the transacted product.">
		priceNotation PriceNotation (1..*) <"Prices (e.g. spread, equity price, FX rate) associated with the constituents of the transacted product.">
		counterparties  Counterparty (2..2)
		parties Party (2..*) <"All parties to that execution, including agents and brokers.">
		partyRoles PartyRole (0..*) <"The role(s) that party(ies) may have in relation to the execution.">
		settlementTerms SettlementTerms (0..*) <"The settlement terms for the execution e.g. initial fee, broker fee, up-front cds payment or option premium settlement">

	output:
		executionEvent BusinessEvent (1..1) <"Qualified execution business event containing a single execution primitive event, and no other primitive event.">

	assign-output executionEvent -> primitives -> execution: <"Create and assign the execution primitive event to the execution business event, using the corresponding primitive event creation function.">
		Create_ExecutionPrimitive(product, quantityNotation, priceNotation, counterparties, parties, partyRoles, settlementTerms)

	assign-output executionEvent -> eventEffect -> execution: <"The execution object, i.e. the after state of the execution primitive event, is the single event effect of the business event.">
		executionEvent -> primitives -> execution -> after -> execution

func Create_ExecutionPrimitive: <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">
	[creation PrimitiveEvent]
	inputs:
		product Product (1..1) <"The financial product to be executed and contract formed.">
		quantityNotation QuantityNotation (1..*) <"Quantities (e.g. currency amount, no. shares) associated with the constituents of the transacted product.">
		priceNotation PriceNotation (1..*) <"Prices (e.g. spread, equity price, FX rate) associated with the constituents of the transacted product.">
		counterparties  Counterparty (2..2)
		parties Party (2..*) <"All parties to that execution, including agents and brokers.">
		partyRoles PartyRole (0..*) <"The role(s) that party(ies) may have in relation to the execution.">
		settlementTerms SettlementTerms (0..*) <"The settlement terms for the execution e.g. initial fee, broker fee, up-front cds payment or option premium settlement">

	output:
		executionPrimitive ExecutionPrimitive (1..1) <"Execution primitive event with absent before state and an after state containing the tradable product, parties, associated party roles and the known settlement terms.">

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> product: <"Assign the product input to the tradable product of the execution object.">
		product

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> priceNotation: <"Assign the prices input to the tradable product of the execution object.">
		priceNotation

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> quantityNotation: <"Assign the quantities input to the tradable product of the execution object.">
		quantityNotation

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> counterparties: <"Assign the counterparties input to the tradable product of the execution object.">
		counterparties

	assign-output executionPrimitive -> after -> execution -> party: <"Assign the parties input to the execution object.">
		parties

	assign-output executionPrimitive -> after -> execution -> partyRole: <"Assign the party roles input to the execution object.">
 		partyRoles

	assign-output executionPrimitive -> after -> execution -> settlementTerms: <"Assign the settlement terms input to the execution object.">
		settlementTerms

	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		executionPrimitive -> before is absent

func Create_ContractFormation: <"Function specification to create the business event, representing the affirmation (or confirmation) of an executed transaction between two parties. The formed contract can reference a legal agreement for instance a master agreement, by using the optional legalAgreement input.">
	[creation BusinessEvent]
	inputs:
		executionEvent BusinessEvent (1..1) <"Qualified execution business event containing a execution primitive.">
		legalAgreement LegalAgreement (0..1) <"Optional legal agreement associated to the contract being formed, for instance a master agreement.">

	output:
		contractFormationEvent BusinessEvent (1..1) <"Qualified contract formation business event.">

	alias execution:
		executionEvent -> primitives -> execution -> after -> execution

	condition : <"Input event must be an execution must be on a contractual product.">
		execution exists and
		execution -> tradableProduct -> product -> contractualProduct exists

	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided.">
		if legalAgreement exists then legalAgreement -> contractualParty contains execution -> party

	assign-output contractFormationEvent -> primitives -> contractFormation: <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		Create_ContractFormationPrimitive(executionEvent -> primitives only-element -> execution -> after -> execution, legalAgreement)

	assign-output contractFormationEvent -> eventEffect -> contract: <"The event effect of the business event points to the contract object, i.e. the after state of the contract formation primitive event.">
		contractFormationEvent -> primitives -> contractFormation -> after -> contract

	assign-output contractFormationEvent -> eventEffect -> effectedExecution: <"The event effect of the business event points to the execution object, i.e. the before state of the contract formation primitive event.">
		contractFormationEvent -> primitives -> contractFormation -> before -> execution

	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		contractFormationEvent -> eventEffect -> effectedContract is absent
		and contractFormationEvent -> eventEffect -> productIdentifier is absent
		and contractFormationEvent -> eventEffect -> transfer is absent

func Create_ContractFormationPrimitive: <"Function specification to create the primitive event that represents an executed trade for a contractual product that has been affirmed (or confirmed) by the two parties. The formed contract can reference a legal agreement for instance a master agreement, by using the optional legalAgreement input.">
	[creation PrimitiveEvent]
	inputs:
		execution Execution (1..1) <"Execution consisting of the economic terms which are agreed between the parties.">
		legalAgreement LegalAgreement (0..1) <"Optional legal agreement associated to the contract being formed, for instance a master agreement.">

	output:
		contractFormation ContractFormationPrimitive (1..1) <"Primitive event containing the execution as its before state and the contract as the after state.">

	alias contract:
		contractFormation -> after -> contract

	assign-output contractFormation -> before -> execution: <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		execution

	assign-output contract -> tradableProduct: <"Assign the tradable product input to the execution object.">
		execution -> tradableProduct

	assign-output contract -> contractIdentifier: <"Assign the contract identifier input to the execution object.">
		execution -> identifier

	assign-output contract -> tradeDate -> date: <"Assign the trade date input to the execution object.">
		execution -> tradeDate

	assign-output contract -> partyRole: <"Assign the party role input to the execution object.">
		execution -> partyRole

	assign-output contract -> party: <"Assign the party input to the execution object.">
		execution -> party

	assign-output contract -> documentation -> legalAgreement: <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists
		then Create_LegalAgreementWithPartyReference(legalAgreement -> agreementTerms, legalAgreement -> agreementDate, legalAgreement -> effectiveDate,
			legalAgreement -> identifier, legalAgreement -> lineage, legalAgreement -> agreementType,
			legalAgreement -> contractualParty, legalAgreement -> otherParty)

func Create_Reset:
	[creation BusinessEvent]
	inputs:
		previousEvent BusinessEvent (1..1)
		observationEvent BusinessEvent (1..1)
		date date (1..1)

	output:
		resetEvent BusinessEvent (1..1)

	alias contractState: <"Extract the Contract State from the Event.">
		ExtractContractState(previousEvent)

	alias contract:
		contractState -> contract

	alias observation:
		observationEvent -> primitives  only-element -> observation

	condition: <"ExtractContractState would result in nothing (empty), check we have something.">
		contractState exists

	condition: <"The observation primitive must be part of the observation event">
		observation exists

	assign-output resetEvent -> primitives -> reset:
		Create_ResetPrimitive(contractState, observation, date)

	assign-output resetEvent -> eventEffect -> effectedContract:
		contract as-key

	assign-output resetEvent -> eventEffect -> contract:
		contract as-key

	post-condition:
		resetEvent -> eventEffect -> effectedExecution is absent
		and resetEvent -> eventEffect -> execution is absent
		and resetEvent -> eventEffect -> productIdentifier is absent

func Create_ResetPrimitive: <"Specifies how a Reset Primitive should be constructed.">
	[creation PrimitiveEvent]
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		resetPrimitive ResetPrimitive (1..1)

	alias contract:
		contractState -> contract

	assign-output resetPrimitive -> before:
		contractState

	assign-output resetPrimitive -> after -> contract:
		contractState -> contract

	assign-output resetPrimitive -> after -> updatedContract: <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedContract(contractState, observation, date)

func ResolveUpdatedContract: <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		updatedContract Contract (1..1) <"An object that follows the structure of the Contract with only the updated values are set.">

	alias payout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout

	assign-output updatedContract:
		if payout -> equityPayout exists then ResolveEquityContract(contractState, observation, date)

func Create_CashTransfer: <"Function specification to build a transfer event following a reset on a contract">
	[creation BusinessEvent]
	inputs:
		resetEvent BusinessEvent (1..1)
	output:
		transferEvent BusinessEvent (1..1)

	alias contractState:
		resetEvent -> primitives -> reset -> after

	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> primitives -> reset exists

	assign-output transferEvent -> primitives -> transfer:
		Create_CashTransferPrimitive(contractState only-element , resetEvent -> eventDate)

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> primitives -> transfer only exists

	post-condition: <"Event effect must include the contract generating the cashflow.">
		transferEvent -> eventEffect -> effectedContract = contractState -> contract
		and transferEvent -> eventEffect -> contract = contractState -> contract
		and transferEvent -> eventEffect -> effectedExecution is absent
		and transferEvent -> eventEffect -> execution is absent
		and transferEvent -> eventEffect -> productIdentifier is absent

func Create_CashTransferPrimitive: <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	[creation PrimitiveEvent]
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		transfer TransferPrimitive (1..1)

	alias cashflow:
		ResolveCashflow(contractState, date)

	assign-output transfer -> status:
		TransferStatusEnum -> Instructed

	assign-output transfer -> cashTransfer -> amount:
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver:
		cashflow -> payerReceiver

	assign-output transfer -> settlementDate:
		cashflow -> cashflowDate

func ResolveCashflow: <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		cashflow Cashflow (1..1)

	assign-output cashflow -> cashflowAmount:
		if contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout exists
		then EquityCashSettlementAmount(contractState, date)

	assign-output cashflow -> cashflowDate -> adjustedDate:
		ResolveCashSettlementDate(contractState)

func ResolveCashSettlementDate: <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: contractState ContractState (1..1)
	output: date date (1..1)

func Create_Allocation: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	[creation BusinessEvent]
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstruction AllocationInstruction (1..1) <"Allocation instructions to be applied.">
	
	output:
		businessEvent BusinessEvent (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	alias splitPrimitive:
		Create_SplitPrimitive( ExecutionAsTrade( execution ), allocationInstruction -> breakdowns -> quantity )

//	assign-output businessEvent -> primitives -> split:
//		splitPrimitive

	/*
	 * TODO: Requires DSL support so implemented in Java:
	 *
	 * Proposed syntax changes:  
	 * Option 1 - loop through split executions to create contract formation primitive for each one:
	 *  - for loop syntax support required to create contract formation primitive for each split execution
	 *  - list append syntax support required to add each contract formation primitive to the list of primitives 
	 *  Option 2 - create function that creates list of contract formation primitives 
	 *  - syntax support for returning lists from functions
	 *  - syntax support for list add all (to add function result to list of primitives)
	 */
//	add-output businessEvent -> primitives -> contractFormation for-each splitPrimitive -> after -> splitTrades -> execution:
//		then Create_ContractFormationPrimitive( it, empty )

	post-condition:  <"Both split and contract formation primitives should be created.">
		businessEvent -> primitives -> split exists and businessEvent -> primitives -> contractFormation exists
			
	post-condition: <"The split outcome must result in execution state of 'Allocated' for an execution.">
		if businessEvent -> primitives -> split -> after -> originalTrade -> execution exists
		then businessEvent -> primitives -> split -> after -> originalTrade -> execution -> closedState -> state = ClosedStateEnum -> Allocated
	
	post-condition: <"The split outcome must result in a contract state of 'Allocated' for a contract.">
		if businessEvent -> primitives -> split -> after -> originalTrade -> contract exists
		then businessEvent -> primitives -> split -> after -> originalTrade -> contract -> closedState -> state = ClosedStateEnum -> Allocated

func Create_SplitPrimitive: <"Function specification to create the Split primitive based by splitting the trade into separate trades with the qualities specified in the split instructions.">
	[creation PrimitiveEvent]
	inputs:
		trade Trade (1..1) <"Block trade to be split.">
		splitInstructions QuantityNotation (1..*) <"Split instructions to be applied.">

	output:
		primitive SplitPrimitive (1..1) <"Split primitive containing both the original block trade (with the status set to Split) and the set of split trades.">

func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	// TODO Never referenced in CDM
	inputs:
		execution Execution (1..1) <"Execution to be settled.">
		previousEvent WorkflowStep (1..1) <"Previous event for lineage purposes.">

	output:
		transferEvent WorkflowStep (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		execution -> tradableProduct -> product -> security exists

	assign-output transferEvent -> businessEvent -> primitives -> transfer:
		Create_TransferPrimitive(execution)

	assign-output transferEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output transferEvent -> lineage -> executionReference:
		execution as-key


func Create_TransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	[creation PrimitiveEvent]
	inputs:
		execution Execution (1..1)

	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	assign-output transferPrimitive -> status:
		TransferStatusEnum -> Instructed

	post-condition:
		if execution -> tradableProduct -> product -> security exists and execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum -> DeliveryVersusPayment
		then transferPrimitive -> cashTransfer exists
			and transferPrimitive -> securityTransfer exists
			and transferPrimitive -> commodityTransfer is absent


func Create_QuantityChangePrimitive: <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	[creation PrimitiveEvent]
	inputs:
		trade Trade (1..1)
		currencyAmount number (0..1)
		noOfUnits number (0..1)
		
	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	condition:
		( currencyAmount or noOfUnits ) exists

	assign-output quantityChangePrimitive -> before:
		trade as-key
	
	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> execution exists then quantityChangePrimitive -> after -> execution exists
			and if quantityChangePrimitive -> before -> contract exists then quantityChangePrimitive -> after -> contract exists


func Create_PriceChangePrimitive:
	[creation PrimitiveEvent]
	inputs:
		trade Trade (1..1)
		cashPrice number (1..1)

	output:
		termsChangePrimitive TermsChangePrimitive (1..1)


func Create_TerminationQuantityChangePrimitive: <"A specification for terminating a contract. A QuantityChangePrimitive is created with the after set with quantity of 0, and the closed state to be Terminated.">
	[creation PrimitiveEvent]
	inputs:
		contract Contract (1..1)

	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	assign-output quantityChangePrimitive -> before -> contract: <"Correctly populate the before attributes on the Primitive Event">
		contract

	assign-output quantityChangePrimitive -> after -> contract: <"Correctly populate the after attributes on the Primitive Event">
		TerminateContract(contract)

func EvaluatePortfolioState: <"Function specification to evaluate a portfolio's aggregation parameters and return a new portfolio state containing aggregated positions.">
	// TODO Never referenced in CDM
	inputs:
		portfolio Portfolio (1..1) <"Portfolio containing the aggregation parameters to be used to calculate the new portfolio state.">

	output:
		portfolioState PortfolioState (1..1) <"Portfolio state containing the aggregated positions based on the input aggregation parameters.">

func TerminateContract: <"Function specification for a contract termination where the 'ClosedStateEnum' is set to Terminated and the quantity amount is set to 0.">
	inputs:
		contract Contract (1..1) <"Formed contract in non-terminated state.">

	output:
		terminatedContract Contract (1..1) <"Contract in terminated state with quantity amount set to 0.">

	assign-output terminatedContract -> contractIdentifier:
		contract -> contractIdentifier
	assign-output terminatedContract -> tradeDate:
		contract -> tradeDate
	assign-output terminatedContract -> clearedDate:
		contract -> clearedDate
	assign-output terminatedContract -> tradableProduct -> product:
		contract -> tradableProduct -> product
	assign-output terminatedContract -> tradableProduct -> priceNotation:
		contract -> tradableProduct -> priceNotation
	assign-output terminatedContract -> collateral:
		contract -> collateral
	assign-output terminatedContract -> documentation:
		contract -> documentation
	assign-output terminatedContract -> governingLaw:
		contract -> governingLaw
	assign-output terminatedContract -> party:
		contract -> party
	assign-output terminatedContract -> account:
		contract -> account
	assign-output terminatedContract -> partyRole:
		contract -> partyRole
	assign-output terminatedContract -> calculationAgent:
		contract -> calculationAgent
	assign-output terminatedContract -> partyContractInformation:
		contract -> partyContractInformation

	assign-output terminatedContract -> closedState -> state: <"Set the closed state on the terminatedContract">
		ClosedStateEnum -> Terminated

	assign-output terminatedContract -> tradableProduct -> quantityNotation -> quantity -> amount: <"Set the quantity amount to 0">
        0.0

func NewExecutionPrimitiveEvent: <"Constructs a primitive event from a fully formed execution primitive.">
	inputs:
		executionPrimitive ExecutionPrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> execution:
		executionPrimitive

func NewContractFormationPrimitiveEvent: <"Constructs a primitive event from a fully formed contract formation primitive.">
	inputs:
		contractFormation ContractFormationPrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> contractFormation:
		contractFormation

func NewQuantityChangePrimitiveEvent: <"Constructs a primitive event from a fully formed quantity change primitive event.">
	inputs:
		quantityChangePrimitive QuantityChangePrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> quantityChange:
	quantityChangePrimitive

type ClearingInstruction: <"All information required to perform the clear life cycle event; the clearing party (CCP), the two parties facing each other on the alpha contract, and optionally the parties acting as clearing members.">
	alphaContract Contract (1..1) <"The contract that will be submitted to the clearing house for clearing. The contract should indicate that it should be cleared by assigning a clearing organisation as a party role.">
	
	clearingParty Party(1..1) <"The Central Counter party (CCP) that the contract will be submitted to for clearing.">
		
	party1 Party(1..1) <"First party facing the CCP if it is clearing for its own account.">
	party2 Party(1..1) <"Second party facing the CCP if it is clearing for its own account.">
	
	clearerParty1 Party(0..1) <"Optional party facing the CCP, acting as clearing member for party1.">
	clearerParty2 Party(0..1) <"Optional party facing the CCP, acting as clearing member for party2.">
	
func Create_ClearedTrade: <"Function supporting direct principal and agency clearing model that takes the clearing instruction as an input and results in the cleared trade BusinessEvent. Direct clearing is when the risk party to the trade is facing the CCP, either through its own account or its clearing member acting as agent. In the direct clearing agency model, the party facing the CCP is acting as clearing member for another party. If the clearing instructions contains clearerParty1 or clearerParty2, then it should be used as the party facing the CCP in the beta or gamma contracts respectively. The resulting beta and gamma trades should have the same tradable product as the alpha referencing the risk parties however, the current state of the model does not allow parties to be aliased efficiently which will be resolved by Trello task https://trello.com/c/q8S3w2Rz.">
	[creation BusinessEvent]
	inputs:
		clearingInstruction ClearingInstruction(1..1) <"Clearing Instruction with all party information required to clear the trade.">

	output:
		clearedEvent BusinessEvent (1..1) <"Business event qualified as a cleared trade consisting of five primitive events; terminated alpha contract, new beta execution, beta contract formation, new gamma execution and gamma contract formation">
	
	alias alphaTerminated: <"Terminated alpha primitive event represented as a quantity change event with the after quantity set to 0. The before state is a reference to the original alpha contract.">
		Create_TerminationQuantityChangePrimitive(clearingInstruction -> alphaContract)
	alias alphaTerminatedPrimitives: NewQuantityChangePrimitiveEvent(alphaTerminated)

	alias clearerRole: <"The clearing party (CCP) role set to ClearingOrganization.">
		Create_PartyRole(clearingInstruction -> clearingParty, PartyRoleEnum -> ClearingOrganization)

	alias betaExecution: <"Execution between the CCP and the beta party.">
		Create_ExecutionPrimitive(clearingInstruction -> alphaContract -> tradableProduct -> product, clearingInstruction -> alphaContract -> tradableProduct -> quantityNotation, clearingInstruction -> alphaContract -> tradableProduct -> priceNotation, empty, [clearingInstruction -> clearingParty, betaParty], [clearerRole], empty)
	alias betaExecutionPrimitives: NewExecutionPrimitiveEvent(betaExecution)

	alias betaParty: <"Beta party is the clearerParty1 when acting as a clearing member or else is party1 when it is clearing for its own account.">
		if clearingInstruction -> clearerParty1 exists 
		then clearingInstruction -> clearerParty1
		else clearingInstruction -> party1

	alias betaContract: <"Contract between the CCP and the beta party.">
		Create_ContractFormationPrimitive(betaExecution -> after -> execution, empty)
	alias betaContractPrimitives: NewContractFormationPrimitiveEvent(betaContract)

	alias gammaParty: <"Gamma party is the clearerParty2 when acting as a clearing member or else is party1 when it is clearing for its own account.">
		if clearingInstruction -> clearerParty2 exists
		then clearingInstruction -> clearerParty2
		else clearingInstruction -> party2

	alias gammaExecution: <"Execution between the CCP and the gamma party">
		Create_ExecutionPrimitive(clearingInstruction -> alphaContract -> tradableProduct -> product, clearingInstruction -> alphaContract -> tradableProduct -> quantityNotation, clearingInstruction -> alphaContract -> tradableProduct -> priceNotation, empty, [clearingInstruction -> clearingParty, gammaParty], [clearerRole], empty)
	alias gammaExecutionPrimitives: NewExecutionPrimitiveEvent(gammaExecution)

	alias gammaContract: <"Contract between the CCP and the gamma party.">
		Create_ContractFormationPrimitive(gammaExecution -> after -> execution, empty)
	alias gammaContractPrimitives: NewContractFormationPrimitiveEvent(gammaContract)

	condition: <"The alpha contract being terminated must include the party1 contained in the clearing instruction.">
		clearingInstruction -> alphaContract -> party includes clearingInstruction -> party1
		
	condition: <"The alpha contract being terminated must include the party2 contained in the clearing instruction.">
		clearingInstruction -> alphaContract -> party includes clearingInstruction -> party2
	
	condition: <"The alpha contract being terminated must include the party role of the clearing member (clearerParty1) if it has been specified.">
		if clearingInstruction -> clearerParty1 exists
		then clearingInstruction -> alphaContract -> partyRole -> partyReference includes clearingInstruction -> clearerParty1
	
	condition: <"The alpha contract being terminated must include the party role of the clearing member (clearerParty2) if it has been specified.">
		if clearingInstruction -> clearerParty2 exists
		then clearingInstruction -> alphaContract -> partyRole -> partyReference includes clearingInstruction -> clearerParty2

	assign-output clearedEvent -> primitives: <"Create the event made up of five primitives; alpha terminated, beta execution, beta contract, gamma execution and gamma contract. Each beta and gamma contracts contain references to the respective executions.">
		[
			alphaTerminatedPrimitives,
			betaExecutionPrimitives,
			betaContractPrimitives,
			gammaExecutionPrimitives,
			gammaContractPrimitives
		]

func ExecutionAsTrade: <"Constructs a 'Trade' type that wraps an execution.">
	inputs:
		execution Execution (0..1)
	
	output:
		trade Trade (1..1)
	
	assign-output trade -> execution:
		execution

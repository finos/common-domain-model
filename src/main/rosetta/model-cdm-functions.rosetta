namespace "org.isda.cdm"
version "${project.version}"


func Execute:
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">

	output:
		executionEvent WorkflowEvent (1..1)

	assign-output executionEvent -> businessEvent -> primitives -> execution:
		NewExecutionPrimitive(product, partyA, partyB, quantity)

	assign-output executionEvent -> eventEffect -> execution:
		executionEvent -> businessEvent -> primitives -> execution -> after -> execution

	assign-output executionEvent -> party:
		[ partyA, partyB ]

	post-condition:
		executionEvent -> lineage is absent


func NewExecutionPrimitive: <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		quantity ExecutionQuantity (1..1) <"The quantity of the financial product being executed.">

	output:
		execution ExecutionPrimitive (1..1)

	condition: <"Parties must be different, and match the contractual parties to the legal agreement when the latter exists.">
		partyA <> partyB

	assign-output execution -> after -> execution -> product -> contractualProduct:
		product -> contractualProduct

	assign-output execution -> after -> execution -> party:
		[ partyA, partyB ] // TODO assign partyA and partyB as references when the as-key syntax support lists of values
	assign-output execution -> after -> execution -> executionQuantity:
		quantity

	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		execution -> before is absent


func FormContract: <"Function specification to create the fully-formed business event of entering into a new contract, as a combination of an execution primitive and a contract formation primitive, when there is no allocation involved and the contractual parties are the execution parties. This specification is meant to replace the 'Inception' primitive that previously co-mingled these 2 primitives.">
	inputs:
		executionEvent WorkflowEvent (1..1)
		legalAgreement LegalAgreement (0..1)

	output:
		contractFormationEvent WorkflowEvent (1..1)

	alias execution:
		executionEvent -> businessEvent -> primitives -> execution -> after -> execution

	condition : <"Input event must be an execution must be on a contractual product.">
		execution exists and
		execution -> product -> contractualProduct exists

	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided.">
		if legalAgreement exists then legalAgreement -> contractualParty contains execution -> party

	assign-output contractFormationEvent -> businessEvent -> primitives -> contractFormation: <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		NewContractFormationPrimitive(executionEvent -> businessEvent -> primitives -> execution -> after only-element, execution -> party, legalAgreement)

	assign-output contractFormationEvent -> party: <"The parties on the output Event must match the parties on the input Execution.">
		execution -> party

	assign-output contractFormationEvent -> lineage -> eventReference: <"Construct the lineage making reference to the input event">
		executionEvent as-key

	assign-output contractFormationEvent -> eventEffect -> contract :
		contractFormationEvent -> businessEvent -> primitives -> contractFormation -> after -> contract

	assign-output contractFormationEvent -> eventEffect -> effectedExecution:
		contractFormationEvent -> businessEvent -> primitives -> contractFormation -> before -> execution
	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		contractFormationEvent -> eventEffect -> effectedContract is absent
		and contractFormationEvent -> eventEffect -> productIdentifier is absent
		and contractFormationEvent -> eventEffect -> transfer is absent


func NewContractFormationPrimitive: <"Function specification to create a fully-formed contract following execution on a contractual product. The contract can optionally reference a further legal agreement (such as a CSA or a Master Confirmation).">
	inputs:
		executionState ExecutionState (1..1)
		parties Party (1..*)
		legalAgreement LegalAgreement (0..1)

	output:
		contractFormation ContractFormationPrimitive (1..1)

	alias contract:
		contractFormation -> after -> contract

	alias execution:
		executionState -> execution

	assign-output contractFormation -> before: <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		executionState

	assign-output contract -> contractualProduct:
		execution -> product -> contractualProduct

	assign-output contract -> contractualQuantity:
		execution -> executionQuantity

	assign-output contract -> documentation -> legalAgreement: <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists then legalAgreement

	assign-output contract -> party:
	parties


func Reset:
	inputs:
		previousEvent WorkflowEvent (1..1)
		observationEvent WorkflowEvent (1..1)
		date date (1..1)

	output:
		reset WorkflowEvent (1..1)

	alias contractState: <"Extract the Contract State from the Event.">
		ExtractContractState(previousEvent)

	alias contract:
		contractState -> contract

	alias observation:
		observationEvent -> businessEvent -> primitives -> observation only-element

	condition: <"ExtractContractState would result in nothing (empty), check we have something.">
		contractState exists

	condition: <"The observation primitive must be part of the observation event">
		observation exists

	assign-output reset -> businessEvent -> primitives -> reset:
		NewResetPrimitive(contractState, observation, date)

	assign-output reset -> lineage -> eventReference:
		previousEvent as-key

	assign-output reset -> lineage -> contractReference:
		contract as-key

	assign-output reset -> eventEffect -> effectedContract:
		contract as-key

	assign-output reset -> eventEffect -> contract:
		contract as-key

	assign-output reset -> timestamp -> dateTime:
		ToDateTime(date)

	post-condition:
		reset -> eventEffect -> effectedExecution is absent
		and reset -> eventEffect -> execution is absent
		and reset -> eventEffect -> productIdentifier is absent


func NewResetPrimitive: <"Specifies how a Reset Primitive should be constructed.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		resetPrimitive ResetPrimitive (1..1)

	alias contract:
		contractState -> contract

	assign-output resetPrimitive -> before:
		contractState

	assign-output resetPrimitive -> after -> contract:
		contractState -> contract

	assign-output resetPrimitive -> after -> updatedContract: <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedContract(contractState, observation, date)


func ResolveUpdatedContract: <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		updatedContract Contract (1..1) <"An object that follows the structure of the Contract with only the updated values are set.">

	alias payout:
		contractState -> contract -> contractualProduct -> economicTerms -> payout

	assign-output updatedContract:
		if payout -> equityPayout exists then ResolveEquityContract(contractState, observation, date)


func TransferCash: <"Function specification to build a transfer event following a reset on a contract">
	inputs:
		resetEvent WorkflowEvent (1..1)
	output:
		transferEvent WorkflowEvent (1..1)

	alias contractState:
		resetEvent -> businessEvent -> primitives -> reset -> after only-element

	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> businessEvent -> primitives -> reset exists

	assign-output transferEvent -> businessEvent -> primitives -> transfer:
		NewCashTransferPrimitive(contractState, resetEvent -> eventDate)

	assign-output transferEvent -> lineage -> contractReference: <"Event lineage must point to the contract that generated the cashflow and the reset event.">
		contractState -> contract as-key

	assign-output transferEvent -> lineage -> eventReference: <"Event lineage must point to the contract that generated the cashflow and the .">
		resetEvent as-key

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> businessEvent -> primitives -> transfer only exists

	post-condition: <"Event effect must include the contract generating the cashflow.">
		transferEvent -> eventEffect -> effectedContract = contractState -> contract
		and transferEvent -> eventEffect -> contract = contractState -> contract
		and transferEvent -> eventEffect -> effectedExecution is absent
		and transferEvent -> eventEffect -> execution is absent
		and transferEvent -> eventEffect -> productIdentifier is absent


func NewCashTransferPrimitive: <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		transfer TransferPrimitive (1..1)

	alias cashflow:
		ResolveCashflow(contractState, date)

	assign-output transfer -> status:
		TransferStatusEnum -> Instructed

	assign-output transfer -> cashTransfer -> amount:
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver:
		cashflow -> payerReceiver

	assign-output transfer -> settlementDate:
		cashflow -> cashflowDate


func ResolveCashflow: <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		cashflow Cashflow (1..1)

	assign-output cashflow -> cashflowAmount:
		if contractState -> contract -> contractualProduct -> economicTerms -> payout -> equityPayout exists
		then EquityCashSettlementAmount(contractState, date)

	assign-output cashflow -> cashflowDate -> adjustedDate:
		ResolveCashSettlementDate(contractState)


func ResolveCashSettlementDate: <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: contractState ContractState (1..1)
	output: date date (1..1)


func Allocate: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">
		previousEvent WorkflowEvent (1..1) <"Previous event for lineage purposes.">

	output:
		allocationEvent WorkflowEvent (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	assign-output allocationEvent -> businessEvent -> primitives -> allocation:
		NewAllocationPrimitive(execution, allocationInstructions)

	assign-output allocationEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output allocationEvent -> lineage -> executionReference:
		execution as-key


func NewAllocationPrimitive: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstructions (1..1) <"Allocation instructions to be applied.">

	output:
		primitive AllocationPrimitive (1..1) <"Allocation primitive containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">


func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	// TODO Never referenced in CDM
	inputs:
		execution Execution (1..1) <"Execution to be settled.">
		previousEvent WorkflowEvent (1..1) <"Previous event for lineage purposes.">

	output:
		transferEvent WorkflowEvent (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		execution -> product -> security exists

	assign-output transferEvent -> businessEvent -> primitives -> transfer:
		NewTransferPrimitive(execution)

	assign-output transferEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output transferEvent -> lineage -> executionReference:
		execution as-key

func NewTransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1)

	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	assign-output transferPrimitive -> status:
		TransferStatusEnum -> Instructed

	post-condition:
		if execution -> product -> security exists and execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum -> DeliveryVersusPayment
		then transferPrimitive -> cashTransfer exists
			and transferPrimitive -> securityTransfer exists
			and transferPrimitive -> commodityTransfer is absent


func NewQuantityChangePrimitive: <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	// TODO Never referenced in CDM
	inputs:
		trade Trade (1..1)
		quantityChange ContractualQuantity (1..1)

	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	condition: <"Non-zero quantity change">
		GreaterThan(quantityChange, 0.0)

	assign-output quantityChangePrimitive -> before: <"Correctly populate the before attributes on the Primitive Event">
		trade

	post-condition: <"The resulting quantity must equal the original quantity plus the quantity change.">
		ExtractQuantity(quantityChangePrimitive -> after) = Plus(ExtractQuantity( trade ), quantityChange)

	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> execution exists then quantityChangePrimitive -> after -> execution exists
			and if quantityChangePrimitive -> before -> contract exists then quantityChangePrimitive -> after -> contract exists


func EvaluatePortfolioState: <"Function specification to evaluate a portfolio's aggregation parameters and return a new portfolio state containing aggregated positions.">
	// TODO Never referenced in CDM
	inputs:
		portfolio Portfolio (1..1) <"Portfolio containing the aggregation parameters to be used to calculate the new portfolio state.">

	output:
		portfolioState PortfolioState (1..1) <"Portfolio state containing the aggregated positions based on the input aggregation parameters.">

func Clear:
	inputs:
		contract Contract (1..1)
		party Party (1..1)
	output:
		workflowEvent WorkflowEvent (1..1)

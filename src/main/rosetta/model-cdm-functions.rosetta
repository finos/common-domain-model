namespace "org.isda.cdm"
version "${project.version}"

func Execute:
	inputs:
		product Product (1..1) <"The financial product, either contractual or fungible, that is the subject of the execution.">
		priceNotation PriceNotation (1..*) <"The price of the financial product being executed.">
		quantityNotation QuantityNotation (1..*) <"The quantity of the financial product being executed.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyRoles PartyRole (0..*) <"The role(s) that party(ies) may have in relation to the execution.">

	output:
		executionEvent WorkflowStep (1..1)

	assign-output executionEvent -> businessEvent -> primitives -> execution:
		NewExecutionPrimitive(product -> contractualProduct, partyA, partyB, priceNotation, quantityNotation, partyRoles)

	assign-output executionEvent -> eventEffect -> execution:
		executionEvent -> businessEvent -> primitives -> execution -> after -> execution

	assign-output executionEvent -> party:
		[partyA, partyB]

	post-condition:
		executionEvent -> lineage is absent

func NewExecutionPrimitive: <"Function specification to compose an execution based on a minimum required set of inputs: product, quantity, parties etc.">
	inputs:
		contractualProduct ContractualProduct (1..1) <"The financial contractual product.">
		partyA Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		partyB Party (1..1) <"The parties to that execution, for now assumed Principal-Principal, i.e. no Agent.">
		priceNotation PriceNotation (1..*) <"The price of the financial product being executed.">
		quantityNotation QuantityNotation (1..*) <"The quantity of the financial product being executed.">
		partyRoles PartyRole (0..*) <"The role(s) that party(ies) may have in relation to the execution.">

	output:
		executionPrimitive ExecutionPrimitive (1..1)

	condition: <"Parties must be different, and match the contractual parties to the legal agreement when the latter exists.">
		partyA <> partyB

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> product -> contractualProduct:
		contractualProduct

	assign-output executionPrimitive -> after -> execution -> party:
		[partyA, partyB] // TODO assign partyA and partyB as references when the as-key syntax support lists of values

	assign-output executionPrimitive -> after -> execution -> partyRole:
 		partyRoles

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> priceNotation:
		priceNotation

	assign-output executionPrimitive -> after -> execution -> tradableProduct -> quantityNotation:
		quantityNotation

	post-condition: <"The execution will be the first event in any post-trade life cycle and therefore does not have a before state. Once pre-trade elements are brought into CDM, the 'before' will be used to refer to the last of the pre-trade event states.">
		executionPrimitive -> before is absent

func FormContract: <"Function specification to create the fully-formed business event of entering into a new contract, as a combination of an execution primitive and a contract formation primitive, when there is no allocation involved and the contractual parties are the execution parties. This specification is meant to replace the 'Inception' primitive that previously co-mingled these 2 primitives.">
	inputs:
		executionEvent WorkflowStep (1..1)
		legalAgreement LegalAgreement (0..1)

	output:
		contractFormationEvent WorkflowStep (1..1)

	alias execution:
		executionEvent -> businessEvent -> primitives -> execution -> after -> execution

	condition : <"Input event must be an execution must be on a contractual product.">
		execution exists and
		execution -> tradableProduct -> product -> contractualProduct exists

	condition : <"Ensures that parties to the Contract are defined in the Legal Agreement, if one is provided.">
		if legalAgreement exists then legalAgreement -> contractualParty contains execution -> party

	assign-output contractFormationEvent -> businessEvent -> primitives -> contractFormation: <"Event must contain a contract formation primitive based on the execution primitive and an optional legal agreement.">
		NewContractFormationPrimitive(executionEvent -> businessEvent -> primitives only-element -> execution -> after, legalAgreement)

	assign-output contractFormationEvent -> party: <"The parties on the output Event must match the parties on the input Execution.">
		execution -> party

	assign-output contractFormationEvent -> lineage -> eventReference: <"Construct the lineage making reference to the input event">
		executionEvent as-key

	assign-output contractFormationEvent -> eventEffect -> contract:
		contractFormationEvent -> businessEvent -> primitives -> contractFormation -> after -> contract

	assign-output contractFormationEvent -> eventEffect -> effectedExecution:
		contractFormationEvent -> businessEvent -> primitives -> contractFormation -> before -> execution
	post-condition : <"Event effect must point to the new execution and contract, and exclude other effects.">
		contractFormationEvent -> eventEffect -> effectedContract is absent
		and contractFormationEvent -> eventEffect -> productIdentifier is absent
		and contractFormationEvent -> eventEffect -> transfer is absent


func NewContractFormationPrimitive: <"Function specification to create a fully-formed contract following execution on a contractual product. The contract can optionally reference a further legal agreement (such as a CSA or a Master Confirmation).">
	inputs:
		executionState ExecutionState (1..1)
		legalAgreement LegalAgreement (0..1)

	output:
		contractFormation ContractFormationPrimitive (1..1)

	alias contract:
		contractFormation -> after -> contract

	alias execution:
		executionState -> execution

	assign-output contractFormation -> before: <"Before state must be the execution, and the contractual product in the after state must be the underlying product of the contract being formed.">
		executionState

	assign-output contract -> tradableProduct:
		execution -> tradableProduct

	assign-output contract -> contractIdentifier:
		execution -> identifier

	assign-output contract -> tradeDate -> date:
		execution -> tradeDate

	assign-output contract -> partyRole:
		execution -> partyRole

	assign-output contract -> party:
		execution -> party

	assign-output contract -> documentation -> legalAgreement: <"When an overlaying legal agreement exists, the contract must reference it.">
		if legalAgreement exists then legalAgreement


func Reset:
	inputs:
		previousEvent WorkflowStep (1..1)
		observationEvent WorkflowStep (1..1)
		date date (1..1)

	output:
		reset WorkflowStep (1..1)

	alias contractState: <"Extract the Contract State from the Event.">
		ExtractContractState(previousEvent)

	alias contract:
		contractState -> contract

	alias observation:
		observationEvent -> businessEvent -> primitives  only-element -> observation

	condition: <"ExtractContractState would result in nothing (empty), check we have something.">
		contractState exists

	condition: <"The observation primitive must be part of the observation event">
		observation exists

	assign-output reset -> businessEvent -> primitives -> reset:
		NewResetPrimitive(contractState, observation, date)

	assign-output reset -> lineage -> eventReference:
		previousEvent as-key

	assign-output reset -> lineage -> contractReference:
		contract as-key

	assign-output reset -> eventEffect -> effectedContract:
		contract as-key

	assign-output reset -> eventEffect -> contract:
		contract as-key

	assign-output reset -> timestamp -> dateTime:
		ToDateTime(date)

	post-condition:
		reset -> eventEffect -> effectedExecution is absent
		and reset -> eventEffect -> execution is absent
		and reset -> eventEffect -> productIdentifier is absent

func NewResetPrimitive: <"Specifies how a Reset Primitive should be constructed.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		resetPrimitive ResetPrimitive (1..1)

	alias contract:
		contractState -> contract

	assign-output resetPrimitive -> before:
		contractState

	assign-output resetPrimitive -> after -> contract:
		contractState -> contract

	assign-output resetPrimitive -> after -> updatedContract: <"To handle the various ways Contracts can change over time, ">
		ResolveUpdatedContract(contractState, observation, date)

func ResolveUpdatedContract: <"The updated contract should be generated differently in different reset scenarios. This function handles how the contract should update according to which payouts are present within the Economic Terms.">
	inputs:
		contractState ContractState (1..1)
		observation ObservationPrimitive (1..1)
		date date (1..1)

	output:
		updatedContract Contract (1..1) <"An object that follows the structure of the Contract with only the updated values are set.">

	alias payout:
		contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout

	assign-output updatedContract:
		if payout -> equityPayout exists then ResolveEquityContract(contractState, observation, date)

func TransferCash: <"Function specification to build a transfer event following a reset on a contract">
	inputs:
		resetEvent WorkflowStep (1..1)
	output:
		transferEvent WorkflowStep (1..1)

	alias contractState:
		resetEvent -> businessEvent -> primitives -> reset -> after

	condition: <"There must be a reset primitive on the event input, and the contract being referenced must be consistent between those events.">
		resetEvent -> businessEvent -> primitives -> reset exists

	assign-output transferEvent -> businessEvent -> primitives -> transfer:
		NewCashTransferPrimitive(contractState only-element , resetEvent -> businessEvent -> eventDate)

	assign-output transferEvent -> lineage -> contractReference: <"Event lineage must point to the contract that generated the cashflow and the reset event.">
		contractState -> contract as-key

	assign-output transferEvent -> lineage -> eventReference: <"Event lineage must point to the contract that generated the cashflow and the .">
		resetEvent as-key

	post-condition: <"Event must contain a transfer primitive populated with the cashflow, and no other primitive.">
		transferEvent -> businessEvent -> primitives -> transfer only exists

	post-condition: <"Event effect must include the contract generating the cashflow.">
		transferEvent -> eventEffect -> effectedContract = contractState -> contract
		and transferEvent -> eventEffect -> contract = contractState -> contract
		and transferEvent -> eventEffect -> effectedExecution is absent
		and transferEvent -> eventEffect -> execution is absent
		and transferEvent -> eventEffect -> productIdentifier is absent

func NewCashTransferPrimitive: <"Function specification to generate a transfer primitive following a reset. The cashflow is being passed as an input, as currently the cashflow is meant to be part of the reset. At a later stage, we should pass the reset value while the cashflow calculation should be executed as part of this spec.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		transfer TransferPrimitive (1..1)

	alias cashflow:
		ResolveCashflow(contractState, date)

	assign-output transfer -> status:
		TransferStatusEnum -> Instructed

	assign-output transfer -> cashTransfer -> amount:
		cashflow -> cashflowAmount

	assign-output transfer -> cashTransfer -> payerReceiver:
		cashflow -> payerReceiver

	assign-output transfer -> settlementDate:
		cashflow -> cashflowDate

func ResolveCashflow: <"A product agnostic function that calculates the amount due to be transfered after a Reset Event.">
	inputs:
		contractState ContractState (1..1)
		date date (1..1)

	output:
		cashflow Cashflow (1..1)

	assign-output cashflow -> cashflowAmount:
		if contractState -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout exists
		then EquityCashSettlementAmount(contractState, date)

	assign-output cashflow -> cashflowDate -> adjustedDate:
		ResolveCashSettlementDate(contractState)

func ResolveCashSettlementDate: <"A product agnostic function that resolves the settlement date of the payout for the period in question">
	inputs: contractState ContractState (1..1)
	output: date date (1..1)

func Allocate: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstruction AllocationInstruction (1..1) <"Allocation instructions to be applied.">
		previousEvent WorkflowStep (1..1) <"Previous event for lineage purposes.">

	output:
		allocationEvent WorkflowStep (1..1) <"Allocation event containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">

	assign-output allocationEvent -> businessEvent -> primitives -> allocation:
		NewAllocationPrimitive(execution, allocationInstruction)

	assign-output allocationEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output allocationEvent -> lineage -> executionReference:
		execution as-key

func NewAllocationPrimitive: <"Function specification to create the fully-formed business event of allocating an execution based on allocation instructions.">
	inputs:
		execution Execution (1..1) <"Block trade to be allocated.">
		allocationInstructions AllocationInstruction (1..1) <"Allocation instructions to be applied.">

	output:
		primitive AllocationPrimitive (1..1) <"Allocation primitive containing both the original block trade (with the status set to Allocated) and the set of allocated trades.">


func Settle: <"Function specification to create the Transfer event based on an execution's settlement terms. Initial implementation only supports securities settled via delivery vs payment.">
	// TODO Never referenced in CDM
	inputs:
		execution Execution (1..1) <"Execution to be settled.">
		previousEvent WorkflowStep (1..1) <"Previous event for lineage purposes.">

	output:
		transferEvent WorkflowStep (1..1) <"Transfer event composed of cash and security components created from a security settled via delivery vs payment.">

	condition:
		execution -> tradableProduct -> product -> security exists

	assign-output transferEvent -> businessEvent -> primitives -> transfer:
		NewTransferPrimitive(execution)

	assign-output transferEvent -> lineage -> eventReference:
		previousEvent as-key

	assign-output transferEvent -> lineage -> executionReference:
		execution as-key


func NewTransferPrimitive: <"Function specification to create the Transfer primitive based on an execution's settlement terms and instructions. Initial implementation only supports creating transfer primitives from securities settled via delivery vs payment.">
	inputs:
		execution Execution (1..1)

	output:
		transferPrimitive TransferPrimitive (1..1) <"Transfer primitive generated from execution.">

	assign-output transferPrimitive -> status:
		TransferStatusEnum -> Instructed

	post-condition:
		if execution -> tradableProduct -> product -> security exists and execution -> settlementTerms -> transferSettlementType = TransferSettlementEnum -> DeliveryVersusPayment
		then transferPrimitive -> cashTransfer exists
			and transferPrimitive -> securityTransfer exists
			and transferPrimitive -> commodityTransfer is absent


func NewQuantityChangePrimitive: <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
	// TODO Never referenced in CDM
	inputs:
		trade Trade (1..1)
		quantityChange QuantityNotation (1..*)

	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	condition: <"Non-zero quantity change">
		GreaterThan(quantityChange, 0.0)

	assign-output quantityChangePrimitive -> before: <"Correctly populate the before attributes on the Primitive Event">
		trade

	post-condition: <"The resulting quantity must equal the original quantity plus the quantity change.">
		// TODO: add support for funcs to return multiple cardinality
		ExtractQuantity(quantityChangePrimitive -> after) = Plus(ExtractQuantity( trade ), quantityChange only-element)

	post-condition: <"The input and output types need to be consistent, if we started with an Execution, we should end with an Execution, likewise with Contract.">
		if quantityChangePrimitive -> before -> execution exists then quantityChangePrimitive -> after -> execution exists
			and if quantityChangePrimitive -> before -> contract exists then quantityChangePrimitive -> after -> contract exists


func NewTerminatedContractPrimitive: <"A specification for terminating a contract. A QuantityChangePrimitive is created with the after set with quantity of 0, and the closed state to be Terminated.">
	inputs:
		contract Contract (1..1)

	output:
		quantityChangePrimitive QuantityChangePrimitive (1..1)

	assign-output quantityChangePrimitive -> before -> contract: <"Correctly populate the before attributes on the Primitive Event">
		contract

	assign-output quantityChangePrimitive -> after -> contract: <"Correctly populate the after attributes on the Primitive Event">
		TerminateContract(contract)


func EvaluatePortfolioState: <"Function specification to evaluate a portfolio's aggregation parameters and return a new portfolio state containing aggregated positions.">
	// TODO Never referenced in CDM
	inputs:
		portfolio Portfolio (1..1) <"Portfolio containing the aggregation parameters to be used to calculate the new portfolio state.">

	output:
		portfolioState PortfolioState (1..1) <"Portfolio state containing the aggregated positions based on the input aggregation parameters.">


func TerminateContract:
	inputs:
		contract Contract (1..1)

	output:
		terminatedContract Contract (1..1)

	assign-output terminatedContract -> contractIdentifier:
		contract -> contractIdentifier
	assign-output terminatedContract -> tradeDate:
		contract -> tradeDate
	assign-output terminatedContract -> clearedDate:
		contract -> clearedDate
	assign-output terminatedContract -> tradableProduct -> product:
		contract -> tradableProduct -> product
	assign-output terminatedContract -> tradableProduct -> priceNotation:
		contract -> tradableProduct -> priceNotation
	assign-output terminatedContract -> collateral:
		contract -> collateral
	assign-output terminatedContract -> documentation:
		contract -> documentation
	assign-output terminatedContract -> governingLaw:
		contract -> governingLaw
	assign-output terminatedContract -> party:
		contract -> party
	assign-output terminatedContract -> account:
		contract -> account
	assign-output terminatedContract -> partyRole:
		contract -> partyRole
	assign-output terminatedContract -> calculationAgent:
		contract -> calculationAgent
	assign-output terminatedContract -> partyContractInformation:
		contract -> partyContractInformation

	assign-output terminatedContract -> closedState -> state: <"Set the closed state on the terminatedContract">
		ClosedStateEnum -> Terminated

	assign-output terminatedContract -> tradableProduct -> quantityNotation -> quantity -> amount: <"Set the quantity amount to 0">
        0.0

func PartyRoleForParty:
 	inputs:
 		party Party (1..1)
 		role PartyRoleEnum (1..1)

  	output:
 		partyRole PartyRole (1..1)

  	assign-output partyRole -> partyReference:
 		party

  	assign-output partyRole -> role:
 		role

func NewExecutionPrimitiveEvent:
	inputs:
		executionPrimitive ExecutionPrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> execution:
		executionPrimitive

func NewContractFormationPrimitiveEvent:
	inputs:
		contractFormation ContractFormationPrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> contractFormation:
	contractFormation

func NewQuantityChangePrimitiveEvent:
	inputs:
		quantityChangePrimitive QuantityChangePrimitive (0..1)
	output:
		primitiveEvent PrimitiveEvent (0..1)

	assign-output primitiveEvent -> quantityChange:
	quantityChangePrimitive

func PartyByRole: <"Given a collection of party role containers and a party role, return the party for that role if found in the collection">
	inputs:
		roles PartyRole(1..*)
		role PartyRoleEnum(1..1)
	output:
		party Party (1..1)

type ClearingInstruction: <"All information required to perform the clear life cycle event">
	clearingParty Party(1..1)
	alphaContract Contract (1..1)
		[metadata reference]

func Clear: <"Clear function that inputs the alpha contract and clearingInstruction, resulting in the cleared BusinessEvent">
	inputs:
		clearingInstruction ClearingInstruction(1..1) <"Clearing Instruction with all information to clear the trade including the alpha contract and the clearing party.">

	output:
		clearedEvent BusinessEvent (1..1) <"Business event qualified as a cleared trade">

	alias alpha:
		clearingInstruction -> alphaContract

	alias party1: <"Executing entity">
		PartyByRole(alpha -> partyRole, PartyRoleEnum -> ExecutingEntity)
		
	alias party2: <"Counter party">
		PartyByRole(alpha -> partyRole, PartyRoleEnum -> Counterparty)

	alias alphaTerminated: <"Terminated alpha quantity change event">
		NewTerminatedContractPrimitive(alpha)
	alias alphaTerminatedPrimitives: NewQuantityChangePrimitiveEvent(alphaTerminated)

	alias clearerRole: <"ClearingOrganization role">
		PartyRoleForParty(clearingInstruction -> clearingParty, PartyRoleEnum -> ClearingOrganization)

	alias betaExecution: <"Beta execution">
		NewExecutionPrimitive(alpha -> tradableProduct -> product -> contractualProduct, clearingInstruction -> clearingParty, party1, alpha -> tradableProduct -> priceNotation, alpha -> tradableProduct -> quantityNotation, [clearerRole])
	alias betaExecutionPrimitives: NewExecutionPrimitiveEvent(betaExecution)

	alias betaContract: <"Beta contract">
		NewContractFormationPrimitive(betaExecution -> after, empty)
	alias betaContractPrimitives: NewContractFormationPrimitiveEvent(betaContract)

	alias gammaExecution: <"Gamma execution">
		NewExecutionPrimitive(alpha -> tradableProduct -> product -> contractualProduct, clearingInstruction -> clearingParty, party2, alpha -> tradableProduct -> priceNotation, alpha -> tradableProduct -> quantityNotation, [clearerRole])
	alias gammaExecutionPrimitives: NewExecutionPrimitiveEvent(gammaExecution)

	alias gammaContract: <"Gamma contract">
		NewContractFormationPrimitive(gammaExecution -> after, empty)
	alias gammaContractPrimitives: NewContractFormationPrimitiveEvent(gammaContract)

	assign-output clearedEvent -> primitives:
		[
			alphaTerminatedPrimitives,
			betaExecutionPrimitives,
			betaContractPrimitives,
			gammaExecutionPrimitives,
			gammaContractPrimitives
		]


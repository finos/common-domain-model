namespace cdm.product.asset.calculation : <"Product-related, asset class-specific calculation concepts, such as day counting and calculating accruals.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.rates.*

import cdm.observable.asset.*

import cdm.product.template.*
import cdm.product.common.schedule.*
import cdm.product.asset.floatingrate.*
import cdm.product.asset.*

import cdm.legalagreement.common.*

// =====================================================================
//
// Fixed Amount Calculation definitions
//
// these functions return the calculated fixed amount
//
// ======================================================================

func FixedAmountEnhanced: <"Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		calculationPeriodStartDate date (1..1)
	output:
		fixedAmount number (1..1)

	alias calcPeriod: CalculationPeriod(interestRatePayout -> calculationPeriodDates, calculationPeriodStartDate)
	alias calculationPeriod: InitCalculationPeriodBase(calcPeriod)
	assign-output fixedAmount: FixedAmountCalculationNew(interestRatePayout, calculationPeriod)

// TODO: should this be enhanced to support spreads and do spread-exclusive calculations for compounding?
func FixedAmountCalculationNew: <"Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		calculationPeriod CalculationPeriodBase (1..1)
	output:
		fixedAmount number (1..1)

	alias fixedRate: LookupFixedRate(interestRatePayout, calculationPeriod)
	alias calculationAmount: LookupNotionalAmount(interestRatePayout, calculationPeriod)
	alias dcf: interestRatePayout->dayCountFraction
	alias yearFraction: CalculateYearFraction(interestRatePayout, dcf, calculationPeriod)

	assign-output fixedAmount:
		calculationAmount->multiplier * fixedRate * yearFraction

func LookupFixedRate: <"Look up the fixed rate for a calculation period.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
		calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the spread.">
	output:
		fixedRate number (0..1)  <"the fixed rate value value for the period.">
	alias startDate: calculationPeriod->adjustedStartDate
	assign-output
		fixedRate: LookupRateScheduleAmount(interestRatePayout->rateSpecification -> fixedRate->rateSchedule, startDate)

// =====================================================================
//
// Floating Rate Amount Calculation definitions
//
// these functions perform the floating amount calculations
//
// ======================================================================

func FloatingAmountEnhanced: <"2006 ISDA Definition Article 6 Section 6.1. Calculation of a Floating Amount: Subject to the provisions of Section 6.4 (Negative Interest Rates), the Floating Amount payable by a party on a Payment Date will be: (a) if Compounding is not specified for the Swap Transaction or that party, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Floating Amount = Calculation Amount  Floating Rate + Spread  Floating Rate Day Count Fraction (b) if 'Compounding' is specified to be applicable to the Swap Transaction or that party and 'Flat Compounding' is not specified, an amount equal to the sum of the Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period; or (c) if 'Flat Compounding' is specified to be applicable to the Swap Transaction or that party, an amount equal to the sum of the Basic Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period plus the sum of the Additional Compounding Period Amounts for each such Compounding Period.   This enhanced version supports parameterized rate treatments, such as spread schedules, cap rate schedules, negative rate treatment, final rate rounding, etc.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		calculationPeriodStartDate date (1..1)  <"The final date of the calculation period.">
	output:
		floatingAmount number (1..1)
	// determine the calculation period corresponding to the supplied end date
	alias calcPeriod: CalculationPeriod(interestRatePayout -> calculationPeriodDates, calculationPeriodStartDate)
	// perform the floating amount calculation
	alias results: FloatingAmountCalculation(interestRatePayout, InitCalculationPeriodBase(calcPeriod), calcPeriod->isFirstPeriod)
	// record the results
	assign-output floatingAmount: results -> calculatedAmount

func FloatingAmountCalculation: <"Calculate a floating amount for a calculation period by determining the raw floating rate, applying any rate treatments, looking up the calculation period notional, then performing the multiplication of the notional, rate, and year fraction.  Floating amount calculations are described in the 2021 ISDA Definitions in Section 6 and 7.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"The interest rate stream for which the floating amount calculation is being done.">
		calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the floating rate calculation is being done.">
		isInitialPeriod boolean (1..1) <"Is this the initial calculation period?.">
	output:
		result FloatingAmountCalculationDetails (1..1) <"The details of the floating rate calculation, including raw rate, rate treatment details, notional, and calculated cashlow amount.">

	// Get the floating rate before treatments
	alias rawFloatingRateDetails: DetermineFloatingRateReset(interestRatePayout, calculationPeriod)
	alias rawFloatingRate: rawFloatingRateDetails->floatingRate

	// apply rate treatments/processing
	alias processingParameters: GetFloatingRateProcessingParameters(interestRatePayout, calculationPeriod)
	// TOOD: implement initial rate
	alias processingDetails: ApplyFloatingRateProcessing(processingParameters, rawFloatingRate, calculationPeriod, isInitialPeriod)
	alias appliedRate: processingDetails-> processedRate
	alias spreadExclusiveRate: processingDetails->spreadExclusiveRate

	// determine notional, year fraction, and perform the final calculation
	alias notional: LookupNotionalAmount(interestRatePayout, calculationPeriod)
	alias dcf: interestRatePayout->dayCountFraction
	alias yearFraction: CalculateYearFraction(interestRatePayout, dcf, calculationPeriod)
	alias annualAccrual: notional->multiplier * appliedRate
	alias notionalAccrual: notional->multiplier * yearFraction
	alias cashflow: notionalAccrual * appliedRate
	alias spreadExclusiveCashflow: notionalAccrual * spreadExclusiveRate

	// record results
	assign-output result->calculationPeriod: calculationPeriod
	assign-output result->calculationPeriodNotionalAmount: notional
	assign-output result->floatingRate: rawFloatingRateDetails
	assign-output result->processingDetails: processingDetails
	assign-output result->appliedRate: appliedRate
	// assign-output result->notionalAmount : notional->amount
	assign-output result->yearFraction: yearFraction
	assign-output result->calculatedAmount: cashflow
	assign-output result->spreadExclusiveCalculatedAMount: spreadExclusiveCashflow

//-------------------------------------------------------
// The following functions look up current notional
//-------------------------------------------------------

func LookupNotionalAmount: <"Look up the notional amount in effect for a calculation period.">
	[calculation]
	inputs:
		interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
		calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the notional.">
	output:
		notional Money (1..1) <"The notional that is in effect starting from the adjusterPeriodStartDate.">
	// look up and return the notional from the notional schedule
	assign-output notional->multiplier: 
		LookupQuantityScheduleAmount(interestRatePayout->payoutQuantity->quantitySchedule, calculationPeriod->adjustedStartDate)
	assign-output notional->multiplierUnit->currency: 
		interestRatePayout->payoutQuantity->quantitySchedule->initialQuantity->multiplierUnit->currency

func LookupQuantityScheduleAmount: <"Look up a value from a quantity schedule given a supplied starting date.  It will return the value of the last step that is before the supplied starting date, or if none matches, the initial value.">
	[calculation]
	inputs:
		schedule NonNegativeQuantitySchedule (0..1) <"The quantity schedule being looked up from.">
		periodStartDate date (1..1) <"The date for which the quantity is required.">
	output:
		value number (1..1)	<"The quantity in effect on the supplied date.">
	alias stepValues: FindNonNegativeScheduleSteps(schedule->stepSchedule, periodStartDate, 0)
	alias vals: AppendToVector(stepValues, schedule->initialQuantity->multiplier)
	assign-output
		value: SelectFromVector(vals, 0)

func FindNonNegativeScheduleSteps: <"Find all  schedule step values whose stepDate is before or equal to the supplied periodStartDate, starting from supplied startingStep number.  Returns a list of step values starting from the last matching one and going in reverse order.  Done this slightly odd way for efficiency and simplicity in code generation.">
	[calculation]
	inputs:
		schedule NonNegativeStepSchedule (1..1) <"The quantity schedule being looked up from.">
		periodStartDate date (1..1)	<"The date for which the quantity is required.">
		startingStep int (1..1) <"The first step to start looking at.">
	output:
		vector Vector (1..1)
	alias currentStep: SelectNonNegativeScheduleStep(schedule, startingStep)
	alias remainingValues: FindNonNegativeScheduleSteps(schedule, periodStartDate, startingStep + 1)
	alias append: AppendToVector (remainingValues, currentStep->stepValue)
	alias checkAppend: if (periodStartDate >= stepDate) then append
	alias stepDate: currentStep->stepDate
	assign-output vector:
		if (startingStep < schedule->step count) then checkAppend

func SelectNonNegativeScheduleStep: <"Retrieve a single step from a  schedule given a step number.  This is an entry point to a function written in a native language like Java.  Returns the step if it exists, else null. The index is 0-based, so 0 returns the first step.">
	inputs:
		schedule NonNegativeStepSchedule (1..1) <"The quantity schedule being looked up from.">
		stepNo int (1..1) <"The  step to return.">
	output:
		step NonNegativeStep (0..1)	<"The returned step, or null if it does not exist.">

// -----------------------------------------------
//
// Day count and year fraction calculation
//
// -----------------------------------------------

func CalculateYearFraction:
	inputs:
		interestRatePayout InterestRatePayout (1..1)
		dcf DayCountFractionEnum (1..1)
		calculationPeriod CalculationPeriodBase (1..1)
	output:
		yearFrac number (1..1)

	alias start: calculationPeriod->adjustedStartDate
	alias end: calculationPeriod->adjustedEndDate
	alias termination: interestRatePayout->calculationPeriodDates->terminationDate->adjustableDate->unadjustedDate
	alias periodsInYear: <"Number of calculation periods in a year.">
		PeriodsInYear(interestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency)

	assign-output yearFrac:
		YearFraction(dcf, start, end, termination, periodsInYear)

func YearFraction:
	[calculation]
	inputs:
		dayCountFractionEnum DayCountFractionEnum (1..1)
		startDate date (1..1)
		endDate 	date (1..1)
		terminationDate date (0..1)
		periodsInYear int (0..1)
	output:
		result number (1..1)

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _1_1): <"2006 ISDA Definition Article 4 section 4.16(a):	if '1/1' is specified, 1;.">
	[calculation]
	assign-output result: 1.0

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_ACT_ISDA): <"'2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias daysInPeriod: DateDifference(startDate, endDate)
	alias daysInLeapYearPeriod: <"The number of days of the period that fall in a leap year.">
		LeapYearDateDifference(startDate, endDate)
	alias daysInNonLeapPeriod: <"The difference between the total days in the period and the days in leap year period.">
		daysInPeriod - daysInLeapYearPeriod
	assign-output result:
		(daysInNonLeapPeriod / 365) + (daysInLeapYearPeriod / 366)

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_ACT_ICMA): <"2006 ISDA Definition Article 4 section 4.16(c):	(c)	if 'Actual/Actual (ICMA)' or 'Act/Act (ICMA)' is specified, a fraction equal to 'number of days accrued/number of days in year', as such terms are used in Rule 251 of the statutes, by-laws, rules and recommendations of the International Capital Market Association (the 'ICMA Rule Book'), calculated in accordance with Rule 251 of the ICMA Rule Book as applied to non US dollar denominated straight and convertible bonds issued after December 31, 1998, as though the interest coupon on a bond were being calculated for a coupon period corresponding to the Calculation Period or Compounding Period in respect of which payment is being made;.">
	[calculation]
	alias daysInPeriod: DateDifference(startDate, endDate)
	assign-output result:
		daysInPeriod / (daysInPeriod * periodsInYear)

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_365_FIXED): <"'2006 ISDA Definition Article 4 section 4.16(d): If 'Actual/365 (Fixed)', 'Act/365 (Fixed)', 'A/365 (Fixed)' or 'A/365F' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365. ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias daysInPeriod: DateDifference(startDate, endDate)
	assign-output result:
		daysInPeriod / 365

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_360): <"'2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]
	alias daysInPeriod: DateDifference(startDate, endDate)
	assign-output result:
		daysInPeriod / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30_360): <"2006 ISDA Definition Article 4 section 4.16(f): if '30/360', '360/360' or 'Bond Basis' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows:[[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360.">
	[calculation]

	alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
		startDate -> year

	alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
		endDate -> year

	alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
		startDate -> month

	alias endMonth: <"The calendar month, expressed as number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
		endDate -> month

	alias endDay: <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31 and D2, is greater than 29, in which case D2 will be 30.">
		if startDate -> day > 29 then Min(endDate -> day, 30) else endDate -> day

	alias startDay: <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case, will be 30.">
		Min(startDate -> day, 30)
	assign-output result:
		(360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360): <"'2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
	[calculation]

	alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
		startDate -> year

	alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
		endDate -> year

	alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
		startDate -> month

	alias endMonth: <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
		endDate -> month

	alias endDay: <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30.">
		Min(endDate -> day, 30)

	alias startDay: <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30.">
		Min(startDate -> day, 30)
	assign-output result:
		(360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360_ISDA): <"2006 ISDA Definition Article 4 section 4.16(h): if '30E/360 (ISDA)' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows: [[360 × (Y2 - Y1)]+[30 × (M2 - M1)] +(D2 - D1)]/360 .">
	[calculation]

	alias startDateIsInLeapYear:
		IsLeapYear(startDate -> year)

	alias endDateIsInLeapYear:
		IsLeapYear(endDate -> year)

	alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
		startDate -> year

	alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
		endDate -> year

	alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
		startDate -> month

	alias endMonth: <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
		endDate -> month

	alias startDay:
		if startDateIsInLeapYear = False and startDate -> month = 2 and startDate -> day = 28
			or startDateIsInLeapYear = True and startDate -> month = 2 and startDate -> day = 29
			or startDate -> day = 31
		then 30 else endDate -> day

	alias endDay:
		if endDateIsInLeapYear = False and endDate -> month = 2 and endDate -> day = 28
			or endDateIsInLeapYear = True and endDate -> month = 2 and endDate -> day = 29
			or endDate -> day = 31
			or endDate = terminationDate
		then 30 else endDate -> day
	assign-output result:
		(360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_365L): <"The actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365 (or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366).">
	[calculation]

	alias endDateIsInLeapYear:
		IsLeapYear(endDate -> year)

	alias daysInPeriod: DateDifference(startDate, endDate)

	alias daysInYear: <"365 or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366.">
		if (endDateIsInLeapYear = True) then 366 else 365

	assign-output result:
		daysInPeriod / daysInYear


func YearFractionForOneDay: <"Return the year fraction represented by a single day, i.e 1 / dayCountBasis, where daycountBasis represents the denominator of the day count fraction. This perhaps should take into account leap years, though the ISDA compounding formulas do not cover ACT basis at the moment.">
	[calculation]
	inputs:
		dcf DayCountFractionEnum (1..1)	<"Supplied Day count fraction.">
	output:
		yearFrac number (1..1)	<"Corresponding year fraction.">
	// calculate and return the value from the DayCountBasis
	assign-output  yearFrac: 1 / DayCountBasis(dcf)


func DayCountBasis: <"Return the day count basis (the denominator of the day count fraction) for the day count fraction.">
	[calculation]
	inputs:
		dcf DayCountFractionEnum (1..1)	<"a supplied day count fraction.">
	output:
		basis int (1..1)		<" the corresponding basis, typically 360 or 365.">

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_360):
	assign-output basis: 360

func DayCountBasis(dcf: DayCountFractionEnum ->_30_360):
	assign-output basis: 360

func DayCountBasis(dcf: DayCountFractionEnum ->_30E_360):
	assign-output basis: 360

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_365L):
	assign-output basis: 365

func DayCountBasis(dcf: DayCountFractionEnum ->ACT_365_FIXED):
	assign-output basis: 365

func DayCountBasis(dcf: DayCountFractionEnum ->ACT_ACT_AFB):
	assign-output basis: 365 // Should this support 366 in leap years?  requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum ->ACT_ACT_ISDA):
	assign-output basis: 365 // Should this support 366 in leap years?  requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum ->ACT_ACT_ICMA):
	assign-output basis: 365 // Should this support 366 in leap years? requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum ->BUS_252):
	assign-output basis: 252


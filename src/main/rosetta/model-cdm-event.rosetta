namespace "org.isda.cdm"
version "%project.version%"

class AllocationOutcome <"A class to specify the allocated outcome as the combination of an execution which state is specified as 'Allocated' and a contract or set of contract(s). (The allocation to one single contract is deemed appropriate.)">
{
	execution Execution (1..1);
		[synonym Rosetta_Workbench value execution]
	contract Contract (1..*);
		[synonym Rosetta_Workbench value trade]
}

data rule AllocationOutcome_execution <"The allocation outcome must result in execution state of 'Allocated'.">
	when AllocationOutcome exists
	then AllocationOutcome -> execution -> closedState -> state = ClosedStateEnum.Allocated

class AllocationPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before ExecutionState (1..1);
		[synonym Rosetta_Workbench value before]
	after AllocationOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class CashTransferBreakdown extends TransferBreakdown
{
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">;
	amount Money (1..1) <"The currency amount of the payment.">;
		[synonym Rosetta_Workbench value amount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value cashflowType]
}

class CashTransferComponent extends TransferBase
{
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">;
	amount Money (1..1) <"The currency amount.">;
		[synonym Rosetta_Workbench value amount]
		[synonym DTCC_11_0, DTCC_9_0 value paymentAmount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value cashflowType]
		[synonym DTCC_11_0, DTCC_9_0 value cashflowType path "calculationDetails.grossCashflow" meta cashflowTypeScheme]
	breakdown CashTransferBreakdown (0..*) <"The cash transfer breakdown, when the transfer corresponds to a net amount across several components which breakdown is deemed relevant (e.g. the net cash transfer related to several contracts, or to the net proceeds across several payout components).">;
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0 value breakdown]
}

class ClearingWorkflow <"A class to specify the clearing workflow information: clearing status, clearing venue, party-specific execution workflow information, ...">
{
	/*
	 * One alternative is to represent the clearing venue as part of the partyRole + party,
	 * but CME mapping would be involved because requiring to create an id/href relationship
	 */
	clearingVenue string (0..1) <"The clearing venue identification. This attribute is optional because the CCP is the party to the contract in the case of a beta/gamma trade.">;
	 	[synonym CME_SubmissionIRS_1_0 value TSub path "Hdr"]
	/*
	 * This information results from CDM lineage into the alpha trade, which implies that the value should probably not be mapped
	 */
	originatingEvent OriginatingEventEnum (0..1) <"The qualification by the clearing facility of whether the cleared trade results from a trade presented for clearing by market participants (in which case it is qualified as a 'New Trade') or whether it results from a process that is internal to the CCP, in which case this process will be qualified accordingly (e.g. Transfer, Novation, Compression, ...).">;
		[synonym CME_ClearedConfirm_1_17 value originatingEvent path "trade.tradeHeader"]
		[synonym Rosetta_Workbench value originatingEvent]
}

/*
 * TODO - The commodity transfer component and its associated breakdown should be deemed as sample implementations,
 * which need to be confirmed through relevant user stories and use cases
 */
class CommodityTransferBreakdown extends TransferBreakdown
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	commodity Commodity (1..1);
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">;
	timeUnit TimeUnitEnum (0..1);
}

class CommodityTransferComponent extends TransferBase
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	commodity Commodity (1..1);
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">;
	timeUnit TimeUnitEnum (0..1);
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">;
	breakdown CommodityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">;
		[synonym Rosetta_Workbench value breakdown]
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction calculation (1..1);
	amount number (1..1);
	currency string (0..1) scheme;
		[synonym Rosetta_Workbench value currency meta currencyScheme]
}

class ContractLineage <"The lineage into the contract object alongside with, optionally, the various payout components.">
{
	contractLineageQualifier ContractLineageQualifierEnum (0..1) <"The lineage qualification, which is meant to provide insight into the object that is represented by the rosettaKey reference.">;
		[synonym Rosetta_Workbench value contractLineageQualifier]
	contractReference Contract (1..1) rosettaKey reference <"The CDM recommended usage is the rosettaKey, which corresponds to the hash value of the contract class which is positioned as the lineage source. The reference is meant to provide support for the ingestion of xml documents with id/href mechanisms.">;
	    [synonym Rosetta_Workbench value contractReference meta href]
	cashflowReference Cashflow (0..*) rosettaKey reference <"The pointer to the cashflow payout component. An expected typical usage is to provide lineage for the payment of, say, the option premium or the swap initial fee.">;
		[synonym Rosetta_Workbench value cashflowReference meta href]
	creditDefaultPayoutReference CreditDefaultPayout (0..*) rosettaKey reference <"The pointer to the credit default payout component.">;
		[synonym Rosetta_Workbench value creditDefaultReference meta href]
	interestRatePayoutReference InterestRatePayout (0..*) rosettaKey reference <"The pointer to the interest rate payout component. An expected typical usage is to provide lineage for the payment of, say, an interest rate swap reset, with the ability to relate the gross cashflow amounts to the respective payout components.">;
		[synonym Rosetta_Workbench value interestRatePayoutReference meta href]
	optionPayoutReference OptionPayout (0..*) rosettaKey reference <"The pointer to the option payout component.">;
		[synonym Rosetta_Workbench value optionPayoutReference meta href]
	equityPayoutReference EquityPayout (0..*) rosettaKey reference <"The pointer to the equity payout component. An expected typical usage is to provide lineage for the payment of, say, an equity dividend.">;
		[synonym Rosetta_Workbench value equityPayoutReference meta href]
}

class ContractState <"A class to specify a contract instantiation with respect to the before and/or after state of lifecycle events.">
{
	contract Contract (1..1);
        [synonym Rosetta_Workbench value trade]
        [synonym DTCC_11_0, DTCC_9_0 value FpML path "Trade"]
        [synonym DTCC_11_0, DTCC_9_0 value TradeMsg path "Manifest"]
        [synonym DTCC_11_0, DTCC_9_0 value ReportingJurisdiction path "ReportingData.ReportingHeader"]
        [synonym CME_SubmissionIRS_1_0 value FpML path "Instrmt.SecXML"]
}

class CreditLimit
	[synonym FpML_5_10 value CreditLimit]
{
	limitId string (0..1) scheme;
		[synonym FpML_5_10 value limitId meta creditLimitIdScheme]
	applicableProduct ProductIdentification (0..1) <"Further to the FpML standard, the CDM ProductIdentification provides the ability to associate a CDM qualified product.">;
	currency string (0..1) scheme;
		[synonym FpML_5_10 value currency meta currencyScheme]
	tenor Period (0..1) <"The maximum allowed tenor for a trade under this limit. When this structure is used as part of a suspendCredit message, this tenor imposes a temporary tenor limit on allowed trade types.">;
		[synonym FpML_5_10 value tenor]
	limitApplicable LimitApplicable (0..*);
		[synonym FpML_5_10 value limitApplicable]
	expirationDateTime BusinessCenterTime (0..1) <"The CDM naming include the time suffix because the FpML element is actually of type dateTime. Also, the attribute is of type BusinessCenterTime because of the design decision to only have time that are specified by reference to a timezone, with that class being deemed the proper implementation.">;
		[synonym FpML_5_10 value expirationDate]
}

class CreditLimitInformation <"A class to represent the credit limit utilisation information.">
	[synonym CME_ClearedConfirm_1_17 value CreditLimitInformation]
{
	limitApplicable LimitApplicableExtended (1..*);
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitApplicable]
}

class CreditLimitUtilisation <"Credit limit utilisation breakdown by executed trades and pending orders.">
	[synonym FpML_5_10 value CreditLimitUtilization]
{
	executed CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to executed trades.">;
		[synonym FpML_5_10 value executed]
	pending CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to pending unexecuted orders.">;
		[synonym FpML_5_10 value pending]
}

class CreditLimitUtilisationPosition
	[synonym FpML_5_10 value CreditLimitUtilizationPosition]
{
	shortPosition number (0..1) <"Credit limit utilisation attributable to short positions.">;
		[synonym FpML_5_10 value short]
	longPosition number (0..1) <"Credit limit utilisation attributable to long positions.">;
		[synonym FpML_5_10 value long]
	global number (0..1) <"Global credit limit utilisation amount, agnostic of long/short position direction.">;
		[synonym FpML_5_10 value global]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1) scheme; // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
		[synonym Rosetta_Workbench value commodityCurve meta commodityReferencePriceScheme]
}

class CustomisedWorkflow <"In its initial iteration, this class is meant to support the DTCC TIW workflow information.">
{
	itemName string (1..1) <"In this initial iteration, this corresponds to the DTCC TIW element name.">;
		[synonym DTCC_11_0, DTCC_9_0 set to "comment" when path = "PartyWorkflowFields.comment"]
		[synonym DTCC_11_0, DTCC_9_0 set to "superId" when path = "PartyWorkflowFields.superId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "deskId" when path = "PartyWorkflowFields.deskId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "eTradeId" when path = "PartyWorkflowFields.eTradeId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "designatedParty" when path = "PartyWorkflowFields.designatedParty"]
		[synonym DTCC_11_0, DTCC_9_0 set to "brokerName" when path = "PartyWorkflowFields.brokerName"]
		[synonym DTCC_11_0, DTCC_9_0 set to "branchLocation" when path = "PartyWorkflowFields.branchLocation"]
		[synonym DTCC_11_0, DTCC_9_0 set to "midMarketPriceType" when path = "PartyWorkflowFields.midMarketPrice.midMarketPriceType"]
		[synonym DTCC_11_0, DTCC_9_0 set to "amount" when path = "PartyWorkflowFields.midMarketPrice.amount"]
		[synonym CME_SubmissionIRS_1_0 set to "ClientOrderId" when path = "ClOrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "TradeOriginationSystem" when path = "InptSrc"]
		[synonym CME_SubmissionIRS_1_0 set to "OriginatingTradeId" when path = "OrigTrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "ExecutionTime" when path = "TrdRegTS.TS" and "TrdRegTS.Typ" = "1"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyType" when path = "Pty.R"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyIdentifier" when path = "Pty.Src"]
	itemValue string (1..1) <"In this initial iteration, this corresponds to the DTCC value.">;
		[synonym DTCC_11_0, DTCC_9_0 value comment path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value superId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value deskId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value eTradeId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value designatedParty path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value brokerName path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value branchLocation path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value midMarketPriceType path "PartyWorkflowFields.midMarketPrice"]
		[synonym DTCC_11_0, DTCC_9_0 value amount path "PartyWorkflowFields.midMarketPrice"]
		[synonym CME_SubmissionIRS_1_0 value ClOrdID]
		[synonym CME_SubmissionIRS_1_0 value InptSrc]
		[synonym CME_SubmissionIRS_1_0 value OrigTrdID]
		[synonym CME_SubmissionIRS_1_0 value TS path "TrdRegTS"]
		[synonym CME_SubmissionIRS_1_0 set to "Customer Account" when "Pty.R" = "24"]
		[synonym CME_SubmissionIRS_1_0 set to "Custom" when "Pty.Src" = "D"]
}

class Event rosettaKey
{
	id (0..1);
		[synonym Rosetta_Workbench meta id]
	messageInformation MessageInformation (0..1);
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Payment"]
		[synonym DTCC_11_0, DTCC_9_0 value RouteInfo path "Header.OTC_RM.Delivery"]
		[synonym DTCC_11_0, DTCC_9_0 value Manifest path "Header.OTC_RM"]
		[synonym CME_ClearedConfirm_1_17 value header path "clearingConfirmed"]
	timestamp EventTimestamp (1..*) <"The set of timestamp(s) associated with the event as a collection of [dateTime, qualifier].">;
		[synonym Rosetta_Workbench value timestamp]
		[synonym DTCC_11_0, DTCC_9_0 value header path "Body.OTC_Matching.Trade.FpML"]
		[synonym DTCC_11_0, DTCC_9_0 value Route path "Header.OTC_RM.Delivery.RouteHist"]
		[synonym DTCC_11_0, DTCC_9_0 value header path "Body.OTC_Matching.Payment.FpML"]
        [synonym CME_ClearedConfirm_1_17 value timestamps path "clearingConfirmed.trade.tradeHeader"]
        [synonym CME_ClearedConfirm_1_17 value header path "clearingConfirmed"]
    eventIdentifier Identifier (1..*) <"The identifier(s) that uniquely identify a lifecycle event. The unbounded cardinality is meant to provide the ability to associate identifiers that are issued by distinct parties. As an example, each of the parties to the event may choose to associate their own identifiers to the event.">;
		[synonym Rosetta_Workbench value eventIdentifier]
		[synonym DTCC_11_0, DTCC_9_0 value Submitter path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value ContraTradeId path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value YourTradeId path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value tradeIdentifyingItems path "Header.OTC_RM.Manifest.TradeMsg"]
	eventQualifier eventType (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic (e.g. PartialTermination, ClearingSubmission, Novation, ...).">;
	eventDate date (1..1) <"The date on which the event is taking place. This is the equivalent of the trade date in the case of an execution or a contract.">;
		[synonym Rosetta_Workbench value eventDate]
		[synonym CME_ClearedConfirm_1_17 value clearedDate path "clearingConfirmed.trade.tradeHeader" maps 2]
	effectiveDate date (0..1) <"The date on which the event contractually takes effect, when different from the event date.">;
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym Rosetta_Workbench
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True,
			set to ActionEnum.Cancel when "isRetraction" = True]
		[synonym FpML_5_10
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True]
		[synonym DTCC_11_0, DTCC_9_0 value Activity path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym CME_SubmissionIRS_1_0 value TransTyp path "TrdCaptRpt"]
	intent IntentEnum (0..1) <"The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from the event features. As a result it is only associated with those primitives that can give way to such ambiguity, the quantityChange being one of those. An example of such is a reduction in the trade notional, which could be interpreted as either a trade correction (unless a maximum period of time post-event is specified as part of the qualification), a partial termination or a portfolio rebalancing in the case of an equity swap. On the other hand, an event such as the exercise is not expected to have an associated intent as there should not be ambiguity.">;
		[synonym Rosetta_Workbench value intent]
	party Party (0..*) <"The specification of the event parties. This attribute is optional, as not applicable to certain events (e.g. most of the observations).">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value party]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Trade.FpML" ]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Payment.FpML" ]
	account Account (0..*) <"Optional account information that could be associated to the event.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0 value account]
		[synonym CME_ClearedConfirm_1_17 value account path "clearingConfirmed"]
	lineage Lineage (0..1) <"The lineage attribute provides a linkage among lifecycle events through the rosettaKey hash value. One example is when a given lifecycle event is being corrected or cancelled. In such case, each subsequent event will have lineage into the prior version of that event. The second broad use case is when an event has a dependency upon either another event (e.g. the regular payment associated with a fix/float swap will have a lineage into the reset event, which will in turn have a lineage into the observation event for the floating rate and the contract) or a contract (e.g. the exercise of an option has a lineage into that option).">;
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1) <"The primitive (or set of primitives) associated with the event, such as quantityChange, transfer, ... Those primitives are specified through the PrimitiveEvent class.">;
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1) <"This is placeholder concept for a function call into a calculation that will return an outcome. This concept needs to be further firmed out.">;
		[synonym Rosetta_Workbench value functionCall]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, novation events), listed products (from, say, a bond option exercise event)  values and more. Those are represented through a set of rosettaKey references. This attribute is optional in order to provide implementers with the ability not to make use of this feature.">;
	eventWorkflow EventWorkflow (0..1) <"The event workflow information, i.e. the workflow status, the associated comment and the partyCustomisedWorkflow which purpose is to provide the ability to associate custom workflow information to the CDM.">;
}

data rule Event_version <"The identifier version is required for lifecycle events.">
	when Event -> eventIdentifier -> assignedIdentifier -> identifier exists
	then Event -> eventIdentifier -> assignedIdentifier -> version exists

data rule Event_new <"The eventIdentifier version associated with a new event is equal to 1.">
	when Event -> action = ActionEnum.New
	then Event -> eventIdentifier -> assignedIdentifier -> version = 1

data rule Event_correctCancel <"The eventIdentifier version associated with a correction or a cancellation is greater than 1 and a lineage into a prior version of the event needs to exist.">
	when ( Event -> action = ActionEnum.Correct
		or Event -> action = ActionEnum.Cancel )
	then Event -> eventIdentifier -> assignedIdentifier -> version > 1
	and Event -> lineage -> eventLineage -> eventLineageQualifier = EventLineageQualifierEnum.PriorEventVersion

data rule Event_intent <"The intent should only be associated with the primitives which use can lead to ambiguity with respect to the qualification of the event.">
	when ( Event -> primitive -> allocation
		or Event -> primitive -> exercise
		or Event -> primitive -> inception
		or Event -> primitive -> observation
		or Event -> primitive -> reset ) exists
	then Event -> intent is absent

class EventEffect <"The set of operational and positional effects associated with a lifecycle event, alongside the reference to the contract reference(s) that is subject to the event (and is positioned in the before state of the event primitive).">
{
	effectedContract Contract (0..*) rosettaKey <"A pointer to the contract(s) to which the event effect(s) apply, i.e. in the before event state.">;
	effectedExecution Execution (0..*) rosettaKey <"A pointer to the execution(s) to which the event effect(s) apply, i.e. in the before event state.">;
	contract Contract (0..*) rosettaKey <"A pointer to the contract effect(s), an example of such being the outcome of a new trade, swaption exercise or novation event.">;
    execution Execution (0..*) rosettaKey <"A pointer to the execution effect(s), an example of such being a clearing submission event when taking place on the back of an execution.">;
    productIdentifier ProductIdentifier (0..*) rosettaKey <"A pointer to the product identifier effect(s), an example of such being the outcome of the physical exercise of a bond option.">;
	transfer TransferPrimitive (0..*) rosettaKey <"A pointer to the transfer effect(s), either a cash, security or other asset.">;
}

class EventLineage <"The lineage into the event object alongside with, optionally, the transfer component.">
{
	eventLineageQualifier EventLineageQualifierEnum (1..1) <"The lineage qualification, which is meant to provide insight into the object that is represented by the rosettaKey reference.">;
		[synonym Rosetta_Workbench value eventLineageQualifier]
	eventReference Event (1..1) rosettaKey reference <"The CDM recommended usage is the rosettaKey, which corresponds to the hash value of the event class which is positioned as the lineage source. The reference is meant to provide support for the ingestion of xml documents with id/href mechanisms.">;
		[synonym Rosetta_Workbench value eventReference meta href]
	transferReference TransferPrimitive (0..*) rosettaKey reference; // Usage needs to be confirmed
		[synonym Rosetta_Workbench value cashflowReference meta href]
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimestamp <"A class to represent the various set of timestamps that can be associated with lifecycle events, as a collection of [dateTime, qualifier]">
{
	dateTime zonedDateTime (1..1) <"The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">;
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value creationTimestamp]
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value expiryTimestamp]
		[synonym DTCC_11_0, DTCC_9_0 value ReceiveTime]
		[synonym CME_ClearedConfirm_1_17 value submittedForClearing]
		[synonym CME_SubmissionIRS_1_0 value TxnTm path "TrdCaptRpt"]
		[synonym CME_SubmissionIRS_1_0 value Snt path "TrdCaptRpt.Hdr"]
		[synonym CME_SubmissionIRS_1_0 value TS path "TrdCaptRpt.TrdRegTS"]
	qualification EventTimeStampQualificationEnum (1..1);
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimeStampQualificationEnum.eventCreationTime when "creationTimestamp" exists]
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimeStampQualificationEnum.eventExpirationTime when "expiryTimestamp" exists]
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench set to EventTimeStampQualificationEnum.clearingSubmissionTime when "submittedForClearing" exists]
		[synonym DTCC_11_0, DTCC_9_0 set to EventTimeStampQualificationEnum.eventSubmittedTime when "ReceiveTime" exists]
		[synonym CME_SubmissionIRS_1_0 set to EventTimeStampQualificationEnum.transactionCreationTime when path = "TrdCaptRpt.TxnTm"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimeStampQualificationEnum.eventSentTime when path= "TrdCaptRpt.Hdr.Snt"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimeStampQualificationEnum.executionTime when path= "TrdCaptRpt.TrdRegTS.TS" and "TrdCaptRpt.TrdRegTS.Typ" = 1]
}

class EventWorkflow <"A class to specify workflow information, which is conceptually applicable to all lifecycle events.">
{
	workflowStatus WorkflowStatusEnum (0..1) <"The workflow status indicator, e.g. Accepted, Rejected, ...">;
		[synonym CME_SubmissionIRS_1_0 value RptTyp path "TrdCaptRpt"]
		[synonym Rosetta_Workbench value clearingStatus path "primitive.inception.after"]
		[synonym CME_ClearedConfirm_1_17 value status path "clearingConfirmed.trade.tradeHeader"]
	comment string (0..1) <"A comment field to be associated with the workflow, e.g. to specify why a transaction event was rejected by a party.">;
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Workflow data that is specific to certain market participants and is expressed as part of the CDM in a very generic manner, which can be part-specific. The initial use cases have been derived from the CME clearing and the DTCC TIW submissions.">;
		[synonym CME_SubmissionIRS_1_0 value RptSide path "TrdCaptRpt"]
}

class ExerciseOutcome <"The exercise outcome combines the option contract (which states would be 'Exercised' in case of a full exercise and which would have a reduced notional in case of partial exercise) and either a physical or partial exercise.">
{
	contract Contract (1..1);
		[synonym Rosetta_Workbench value contract]
	physicalExercise PhysicalExercise (0..1);
		[synonym Rosetta_Workbench value physicalExercise]
	cashExercise Cashflow (0..1);
		[synonym Rosetta_Workbench value cashExercise]
}

choice rule ExerciseOutcome_choice <"A option exercise results in either a physical or a cash exercise.">
	for ExerciseOutcome required choice between
	physicalExercise and cashExercise

class ExecutionState <"A class to specify an execution instantiation with respect to the before and/or after state of lifecycle events.">
{
	execution Execution (1..1);
		[synonym Rosetta_Workbench value execution]
}

class ExercisePrimitive <"This primitive leverages the FpML OptionExercise construct, except for the exerciseTiming which is deemed as associated to a request for exercise that is meant to take place, as opposed to the actual exercise event.">
{
	exerciseDate AdjustableOrAdjustedDate (0..1);
		[synonym Rosetta_Workbench value exerciseDate]
	exerciseTime BusinessCenterTime (0..1);
		[synonym Rosetta_Workbench value exerciseTime]
	fullExercise boolean (1..1);
		[synonym Rosetta_Workbench value fullExercise]
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Inception <"The primitive event for the inception of a new contract between parties. It is expected that this primitive will be adjusted or deprecated once the CDM scope is extended to the pre-execution space.">
{
	before ContractState (0..0) <"The (0..0) cardinality reflects the fact that there is no contract in the before state of an inception primitive. As noted in the definition associated with the class, this is expected to change once the CDM scope is extended to the pre-execution space.">;
		[synonym Rosetta_Workbench value before]
	after PostInceptionState (1..1) <"The after state corresponds to the new contract between the parties.">;
		[synonym Rosetta_Workbench value after]
		[synonym DTCC_11_0 value OTC_RM path "Header"]
		[synonym DTCC_11_0, DTCC_9_0 value OTC_Matching path "Body" set when "Header.OTC_RM.Manifest.TradeMsg.TransType" = "Trade"]
		[synonym CME_ClearedConfirm_1_17 value clearingConfirmed]
}

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1) scheme;
		[synonym Rosetta_Workbench value floatingRateIndex meta floatingRateIndexScheme]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class LimitApplicable
	[synonym FpML_5_10 value LimitApplicable]
{
	limitType CreditLimitTypeEnum (0..1) scheme <"Standard code to indicate which type of credit line is being referred to - i.e. IM, DV01, PV01, CS01, Notional, Clip Size, Notional, maximumOrderQuantity.">;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value limitType meta creditLimitTypeScheme]
	clipSize int (0..1) <"This element is required in FpML, optional in CDM for the purpose of accommodating the CME data representation while making reference to the FpML one.">;
		[synonym FpML_5_10 value clipSize]
	amountUtilized number (0..1) <"The limit utilised by all the cleared trades for the limit level and limit type. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value amountUtilized]
	utilization CreditLimitUtilisation (0..1);
		[synonym FpML_5_10 value utilization]
	amountRemaining number (0..1) <"The limit remaining for the limit level and limit type. This does not take into account any pending trades. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value amountRemaining]
	currency string (0..1) scheme;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value currency meta currencyScheme]
	velocity Velocity (0..1);
		[synonym FpML_5_10 value velocity]
}

choice rule LimitApplicable_choice <"Choice rule to represent an FpML choice construct.">
 	for LimitApplicable optional choice between
	amountUtilized and utilization

class LimitApplicableExtended extends LimitApplicable <"A class to represent the CDM attributes that are not part of the FpML standard. Once broader usage is confirmed, it is expected that those two classes can be collapsed.">
	[synonym CME_ClearedConfirm_1_17 value CreditLimitInformation]
{
	limitLevel LimitLevelEnum (0..1) scheme <"The level at which the limit is set: customer business, proprietary business or account level. This attribute is specified as a string as part of the CME clearing confirmation specification.">;
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value level meta creditLimitLevelScheme]
	limitAmount number (0..1) <"The total limit available for the limit level and limit type. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitAmount]
	limitImpactDueToTrade number (0..1) <"The limit utilised by this specific trade. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitImpactDueToTrade]
}

class Lineage <"The class to provide lineage information across lifecycle events, i.e. to provide a pointer or set of pointers into the event(s), contract(s) and, possibly, payout components that the event is dependent on. Those pointers are constituted by the rosettaKey, which corresponds to the hash value of the CDM class which is referred to. As an example, if an inception event is corrected, the correction event will have a lineage into the initial event, which takes the form of a rosettaKey into that initial inception event.">
{
	contractLineage ContractLineage (0..*) <"The contract lineage components, i.e. the contract and the various contract payouts. A typical usage example is the payment of an interest rate swap reset event, with the lineage into the contract as well as each of the respective legs for the gross cashflow components.">;
	    [synonym Rosetta_Workbench value contractLineage]
	eventLineage EventLineage (0..*) <"The event lineage components, i.e. the contract and the transfer.">;
	    [synonym Rosetta_Workbench value eventLineage]
}

class MessageInformation <"This class corresponds to the components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId path "messageInformation" meta messageIdScheme]
		[synonym DTCC_11_0, DTCC_9_0 value messageId path "header" meta messageIdScheme]
		[synonym CME_ClearedConfirm_1_17 value messageId meta messageIdScheme]
	sentBy string (0..1) scheme <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy path "messageInformation" meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value From]
		[synonym CME_ClearedConfirm_1_17 value sentBy meta messageAddressScheme]
		[synonym CME_SubmissionIRS_1_0 value SSub path "TrdCaptRpt.Hdr"]
	sentTo string (0..*) scheme <"The identifier(s) for the recipient(s) of a message instance.">;
		[synonym Rosetta_Workbench value sentTo path "messageInformation" meta messageAddressScheme]
		[synonym CME_ClearedConfirm_1_17 value sendTo meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value To]
		[synonym CME_SubmissionIRS_1_0 value TID path "TrdCaptRpt.Hdr"]
	copyTo string (0..*) scheme  <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
		[synonym DTCC_11_0, DTCC_9_0 value observationDate]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class PartyCustomisedWorkflow <"A class to specify a party-related, non-standardised data in a generic form.">
{
	partyReference Party (0..1) reference <"Reference to the party to which the workflow pertains to.">;
		[synonym DTCC_11_0, DTCC_9_0 value partyReference meta href]
	partyName string (0..1) <"The party name to which the workflow pertains to.">;
		[synonym CME_SubmissionIRS_1_0 value ID path "Pty"]
	customisedWorkflow CustomisedWorkflow (1..*) <"Non-standardised data in a generic form.">;
}

choice rule PartyCustomisedWorkflow_choice <"The identification of the party to which the PartyCustomisedWorkflow pertains to can be done through either a party reference or the party name.">
	for PartyCustomisedWorkflow required choice between
	partyName and partyReference

class PhysicalExercise <"The physical exercise results into a financial product which is represented through the Product class, with an associated quantity and cashflow (e.g. a physical exercise of a bond option will result into a bond with a cash proceed which will be a function of the option strike price).">
{
	product Product (1..1);
		[synonym Rosetta_Workbench value product]
	quantity Quantity (0..1) <"The quantity associated the asset that is physically settled. This quantity should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">;
		[synonym Rosetta_Workbench value quantity]
	cashflow Cashflow (0..1) <"The cashflow component of the physical exercise.">;
		[synonym Rosetta_Workbench value cashflow]
}

data rule PhysicalExercise_quantity <"The quantity attribute should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
	when ( PhysicalExercise -> product -> contractualProduct or PhysicalExercise -> product -> contract) exists
	then PhysicalExercise -> quantity is absent

class PostInceptionState extends ContractState
{
	creditLimitInformation CreditLimitInformation (0..1) <"Credit limit utilization information.">;
		[synonym CME_ClearedConfirm_1_17 value creditLimitInformation path "trade.tradeHeader"]
		[synonym Rosetta_Workbench value creditLimitInformation]
	tradeWarehouseWorkflow TradeWarehouseWorkflow (0..1) <"Information related to trade warehouse workflow.">;
}

class PrimitiveEvent <"The set of primitive events.">
{
	allocation AllocationPrimitive (0..*);
		[synonym Rosetta_Workbench value allocation]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	inception Inception (0..*);
		[synonym Rosetta_Workbench value inception]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	quantityChange QuantityChangePrimitive (0..*);
		[synonym Rosetta_Workbench value quantityChange]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value ignore]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	termsChange TermsChangePrimitive (0..1);
		[synonym Rosetta_Workbench value termsChange]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	transfer TransferPrimitive (0..*);
		[synonym Rosetta_Workbench value transfer]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
		[synonym DTCC_11_0, DTCC_9_0 value Payment path "Body.OTC_Matching"]
}

class QuantityChangePrimitive <"The primitive event to represent a change in quantity or notional.">
{
	before Trade (1..1) <"The state of the trade (either an execution or a contract, before the event.">;
		[synonym Rosetta_Workbench value before]
		[synonym CME_SubmissionIRS_1_0 value ignore]
	after Trade (1..1) <"The state of the trade (either an execution or a contract, as a follow-up from the event.">;
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

/*
 * TODO - Consider extending the data rule syntax to support the below data rule https://trello.com/c/1ZRsJbzN
 */
//data rule QuantityChangePrimitive_change <"The change value should be equal to the difference between the respective quantities.">_
//	when Event -> primitive -> quantityChange exists
//	then Event -> primitive -> quantityChange -> change = (quantityAfterQuantityChange - quantityBeforeQuantityChange)


class ResetPrimitive <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	resetValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value resetValue]
	/*
	 * Question to the CDM Group - Should the reset primitive have an associated cashflow, or just have the rate reset value?
	 * The latter seems more appropriate, but needs to be confirmed by current operational workflows.
	 * If it has the cashflow, it should also have the associated calculation.
	 */
	cashflow Cashflow (0..1) <"The cashflow resulting from the reset event.">; // The cardinality has been relaxed until the above question is settled
		[synonym Rosetta_Workbench value cashflow]
}

class SecurityTransferBreakdown
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	security Security (1..*) <"The security(ies) that is being transfered">;
		[synonym Rosetta_Workbench value security]
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
}

class SecurityTransferComponent extends TransferBase
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	security Security (1..1) <"The security that is being transfered">;
		[synonym Rosetta_Workbench value security]
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	assetTransferType AssetTransferTypeEnum (0..1); // The relevance of this attribute and the associated values need to be confirmed"
		[synonym Rosetta_Workbench value assetTransferType]
	breakdown SecurityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">;
		[synonym Rosetta_Workbench value breakdown]
}

class TermsChangePrimitive <"The primitive event to represent change(s) to the contractual terms and the clearing submission and acceptance process.">
{
	before Trade (1..1);
		[synonym Rosetta_Workbench value before]
	after Trade (1..1);
		[synonym Rosetta_Workbench value after]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location meta timezoneLocationScheme]
}

class Trade one of <"A class to represent the general trade concept, which can either be an execution or a contract. The execution consists essentially in the economic terms which are agreed between the parties. The contract will further qualify those with the legal entities (think of the allocation case, which execution state can involve the investment adviser rather not the actual funds) while not specify the master agreement or collateral terms which might be associated with the subsequent contract.">
{
    execution Execution (0..1) <"The execution corresponds to economic terms that are agreed between parties, but which legal terms are not yet specified. The execution attribute applies to the post-execution scenario of a product that is subject to the clearing mandate and is then routed to the CCP as an execution.">;
    	[synonym CME_SubmissionIRS_1_0 value TrdCaptRpt set when "TrdCaptRpt.VenuTyp" exists]
//    	[synonym Rosetta_Workbench value trade set when "trade.executionType" exists]
	contract Contract (0..1) <"The contract differs from the execution by the fact that its legal terms are fully specified. This includes the legal entities that are associated to it as well as any associated legal agreement, e.g. master agreement, credit and collateral terms, ... ">;
        [synonym Rosetta_Workbench value trade]
        [synonym DTCC_11_0, DTCC_9_0 value FpML path "Trade"]
        [synonym DTCC_11_0, DTCC_9_0 value TradeMsg path "Manifest"]
        [synonym DTCC_11_0, DTCC_9_0 value ReportingJurisdiction path "ReportingData.ReportingHeader"]
//        [synonym CME_SubmissionIRS_1_0 value TrdCaptRpt set when "TrdCaptRpt.VenuTyp" is absent]
//        [synonym Rosetta_Workbench value trade set when "trade.executionType" is absent]
}

class TradeWarehouseWorkflow <"A class to specify trade warehouse workflow information: the identity of the trade warehouse, the contract status at the warehouse and party-specific workflow information.">
{
	warehouseIdentity WarehouseIdentityEnum (1..1);
		[synonym DTCC_11_0, DTCC_9_0 value WarehousePositionType path "WarehouseState"]
	warehouseStatus WorkflowStatusEnum (1..1);
		[synonym DTCC_11_0, DTCC_9_0 value WarehouseStatus path "WarehouseState"]
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Non-standardized workflow data related to a party.">;
		[synonym DTCC_11_0, DTCC_9_0 value WorkflowData]
		[synonym CME_SubmissionIRS_1_0 value ignore]
}

class TransferPrimitive rosettaKey <"A class to specify the transfer primitive by providing the ability to combine a set of transfer components which are specialised by asset class.">
{
	identifier string (0..1) scheme <"The identifier which might be associated with the transfer.">;
		[synonym DTCC_11_0, DTCC_9_0 value tradeCashflowsId path "FpML" meta tradeCashflowsIdScheme]
	settlementType TransferSettlementEnum (0..1) <"The qualification as to how the transfer will settle, e.g. a DvP settlement.">;
		[synonym Rosetta_Workbench value transferType]
		[synonym DTCC_11_0, DTCC_9_0 value SettlementType path "PaymentDetails"]
	settlementDate AdjustableOrAdjustedOrRelativeDate (1..1);
		[synonym Rosetta_Workbench value settlementDate]
	cashTransfer CashTransferComponent (0..*) <"The cash transfer component of the transfer. In the case where several currencies are involved in the transfer, several components should be used, as the component supports one single currency amount.">;
		[synonym Rosetta_Workbench value cashTransfer]
		[synonym DTCC_11_0, DTCC_9_0 value payment path "FpML"]
	securityTransfer SecurityTransferComponent (0..*) <"The security transfer component of the transfer. In the case where several securities are involved in the transfer, several components should be used, as the component supports one single security.">;
		[synonym Rosetta_Workbench value securityTransfer]
	commodityTransfer CommodityTransferComponent (0..*);
	status TransferStatusEnum (0..1) <"The transfer status, e.g. Instructed, Settled...">;
		[synonym Rosetta_Workbench value status]
	settlementReference string (0..1) <"The settlement reference, when applicable.">;
		[synonym Rosetta_Workbench value settlementReference]
}

class TransferBase
{
	identifier string (0..1) scheme <"The identifier that can be associated with each of the transfer components">;
		[synonym DTCC_11_0, DTCC_9_0 value identifier meta paymentIdScheme]
	transferCalculation TransferCalculation (0..1) <"The calculation details underlying the transfer amount, when applicable.">;
		[synonym DTCC_11_0, DTCC_9_0 value calculationDetails]
}

class TransferCalculation
{
	period CalculationPeriodBase (0..1 ) <"The period adjusted start and end dates.">;
		[synonym DTCC_11_0, DTCC_9_0 value calculationPeriod path "calculationElements"]
	lineage Lineage (0..*) <"The lineage into the components used for the calculation.">;
	calculationOutcome calculation (0..1) <"The calculation outcome.">;
		[synonym Rosetta_Workbench value transferCalculation]
}

class TransferBreakdown extends TransferBase
{
	lineage Lineage (0..*) <"The lineage into the transfer components that might be associated with each of the transfer components.">;
		[synonym Rosetta_Workbench value lineage]
}

class TransferorTransferee <"A class mimicking the PayerReceiver, which is itself derived from the FpML PayerReceiver.model, to represent the transferee and transferor party information in relation to the transfer of security or commodities.">
{
	transferorPartyReference Party (1..1) reference <"A reference to the party responsible for making the payments defined by this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value payerPartyReference meta href]
	transferorAccountReference Account (0..1) reference <"A reference to the account responsible for making the payments defined by this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value payerAccountReference meta href]
	transfereePartyReference Party (1..1) reference <"A reference to the party that receives the payments corresponding to this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value receiverPartyReference meta href]
	transfereeAccountReference Account (0..1) reference <"A reference to the account that receives the payments corresponding to this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value receiverAccountReference meta href]
}

class Velocity
	[synonym FpML_5_10 value Velocity]
{
	periodMultiplier int (0..1);
	period PeriodTimeEnum (0..1);
}

/*********************
 * Event Qualification
 */

isEvent Allocation <"The qualification of allocation event from the fact that (i) the intent is Allocation when specified, (ii) the only primitive is the allocation, (iii) the sum of quantities/notional before = after, and (iv) there is a single contractualProduct before (ensured through cardinality). Note: it is accepted that an allocation can result in a single contract.">
	Event -> primitive -> allocation only exists
	/*
	 * TODO - The below syntax needs to be expanded to specify a summation
	 * This could be specify as  quantityBeforeAllocation = sum(quantityAfterAllocation)
	 */
//	and quantityBeforeAllocation = quantityAfterAllocation

alias quantityBeforeAllocation <"The alias to represent the quantity or notional amount associated to a pre-allocation contractual product in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterAllocation <"The alias to represent the quantity or notional amount associated to allocated contract(s) in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

/*
 * Temporary event qualification until such time that we firm out the proper qualification and the way to infer it
 */
isEvent CashflowCalculationNotification
	Event -> primitive -> transfer only exists
	and Event -> messageInformation -> sentBy = "DTCC"

isEvent CashTransfer <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent
	and Event -> messageInformation -> sentBy <> "DTCC" // This is a kludge related to the CashflowCalculationNotification qualification

isEvent CashAndSecurityTransfer <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transferorPartyReference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent ClearedTrade <"The cleared trade at the CCP.">
	Event -> primitive -> inception only exists
	and Event -> lineage -> eventLineage -> eventLineageQualifier = EventLineageQualifierEnum.CCP_Registration
	and Event -> lineage -> eventLineage -> eventLineageQualifier = EventLineageQualifierEnum.ClearingNotification

isEvent ClearingRejection <"The rejection of an alpha trade submission by a CCP, which is qualified by the fact that (i) termsChange is the only primitive, the workflow status is `rejected`, and (iii) the CCP is positioned as a partyRole to the execution or contract in the after state.">
	Event -> primitive -> termsChange only exists
	and Event -> eventWorkflow -> workflowStatus = WorkflowStatusEnum.Rejected
	and ( Event -> primitive -> termsChange -> after -> execution -> partyRole -> role = PartyRoleEnum.ClearingOrganization
		or Event -> primitive -> termsChange -> after -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization )
	and quantityAfterQuantityChange = quantityBeforeQuantityChange

isEvent ClearingSubmission <"The submission of a contract to a CCP, which is qualified by the fact that (i) the termsChange is the only primitive, and (ii) the CCP is positioned as a partyRole to the execution or contract in the after state.">
	Event -> primitive -> termsChange only exists
	and ( Event -> primitive -> termsChange -> after -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization
		or Event -> primitive -> termsChange -> after -> execution -> partyRole -> role = PartyRoleEnum.ClearingOrganization )

isEvent Compression <"The qualification of a compression event from the fact that (i) the quantityChange primitive exists, and (ii) there are multiple contracts (or contract references) specified in the before state.">
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> quantityChange -> before -> contract multiple exists

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists

isEvent Exercise <"The qualification of an exercise event from the fact that (i) the only primitive is the exercise, and (ii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	Event -> primitive -> exercise only exists

isEvent Increase <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
	Event -> intent when present = IntentEnum.Increase
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityBeforeQuantityChange < quantityAfterQuantityChange
	and changedQuantity > 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

isEvent MultipleTransfers <"The qualification an event that combines multiple transfers from the fact that multiple transfer primitives exist.">
	Event -> primitive -> transfer multiple exists

isEvent NewTrade
	Event -> primitive -> inception only exists
	and Event -> primitive -> inception -> after -> tradeWarehouseWorkflow is absent
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent
	and Event -> primitive -> inception -> after -> contract -> clearedDate is absent

isEvent Novation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum.Novated
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
//	and originalContractParties <> newContractParties

alias novatedContractEffectiveDate
	Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate
	or Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

alias originalContractParties
	( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)

alias newContractParties
	( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)

isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists

isEvent PartialNovation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
//	and originalContractParties <> newContractParties

data rule Novation_fee <"Logic to specify that if a cash transfer is qualified as a novation fee, it must have lineage into the novation contract, the contract resulting from the novation as well as the novation event.">
	when Event -> primitive -> transfer -> cashTransfer -> cashflowType = CashflowTypeEnum.NovationFee
	then Event -> lineage -> eventLineage -> eventLineageQualifier = EventLineageQualifierEnum.Novation

isEvent PartialTermination <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	Event -> intent when present = IntentEnum.PartialTermination
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
	and changedQuantity < 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

alias quantityBeforeQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	(Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity) -> amount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount group by currency) -> amount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> step -> stepValue
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule group by notionalStepSchedule -> currency ) -> notionalStepParameters -> notionalStepAmount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional group by varyingNotionalCurrency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount group by currency ) -> amount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount group by currency ) -> amount

alias quantityAfterQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) after a quantity change primitive.">
	Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount group by currency ) -> amount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency )-> step -> stepValue
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule group by notionalStepSchedule -> currency ) -> notionalStepParameters -> notionalStepAmount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional group by varyingNotionalCurrency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount group by currency ) -> amount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount group by currency ) -> amount

alias changedQuantity
	Event -> primitive -> quantityChange -> change -> quantity -> amount
	and Event -> primitive -> quantityChange -> change -> notionalAmount -> amount
	and Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepSchedule -> initialValue
	and Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	and Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	and Event -> primitive -> quantityChange -> change -> fxLinkedNotional -> initialValue

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists

isEvent SecurityTransfer <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent SecuritySettlement <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transfereePartyReference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent Termination <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
	Event -> intent when present = IntentEnum.Termination
	and Event -> primitive -> quantityChange only exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum.Terminated

isEvent TradeWarehousePositionNotification
	Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> tradeWarehouseWorkflow exists

/****************
 * Workflow rules
 */

/*
workflow rule ClearedContract

    Event <beta> is ClearingNotification
	relatedTo <alpha> by rosettaKey where Event -> lineage -> eventLineage -> eventlineageQualifier = EventLineageQualifierEnum.CCP_Registration
    and relatedTo <gamma> by rosettaKey where Event -> lineage -> eventLineage -> eventlineageQualifier = EventLineageQualifierEnum.ClearingNotification

    constraint is economicTerms are the same except for payerReceiver or buyerSeller
    and event date of `alpha` = trade date of `beta` and `gamma`
    and CCP which is in the party role of `alpha` is the same as the CCP which is counterparty to `beta` and `gamma`

 */

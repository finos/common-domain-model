namespace "org.isda.cdm"
version "${project.version}"

import cdm.base.*
import cdm.base.maths.*
import cdm.base.datetime.*
import cdm.base.staticdata.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.asset.*
import cdm.base.staticdata.asset.rates.*


/**********************************************************
 * Qualifiable functions isProduct and isEvent root classes
 */
isEvent root WorkflowEvent;
isProduct root EconomicTerms;


type AllocationInstructions:
	// TODO: add other allocation context
	breakdowns AllocationBreakdown (1..*) <"The set of allocation breakdowns to be applied to a block trade">

type AllocationBreakdown:
	partyReference Party (1..1) <"Reference to the party to specify the account.">
		[metadata reference]
	quantity NonNegativeQuantity (1..1) <"The quantity to be allocated to the party.">


type AllocationOutcome: <"A class to specify the allocated outcome as the combination of the previous Trade, which is either an execution or a contract and which state is specified as 'Allocated', and a set of Trade(s) of the same execution or contract type as before allocation. The allocation to one single trade is deemed appropriate: e.g. the trade could be effectively allocated from the fund manager doing the execution to a single fund entity.">
	originalTrade Trade (1..1)
		[synonym Workflow_Event value "originalTrade"]
	allocatedTrade Trade (1..*)
		[synonym Workflow_Event value "allocatedTrade"]
	// TODO: move these data rule as a "post-condition" to the Allocation "Function Spec"
	condition AllocationOutcome_executionClosed: <"The allocation outcome must result in execution state of 'Allocated' for an execution.">
		if AllocationOutcome exists and AllocationOutcome -> originalTrade -> execution exists
		then AllocationOutcome -> originalTrade -> execution -> closedState -> state = ClosedStateEnum -> Allocated
	condition AllocationOutcome_contractClosed: <"The allocation outcome must result in a contract state of 'Allocated' for a contract.">
		if AllocationOutcome exists and AllocationOutcome -> originalTrade -> contract exists
		then AllocationOutcome -> originalTrade -> contract -> closedState -> state = ClosedStateEnum -> Allocated

type CashTransferBreakdown extends TransferBreakdown:
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">
	amount Money (1..1) <"The currency amount of the payment.">
		[synonym Workflow_Event value "amount"]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">
		[synonym Workflow_Event value "cashflowType"]

type CashTransferComponent extends TransferBase:
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">
	amount Money (1..1) <"The currency amount.">
		[synonym Workflow_Event value "amount"]
		[synonym DTCC_11_0, DTCC_9_0 value "paymentAmount"]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">
		[synonym Workflow_Event value "cashflowType"]
		[synonym DTCC_11_0, DTCC_9_0 value "cashflowType" path "calculationDetails->grossCashflow" meta "cashflowTypeScheme"]
	breakdown CashTransferBreakdown (0..*) <"The cash transfer breakdown, when the transfer corresponds to a net amount across several components which breakdown is deemed relevant (e.g. the net cash transfer related to several contracts, or to the net proceeds across several payout components).">
		[synonym Workflow_Event, DTCC_11_0, DTCC_9_0 value "breakdown"]

/*
 * TODO - The commodity transfer component and its associated breakdown should be deemed as sample implementations,
 * which need to be confirmed through relevant user stories and use cases
 */
type CommodityTransferBreakdown extends TransferBreakdown:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	commodity Commodity (1..1)
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">
	timeUnit TimeUnitEnum (0..1)

type CommodityTransferComponent extends TransferBase:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	commodity Commodity (1..1)
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">
	timeUnit TimeUnitEnum (0..1)
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">
	breakdown CommodityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">
		[synonym Workflow_Event value "breakdown"]

type ComputedAmount: <"A class to specify the outcome of a computed amount, for testing purposes.">
	callFunction calculation (1..1)
	amount number (1..1)
	currency string (0..1) <"The currency in which the computed amount is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[metadata scheme]
		[synonym Workflow_Event value "currency" meta "currencyScheme"]

type ContractState: <"A class to specify a contract state instantiation with respect to the before and/or after state of lifecycle events.">
	contract Contract (1..1) <"Reference to the original contract, such that the contract state can be resolved by super-imposing the updated values on top of the original contract.">
		[synonym Workflow_Event value "trade"]
		[synonym DTCC_11_0, DTCC_9_0 value "FpML" path "Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value "TradeMsg" path "Manifest"]
		[synonym DTCC_11_0, DTCC_9_0 value "ReportingJurisdiction" path "ReportingData->ReportingHeader"]
		[synonym CME_SubmissionIRS_1_0 value "FpML" path "Instrmt->SecXML"]
	updatedContract Contract (0..1) <"The state of the contract, represented as a replica of the original contract with updated values where applicable, e.g. in the case of resets.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0 value "ignore"]

//TODO: Check that the updated contract in the contract state matches the original reference contract, except for updated (reset) values.
// data rule ContractState_contract
/* NOT USED
 *     class CreditLimit <"A class to specify the credit limit, to be used in the context of the clearing workflow.">
 * 	[synonym FpML_5_10 value "CreditLimit"]
 * {
 * 	limitId string (0..1) scheme;
 * 		[synonym FpML_5_10 value "limitId" meta "creditLimitIdScheme"]
 * 	applicableProduct ProductIdentification (0..1) <"Further to the FpML standard, the CDM ProductIdentification provides the ability to associate a CDM qualified product.">
 * 	currency string (0..1) scheme <"The currency in which the credit limit is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
 * 		[synonym FpML_5_10 value "currency" meta "currencyScheme"]
 * 	tenor Period (0..1) <"The maximum allowed tenor for a trade under this limit. When this structure is used as part of a suspendCredit message, this tenor imposes a temporary tenor limit on allowed trade types.">
 * 		[synonym FpML_5_10 value "tenor"]
 * 	limitApplicable LimitApplicable (0..*)
 * 		[synonym FpML_5_10 value "limitApplicable"]
 * 	expirationDateTime BusinessCenterTime (0..1) <"The CDM naming include the time suffix because the FpML element is actually of type dateTime. Also, the attribute is of type BusinessCenterTime because of the design decision to only have time that are specified by reference to a timezone, with that class being deemed the proper implementation.">
 * 		[synonym FpML_5_10 value "expirationDate"]
 * }
 */
type CreditLimitInformation: <"A class to represent the credit limit utilisation information.">
	[synonym CME_ClearedConfirm_1_17 value "CreditLimitInformation"]
	limitApplicable LimitApplicableExtended (1..*)
		[synonym CME_ClearedConfirm_1_17, Workflow_Event value "limitApplicable"]

type CreditLimitUtilisation: <"Credit limit utilisation breakdown by executed trades and pending orders.">
	[synonym FpML_5_10 value "CreditLimitUtilization"]
	executed CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to executed trades.">
		[synonym FpML_5_10 value "executed"]
	pending CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to pending unexecuted orders.">
		[synonym FpML_5_10 value "pending"]

type CreditLimitUtilisationPosition:
	[synonym FpML_5_10 value "CreditLimitUtilizationPosition"]
	shortPosition number (0..1) <"Credit limit utilisation attributable to short positions.">
		[synonym FpML_5_10 value "short"]
	longPosition number (0..1) <"Credit limit utilisation attributable to long positions.">
		[synonym FpML_5_10 value "long"]
	global number (0..1) <"Global credit limit utilisation amount, agnostic of long/short position direction.">
		[synonym FpML_5_10 value "global"]

type Curve: //one of
	interestRateCurve InterestRateCurve (0..1)
		[synonym Workflow_Event value "interestRateCurve"]
	commodityCurve CommodityReferencePriceEnum (0..1) // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
		[metadata scheme]
		[synonym Workflow_Event value "commodityCurve" meta "commodityReferencePriceScheme"]
	condition Curve: one-of

type CustomisedWorkflow: <"In its initial iteration, this class is meant to support the DTCC TIW workflow information.">
	itemName string (1..1) <"In this initial iteration, this corresponds to the DTCC TIW element name.">
		[synonym DTCC_11_0, DTCC_9_0 set to "comment" when path = "PartyWorkflowFields->comment"]
		[synonym DTCC_11_0, DTCC_9_0 set to "superId" when path = "PartyWorkflowFields->superId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "deskId" when path = "PartyWorkflowFields->deskId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "eTradeId" when path = "PartyWorkflowFields->eTradeId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "designatedParty" when path = "PartyWorkflowFields->designatedParty"]
		[synonym DTCC_11_0, DTCC_9_0 set to "brokerName" when path = "PartyWorkflowFields->brokerName"]
		[synonym DTCC_11_0, DTCC_9_0 set to "branchLocation" when path = "PartyWorkflowFields->branchLocation"]
		[synonym DTCC_11_0, DTCC_9_0 set to "midMarketPriceType" when path = "PartyWorkflowFields->midMarketPrice->midMarketPriceType"]
		[synonym DTCC_11_0, DTCC_9_0 set to "amount" when path = "PartyWorkflowFields->midMarketPrice->amount"]
		[synonym CME_SubmissionIRS_1_0 set to "ClientOrderId" when path = "ClOrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "TradeOriginationSystem" when path = "InptSrc"]
		[synonym CME_SubmissionIRS_1_0 set to "OriginatingTradeId" when path = "OrigTrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "ExecutionTime" when path = "TrdRegTS->TS" and "TrdRegTS->Typ" = "1"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyType" when path = "Pty->R"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyIdentifier" when path = "Pty->Src"]
	itemValue string (1..1) <"In this initial iteration, this corresponds to the DTCC value.">
		[synonym DTCC_11_0, DTCC_9_0 value "comment" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "superId" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "deskId" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "eTradeId" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "designatedParty" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "brokerName" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "branchLocation" path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value "midMarketPriceType" path "PartyWorkflowFields->midMarketPrice"]
		[synonym DTCC_11_0, DTCC_9_0 value "amount" path "PartyWorkflowFields->midMarketPrice"]
		[synonym CME_SubmissionIRS_1_0 value "ClOrdID"]
		[synonym CME_SubmissionIRS_1_0 value "InptSrc"]
		[synonym CME_SubmissionIRS_1_0 value "OrigTrdID"]
		[synonym CME_SubmissionIRS_1_0 value "TS" path "TrdRegTS"]
		[synonym CME_SubmissionIRS_1_0 set to "Customer Account" when "Pty->R" = "24"]
		[synonym CME_SubmissionIRS_1_0 set to "Custom" when "Pty->Src" = "D"]

type WorkflowEvent: <"A class to specify the lifecycle event. The associated rosettaKey denotes the ability to associate a hash value to the Event instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[rootType]
	[synonym Workflow_Event meta "id"]
	businessEvent BusinessEvent (1..1)
		[synonym Workflow_Event hint "primitive"]
	messageInformation MessageInformation (0..1)
		[synonym DTCC_11_0, DTCC_9_0 value "FpML" path "Body->OTC_Matching->Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value "FpML" path "Body->OTC_Matching->Payment"]
		[synonym DTCC_11_0, DTCC_9_0 value "RouteInfo" path "Header->OTC_RM->Delivery"]
		[synonym DTCC_11_0, DTCC_9_0 value "Manifest" path "Header->OTC_RM"]
		[synonym CME_ClearedConfirm_1_17 value "header" path "clearingConfirmed"]
	timestamp EventTimestamp (1..*) <"The set of timestamp(s) associated with the event as a collection of [dateTime, qualifier].">
		[synonym Workflow_Event value "timestamp"]
		[synonym DTCC_11_0, DTCC_9_0 value "header" path "Body->OTC_Matching->Trade->FpML"]
		[synonym DTCC_11_0, DTCC_9_0 value "Route" path "Header->OTC_RM->Delivery->RouteHist"]
		[synonym DTCC_11_0, DTCC_9_0 value "header" path "Body->OTC_Matching->Payment->FpML"]
		[synonym CME_ClearedConfirm_1_17 value "timestamps" path "clearingConfirmed->trade->tradeHeader"]
		[synonym CME_ClearedConfirm_1_17 value "header" path "clearingConfirmed"]
	eventIdentifier Identifier (1..*) <"The identifier(s) that uniquely identify a lifecycle event. The unbounded cardinality is meant to provide the ability to associate identifiers that are issued by distinct parties. As an example, each of the parties to the event may choose to associate their own identifiers to the event.">
		[synonym Workflow_Event value "eventIdentifier"]
		[synonym DTCC_11_0, DTCC_9_0 value "Submitter" path "Header->OTC_RM->Manifest->TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value "ContraTradeId" path "Header->OTC_RM->Manifest->TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value "YourTradeId" path "Header->OTC_RM->Manifest->TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value "tradeIdentifyingItems" path "Header->OTC_RM->Manifest->TradeMsg"]
	eventQualifier eventType (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic which qualifies the lifecycle event as a function of its features (e.g. PartialTermination, ClearingSubmission, Novation, ...).">
	eventDate date (1..1) <"The date on which the event is taking place. This is the equivalent of the trade date in the case of an execution or a contract.">
		[synonym Workflow_Event value "eventDate"]
		[synonym CME_ClearedConfirm_1_17 value "clearedDate" path "clearingConfirmed->trade->tradeHeader" maps 2]
	effectiveDate date (0..1) <"The date on which the event contractually takes effect, when different from the event date.">
		[synonym Workflow_Event value "effectiveDate"]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">
		[synonym Workflow_Event
			set to ActionEnum -> New when "isCorrection" = False,
			set to ActionEnum -> Correct when "isCorrection" = True,
			set to ActionEnum -> Cancel when "isRetraction" = True]
		[synonym FpML_5_10
			set to ActionEnum -> New when "isCorrection" = False,
			set to ActionEnum -> Correct when "isCorrection" = True]
		[synonym DTCC_11_0, DTCC_9_0 value "Activity" path "Header->OTC_RM->Manifest->TradeMsg"]
		[synonym CME_SubmissionIRS_1_0 value "TransTyp" path "TrdCaptRpt"]
	intent IntentEnum (0..1) <"The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from the event features. As a result it is only associated with those primitives that can give way to such ambiguity, the quantityChange being one of those. An example of such is a reduction in the trade notional, which could be interpreted as either a trade correction (unless a maximum period of time post-event is specified as part of the qualification), a partial termination or a portfolio rebalancing in the case of an equity swap. On the other hand, an event such as the exercise is not expected to have an associated intent as there should not be ambiguity.">
		[synonym Workflow_Event value "intent"]
	party Party (0..*) <"The specification of the event parties. This attribute is optional, as not applicable to certain events (e.g. most of the observations).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value "party"]
		[synonym DTCC_11_0, DTCC_9_0 value "party" path "Body->OTC_Matching->Trade->FpML" ]
		[synonym DTCC_11_0, DTCC_9_0 value "party" path "Body->OTC_Matching->Payment->FpML" ]
	account Account (0..*) <"Optional account information that could be associated to the event.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0 value "account"]
		[synonym CME_ClearedConfirm_1_17 value "account" path "clearingConfirmed"]
	lineage Lineage (0..1) <"The lineage attribute provides a linkage among lifecycle events through the rosettaKey hash value. One example is when a given lifecycle event is being corrected or cancelled. In such case, each subsequent event will have lineage into the prior version of that event. The second broad use case is when an event has a dependency upon either another event (e.g. the regular payment associated with a fix/float swap will have a lineage into the reset event, which will in turn have a lineage into the observation event for the floating rate and the contract) or a contract (e.g. the exercise of an option has a lineage into that option).">
		[synonym Workflow_Event value "lineage"]
	functionCall string (0..1) <"This is placeholder concept for a function call into a calculation that will return an outcome. This concept needs to be further firmed out.">
		[synonym Workflow_Event value "functionCall"]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, novation events), listed products (from, say, a bond option exercise event) values and more. Those are represented through a set of rosettaKey references. This attribute is optional in order to provide implementers with the ability not to make use of this feature.">
	workflowEventState WorkflowEventState (0..1) <"The event workflow information, i.e. the workflow status, the associated comment and the partyCustomisedWorkflow which purpose is to provide the ability to associate custom workflow information to the CDM.">

	condition Event_intent: <"The intent should only be associated with the primitives which use can lead to ambiguity with respect to the qualification of the event.">
		if (WorkflowEvent -> businessEvent -> primitives -> allocation exists
			or WorkflowEvent -> businessEvent -> primitives -> exercise exists
			or WorkflowEvent -> businessEvent -> primitives -> inception exists
			or WorkflowEvent -> businessEvent -> primitives -> observation exists
			or WorkflowEvent -> businessEvent -> primitives -> reset exists)
		then WorkflowEvent -> intent is absent

type BusinessEvent: <"A business event is a collection of primitive events.">
	primitives PrimitiveEvent (1..*) <"The elemental component(s) that specify the lifecycle events. Each of the primitive/elemental components listed as part of the PrimitiveEvent class has distinctive features that allow to specify the lifecycle event, either by itself or in combination with some other of such components.">
		[synonym Workflow_Event hint "primitive"]

type EventEffect: <"The set of operational and positional effects associated with a lifecycle event, alongside the reference to the contract reference(s) that is subject to the event (and is positioned in the before state of the event primitive).">
	effectedContract Contract (0..*) <"A pointer to the contract(s) to which the event effect(s) apply, i.e. in the before event state.">
		[metadata reference]
	effectedExecution Execution (0..*) <"A pointer to the execution(s) to which the event effect(s) apply, i.e. in the before event state.">
		[metadata reference]
	contract Contract (0..*) <"A pointer to the contract effect(s), an example of such being the outcome of a new trade, swaption exercise or novation event.">
		[metadata reference]
	execution Execution (0..*) <"A pointer to the execution effect(s), an example of such being a clearing submission event when taking place on the back of an execution.">
		[metadata reference]
	productIdentifier ProductIdentifier (0..*) <"A pointer to the product identifier effect(s), an example of such being the outcome of the physical exercise of a bond option.">
		[metadata reference]
	transfer TransferPrimitive (0..*) <"A pointer to the transfer effect(s), either a cash, security or other asset.">
		[metadata reference]

/* USED in downstrem */
type EventTestBundle: <"A class which combines several events for testing purposes.">
	event WorkflowEvent (2..*)
		[synonym Workflow_Event value "event"]
	computedAmount ComputedAmount (0..*)
		[synonym Workflow_Event value "computedAmount"]

type EventTimestamp: <"A class to represent the various set of timestamps that can be associated with lifecycle events, as a collection of [dateTime, qualifier].">
	dateTime zonedDateTime (1..1) <"The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">
		[synonym Workflow_Event, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value "creationTimestamp"]
		[synonym Workflow_Event, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value "expiryTimestamp"]
		[synonym DTCC_11_0, DTCC_9_0 value "ReceiveTime"]
		[synonym CME_ClearedConfirm_1_17 value "submittedForClearing"]
		[synonym CME_SubmissionIRS_1_0 value "TxnTm" path "TrdCaptRpt"]
		[synonym CME_SubmissionIRS_1_0 value "Snt" path "TrdCaptRpt->Hdr"]
		[synonym CME_SubmissionIRS_1_0 value "TS" path "TrdCaptRpt->TrdRegTS"]
	qualification EventTimestampQualificationEnum (1..1) <"The timestamp qualifier is specified through an enumeration because the experience of integrating the DTCC and CME data representations suggests that a wide set of timestamps are currently utilized among service providers, while there is not at present an objective set of criteria that could help suggest a defined set of timestamps as part of the CDM. At some future point, one possible baseline could be developed from the review of the set of timestamps specified across regulatory regimes and regulations (incl. regulations such as high frequency trading). Also, the integration with a further set of implementations and the specification of business workflows such as clearing as part of the CDM development should help confirm the implementation approach in this respect.">
		[synonym Workflow_Event, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimestampQualificationEnum -> eventCreationDateTime when "creationTimestamp" exists]
		[synonym Workflow_Event, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimestampQualificationEnum -> eventExpirationDateTime when "expiryTimestamp" exists]
		[synonym CME_ClearedConfirm_1_17, Workflow_Event set to EventTimestampQualificationEnum -> clearingSubmissionDateTime when "submittedForClearing" exists]
		[synonym DTCC_11_0, DTCC_9_0 set to EventTimestampQualificationEnum -> eventSubmittedDateTime when "ReceiveTime" exists]
		[synonym CME_SubmissionIRS_1_0 set to EventTimestampQualificationEnum -> transactionCreationDateTime when path = "TrdCaptRpt->TxnTm"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimestampQualificationEnum -> eventSentDateTime when path= "TrdCaptRpt->Hdr->Snt"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimestampQualificationEnum -> executionDateTime when path= "TrdCaptRpt->TrdRegTS->TS" and "TrdCaptRpt->TrdRegTS->Typ" = 1]

type WorkflowEventState: <"A class to specify workflow information, which is conceptually applicable to all lifecycle events.">
	workflowStatus WorkflowStatusEnum (0..*) <"The workflow status indicator, e.g. Accepted, Rejected, ...">
		[synonym CME_SubmissionIRS_1_0 value "RptTyp" path "TrdCaptRpt"]
		[synonym Workflow_Event value "workflowStatus"]
		[synonym CME_ClearedConfirm_1_17 value "status" path "clearingConfirmed->trade->tradeHeader"]
	comment string (0..1) <"A comment field to be associated with the workflow, e.g. to specify why a transaction event was rejected by a party.">
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Workflow data that is specific to certain market participants and is expressed as part of the CDM in a very generic manner, which can be party-specific. The initial use cases have been derived from the CME clearing and the DTCC TIW submissions.">
		[synonym CME_SubmissionIRS_1_0 value "RptSide" path "TrdCaptRpt"]

type CashExercise: <"The cash exercise specifies the cashflow using the cashflow payout and a given quantity.">

	cashflow Cashflow (1..1) <"Cashflow payout specification, excluding the quantity.">
	quantity QuantityNotation (1..1) <"Quantity of the cashflow payout.">

type ExerciseOutcome: <"The exercise outcome combines the option contract (which states would be 'Exercised' in case of a full exercise and which would have a reduced notional in case of partial exercise) and either a physical or partial exercise.">
	contract Contract (1..1)
		[synonym Workflow_Event value "contract"]
	physicalExercise PhysicalExercise (0..1)
		[synonym Workflow_Event value "physicalExercise"]
	cashExercise CashExercise (0..1)
		[synonym Workflow_Event value "cashExercise"]
	condition ExerciseOutcome_choice: <"A option exercise results in either a physical or a cash exercise.">
		required choice physicalExercise, cashExercise

type ExecutionState: <"A class to specify an execution instantiation with respect to the before and/or after state of lifecycle events.">
	execution Execution (1..1)
		[synonym Workflow_Event value "execution"]


type InterestRateCurve:
	floatingRateIndex FloatingRateIndexEnum (1..1)
		[metadata scheme]
		[synonym Workflow_Event value "floatingRateIndex" meta "floatingRateIndexScheme"]
	tenor Period (1..1)
		[synonym Workflow_Event value "tenor"]

type LimitApplicable:
	[synonym FpML_5_10 value "LimitApplicable"]
	limitType CreditLimitTypeEnum (0..1) <"Standard code to indicate which type of credit line is being referred to - i.e. IM, DV01, PV01, CS01, Notional, Clip Size, Notional, maximumOrderQuantity.">
		[metadata scheme]
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Workflow_Event value "limitType" meta "creditLimitTypeScheme"]
	clipSize int (0..1) <"This element is required in FpML, optional in CDM for the purpose of accommodating the CME data representation while making reference to the FpML one.">
		[synonym FpML_5_10 value "clipSize"]
	amountUtilized number (0..1) <"The limit utilised by all the cleared trades for the limit level and limit type. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Workflow_Event value "amountUtilized"]
	utilization CreditLimitUtilisation (0..1)
		[synonym FpML_5_10 value "utilization"]
	amountRemaining number (0..1) <"The limit remaining for the limit level and limit type. This does not take into account any pending trades. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Workflow_Event value "amountRemaining"]
	currency string (0..1) <"The currency in which the applicable limit is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[metadata scheme]
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Workflow_Event value "currency" meta "currencyScheme"]
	velocity Velocity (0..1)
		[synonym FpML_5_10 value "velocity"]
	condition LimitApplicable_choice: <"Choice rule to represent an FpML choice construct.">
		optional choice amountUtilized, utilization


type LimitApplicableExtended extends LimitApplicable: <"A class to represent the CDM attributes that are not part of the FpML standard. Once broader usage is confirmed, it is expected that those two classes can be collapsed.">
	[synonym CME_ClearedConfirm_1_17 value "CreditLimitInformation"]
	limitLevel LimitLevelEnum (0..1) <"The level at which the limit is set: customer business, proprietary business or account level. This attribute is specified as a string as part of the CME clearing confirmation specification.">
		[metadata scheme]
		[synonym CME_ClearedConfirm_1_17, Workflow_Event value "level" meta "creditLimitLevelScheme"]
	limitAmount number (0..1) <"The total limit available for the limit level and limit type. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym CME_ClearedConfirm_1_17, Workflow_Event value "limitAmount"]
	limitImpactDueToTrade number (0..1) <"The limit utilized by this specific trade. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym CME_ClearedConfirm_1_17, Workflow_Event value "limitImpactDueToTrade"]

type Lineage: <"A class to provide lineage information across lifecycle events through a pointer or set of pointers into the event(s), contract(s) and, possibly, payout components that the event is dependent on or relates to. As an example, if an inception event is corrected, the correction event will have a lineage into the initial event, which takes the form of a rosettaKey into that initial inception event. Two referencing mechanisms are provided as part of the CDM: either the rosettaKey, which corresponds to the hash value of the CDM class which is referred to, or a reference qualifier which is meant to provide support for the ingestion of xml documents with id/href mechanisms. The CDM recommends the use of the rosettaKey and provides a default implementation which is accessible in the generated code through org.isda.cdm.rosettakey.RosettaKeyValueHashFunction. If implementers want to use an alternative hashing mechanism, the API in which they need to plug it is com.rosetta.model.lib.HashFunction.">
	contractReference Contract (0..*) <"The reference to the instantiation of a Contract object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "contractReference" meta "href"]
	eventReference WorkflowEvent (0..*) <"The reference to the instantiation of an Event object, either through a rosettaKey or an xml-derived id/href mechanism. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "eventReference" meta "href"]
	executionReference Execution (0..*) <"The reference to the instantiation of a Execution object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "executionReference" meta "href"]
	cashflowReference Cashflow (0..*) <"The reference to the instantiation of a Cashflow payout component object. An expected typical usage is to provide lineage for the payment of, say, the option premium or the swap initial fee. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "cashflowReference" meta "href"]
	creditDefaultPayoutReference CreditDefaultPayout (0..*) <"The reference to the instantiation of a CreditdefaultPayout component object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "creditDefaultReference" meta "href"]
	interestRatePayoutReference InterestRatePayout (0..*) <"The reference to the instantiation of a InterestRatePayout component object. An expected typical usage is to provide lineage for the payment of, say, an interest rate swap reset, with the ability to relate the gross cashflow amounts to the respective payout components. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "interestRatePayoutReference" meta "href"]
	optionPayoutReference OptionPayout (0..*) <"The reference to the instantiation of a OptionPayout component object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "optionPayoutReference" meta "href"]
	equityPayoutReference EquityPayout (0..*) <"The reference to the instantiation of a EquityPayout object. An expected typical usage is to provide lineage for the payment of, say, an equity dividend. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "equityPayoutReference" meta "href"]
	transferReference TransferPrimitive (0..*) <"The reference to the instantiation of a TransferPrimitive object.">
		[metadata reference]
		[synonym Workflow_Event value "transferReference" meta "href"]
	legalAgreement LegalAgreement (0..*) <"The reference to the instantiation of a Legal Agreement object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
	portfolioStateReference PortfolioState (0..*) <"The refence to the previous state of a Portfolio, in a chain of Events leading up to a build of that Portfolio as the holding of Product(s) in specific Quantity(ies). As part of the PortfolioState object, a pointer to the previous PortfolioState is provided through a Lineage object, together with pointer(s) to the Event or set of Events leading up to the current (new) state.">
		[metadata reference]

type MessageInformation: <"This class corresponds to the components of the FpML MessageHeader.model.">
	messageId string (1..1) <"A unique identifier assigned to the message.">
		[metadata scheme]
		[synonym Workflow_Event value "messageId" path "messageInformation" meta "messageIdScheme"]
		[synonym DTCC_11_0, DTCC_9_0 value "messageId" path "header" meta "messageIdScheme"]
		[synonym CME_ClearedConfirm_1_17 value "messageId" meta "messageIdScheme"]
	sentBy string (0..1) <"The identifier for the originator of a message instance.">
		[metadata scheme]
		[synonym Workflow_Event value "sentBy" path "messageInformation" meta "messageAddressScheme"]
		[synonym DTCC_11_0, DTCC_9_0 value "From"]
		[synonym CME_ClearedConfirm_1_17 value "sentBy" meta "messageAddressScheme"]
		[synonym CME_SubmissionIRS_1_0 value "SSub" path "TrdCaptRpt->Hdr"]
	sentTo string (0..*) <"The identifier(s) for the recipient(s) of a message instance.">
		[metadata scheme]
		[synonym Workflow_Event value "sentTo" path "messageInformation" meta "messageAddressScheme"]
		[synonym CME_ClearedConfirm_1_17 value "sendTo" meta "messageAddressScheme"]
		[synonym DTCC_11_0, DTCC_9_0 value "To"]
		[synonym CME_SubmissionIRS_1_0 value "TID" path "TrdCaptRpt->Hdr"]
	copyTo string (0..*) <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">
		[metadata scheme]

type ObservationSource: <"The observation source can be composed of an curve and/or and information source.">
	curve Curve (0..1)
		[synonym Workflow_Event value "curve"]
	informationSource InformationSource (0..1)
		[synonym Workflow_Event value "informationSource"]
	condition ObservationSource_content: <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
		if ObservationSource exists
		then (ObservationSource -> curve exists and ObservationSource -> informationSource exists)
			or ObservationSource -> curve exists
			or ObservationSource -> informationSource exists

type PartyCustomisedWorkflow: <"A class to specify a party-related, non-standardized data in a generic form.">
	partyReference Party (0..1) <"Reference to the party to which the workflow pertains to.">
		[metadata reference]
		[synonym DTCC_11_0, DTCC_9_0 value "partyReference" meta "href"]
	partyName string (0..1) <"The party name to which the workflow pertains to.">
		[synonym CME_SubmissionIRS_1_0 value "ID" path "Pty"]
	customisedWorkflow CustomisedWorkflow (1..*) <"Non-standardized data in a generic form.">
	condition PartyCustomisedWorkflow_choice: <"The identification of the party to which the PartyCustomisedWorkflow pertains to can be done through either a party reference or the party name.">
		required choice partyName, partyReference

type PhysicalExercise: <"The physical exercise results into a financial product which is represented through the Product class, with an associated quantity and cashflow (e.g. a physical exercise of a bond option will result into a bond with a cash proceed which will be a function of the option strike price).">
	product Product (1..1)
		[synonym Workflow_Event value "product"]
	quantity Quantity (0..1) <"The quantity associated the asset that is physically settled. This quantity should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
		[synonym Workflow_Event value "quantity"]
	contractualQuantity ExecutionQuantity (0..1) <"Complex attribute to specify the quantity of the contractual product that is being exercised. This temporarily makes uses of the 'ExecutionQuantity' class, until such time when the latter can be renamed as, and supersede, the existing 'ContractualQuantity' class. To be later merged with the 'quantity' attribute to have consistent mechanism between contractual and non-contractual products.">
		// For Swap Stream:
		[synonym Workflow_Event value "swap" path "product"]
		[synonym Workflow_Event hint "cashflow"]
	cashflow Cashflow (0..1) <"The cashflow component of the physical exercise.">
		[synonym Workflow_Event value "cashflow"]
	condition PhysicalExercise_quantity: <"The quantity attribute should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
		if PhysicalExercise -> product -> contractualProduct exists
		then PhysicalExercise -> quantity is absent

type PostInceptionState extends ContractState:
	creditLimitInformation CreditLimitInformation (0..1) <"Credit limit utilization information.">
		[synonym CME_ClearedConfirm_1_17 value "creditLimitInformation" path "trade->tradeHeader"]
		[synonym Workflow_Event value "creditLimitInformation"]
	tradeWarehouseWorkflow TradeWarehouseWorkflow (0..1) <"Information related to trade warehouse workflow.">


type SecurityTransferBreakdown:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	security Security (1..*) <"The securities that are being transfered">
		[synonym Workflow_Event value "security"]
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]

type SecurityTransferComponent extends TransferBase:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	security Security (1..1) <"The security that is being transfered">
		[synonym Workflow_Event value "security"]
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]
	assetTransferType AssetTransferTypeEnum (0..1) // The relevance of this attribute and the associated values need to be confirmed"
		[synonym Workflow_Event value "assetTransferType"]
	breakdown SecurityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">
		[synonym Workflow_Event value "breakdown"]


//one of
type Trade: <"A class to represent the general trade concept, which can either be an execution or a contract. The execution consists essentially in the economic terms which are agreed between the parties. The contract will further qualify those with the legal entities (think of the allocation case, which execution state can involve the investment adviser rather not the actual funds) while not specify the master agreement or collateral terms which might be associated with the subsequent contract.">
	execution Execution (0..1) <"The execution corresponds to economic terms that are agreed between parties, but which legal terms are not yet specified. The execution attribute applies to the post-execution scenario of a product that is subject to the clearing mandate and is then routed to the CCP as an execution.">
		[synonym CME_SubmissionIRS_1_0 value "TrdCaptRpt" set when "TrdCaptRpt->VenuTyp" exists]
		[synonym Workflow_Event value "trade" set when "trade->executionType" exists]
	contract Contract (0..1) <"The contract differs from the execution by the fact that its legal terms are fully specified. This includes the legal entities that are associated to it as well as any associated legal agreement, e.g. master agreement, credit and collateral terms, ... ">
		[synonym DTCC_11_0, DTCC_9_0 value "FpML" path "Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value "TradeMsg" path "Manifest"]
		[synonym DTCC_11_0, DTCC_9_0 value "ReportingJurisdiction" path "ReportingData->ReportingHeader"]
		[synonym Workflow_Event value "trade" set when "trade->executionType" is absent]
		[synonym CME_SubmissionIRS_1_0 value "TrdCaptRpt" set when "TrdCaptRpt->VenuTyp" is absent]
	condition Trade: one-of

type TradeWarehouseWorkflow: <"A class to specify trade warehouse workflow information: the identity of the trade warehouse, the contract status at the warehouse and party-specific workflow information.">
	warehouseIdentity WarehouseIdentityEnum (1..1)
		[synonym DTCC_11_0, DTCC_9_0 value "WarehousePositionType" path "WarehouseState"]
	warehouseStatus WorkflowStatusEnum (1..1)
		[synonym DTCC_11_0, DTCC_9_0 value "WarehouseStatus" path "WarehouseState"]
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Non-standardized workflow data related to a party.">
		[synonym DTCC_11_0, DTCC_9_0 value "WorkflowData"]
		[synonym CME_SubmissionIRS_1_0 value "ignore"]

type TransferBase:
	identifier string (0..1) <"The identifier that can be associated with each of the transfer components">
		[metadata scheme]
		[synonym DTCC_11_0, DTCC_9_0 value "identifier" meta "paymentIdScheme"]
	transferCalculation TransferCalculation (0..1) <"The calculation details underlying the transfer amount, when applicable.">
		[synonym DTCC_11_0, DTCC_9_0 value "calculationDetails"]

type TransferCalculation:
	period CalculationPeriodBase (0..1 ) <"The period adjusted start and end dates.">
		[synonym DTCC_11_0, DTCC_9_0 value "calculationPeriod" path "calculationElements"]
	lineage Lineage (0..*) <"The lineage into the components used for the calculation.">
	calculationOutcome calculation (0..1) <"This is a conceptual placeholder for providing the breakdown into the cashflow calculation components, leveraging the fact that the CDM provides calculation components, starting with the FixedAmount and the FloatingAmount. Further evaluation of expected usage needs to take place to confirm and prioritize such implementation.">
		[synonym Workflow_Event value "transferCalculation"]


type TransferBreakdown extends TransferBase:
	lineage Lineage (0..*) <"The lineage into the transfer components that might be associated with each of the transfer components.">
		[synonym Workflow_Event value "lineage"]

type TransferorTransferee: <"A class mimicking the PayerReceiver, which is itself derived from the FpML PayerReceiver.model, to represent the transferee and transferor party information in relation to the transfer of security or commodities.">
	transferorPartyReference Party (1..1) <"A reference to the party responsible for making the payments defined by this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value "payerPartyReference" meta "href"]
	transferorAccountReference Account (0..1) <"A reference to the account responsible for making the payments defined by this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value "payerAccountReference" meta "href"]
	transfereePartyReference Party (1..1) <"A reference to the party that receives the payments corresponding to this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value "receiverPartyReference" meta "href"]
	transfereeAccountReference Account (0..1) <"A reference to the account that receives the payments corresponding to this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value "receiverAccountReference" meta "href"]

type Velocity:
	[synonym FpML_5_10 value "Velocity"]
	periodMultiplier int (0..1)
	period PeriodTimeEnum (0..1)

/*********************
 * Event Qualification
 */
func Allocation: <"The qualification of allocation event from the fact that (i) the intent is Allocation when specified, (ii) the only primitive is the allocation, (iii) the sum of quantities/notional before = after, and (iv) there is a single contractualProduct before (ensured through cardinality). Note: it is accepted that an allocation can result in a single contract.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> allocation exists

/*
 * TODO - The below syntax needs to be expanded to specify a summation
 * This could be specify as quantityBeforeAllocation = sum(quantityAfterAllocation)
 */
//	and quantityBeforeAllocation = quantityAfterAllocation
/*
 * Temporary event qualification until such time that we firm out the proper qualification and the way to infer it
 */
func CashflowCalculationNotification:
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> transfer exists
		and workflowEvent -> messageInformation -> sentBy = "DTCC"

func CashTransfer: <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> transfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> securityTransfer is absent
		and workflowEvent -> businessEvent -> primitives -> transfer -> commodityTransfer is absent
		and workflowEvent -> messageInformation -> sentBy <> "DTCC" // This is a kludge related to the CashflowCalculationNotification qualification

func CashAndSecurityTransfer: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> securityTransfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference
		-> reference = workflowEvent -> businessEvent -> primitives -> transfer -> securityTransfer -> transferorTransferee -> transferorPartyReference -> reference
		and workflowEvent -> businessEvent -> primitives -> transfer -> commodityTransfer is absent

// Simple Agency model for clearing
func ClearedTrade:
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 5
		and workflowEvent -> businessEvent -> primitives -> quantityChange count = 1
		and QuantityDecreasedToZero(workflowEvent -> businessEvent -> primitives -> quantityChange) = True
		and workflowEvent -> businessEvent -> primitives -> execution count = 2
		and workflowEvent -> businessEvent -> primitives -> contractFormation count = 2
		and workflowEvent -> businessEvent -> primitives -> execution -> after = workflowEvent -> businessEvent -> primitives -> contractFormation -> before
		// TODO - Add this back in when we correctly map the ClearingOrganization
		and workflowEvent -> businessEvent -> primitives -> contractFormation -> after -> contract -> partyRole -> role contains PartyRoleEnum -> ClearingOrganization

//isEvent ClearedTrade <"The cleared trade at the CCP.">
//	WorkflowEvent -> businessEvent -> primitives count = 1
//	and WorkflowEvent -> businessEvent -> primitives -> inception exists
//	and WorkflowEvent -> workflowEventState -> workflowStatus = WorkflowStatusEnum -> Cleared
/*
 * It is proposed to remove the below qualification for 2 reasons
 *  - Limit the scope of event qualification to evaluating what is available within the event, while the workflow rule evaluated across events
 *  - Not introduce the distinction between agency and principal model (with this latter having contracts between clearing members and clients)
 */
//	and Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
//	and Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearedTrade
func ClearingRejection: <"The rejection of an alpha trade submission by a CCP, which is qualified by the fact that (i) termsChange is the only primitive, the workflow status is `rejected`, and (iii) the CCP is positioned as a partyRole to the execution or contract in the after state, while it didn't exist in the before state.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> termsChange exists
		and workflowEvent -> workflowEventState -> workflowStatus = WorkflowStatusEnum -> Rejected
		and (workflowEvent -> businessEvent -> primitives -> termsChange -> before -> execution -> partyRole is absent
		or workflowEvent -> businessEvent -> primitives -> termsChange -> before -> execution -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization
		or workflowEvent -> businessEvent -> primitives -> termsChange -> before -> contract -> partyRole is absent
		or workflowEvent -> businessEvent -> primitives -> termsChange -> before -> contract -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization)
		and (workflowEvent -> businessEvent -> primitives -> termsChange -> after -> execution -> partyRole -> role = PartyRoleEnum -> ClearingOrganization
		or workflowEvent -> businessEvent -> primitives -> termsChange -> after -> contract -> partyRole -> role = PartyRoleEnum -> ClearingOrganization)
		and NoQuantityChange(workflowEvent -> businessEvent -> primitives -> quantityChange) = True

func ClearingSubmission: <"The submission of a contract to a CCP, which is qualified by the fact that (i) the termsChange is the only primitive, and (ii) the CCP is positioned as a partyRole to the execution or contract in the after state, while it didn't exist in the before state.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> termsChange exists
		and workflowEvent -> workflowEventState -> workflowStatus = WorkflowStatusEnum -> Submitted
		and (workflowEvent -> businessEvent -> primitives -> termsChange -> before -> execution -> partyRole is absent
		or workflowEvent -> businessEvent -> primitives -> termsChange -> before -> execution -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization
		or workflowEvent -> businessEvent -> primitives -> termsChange -> before -> contract -> partyRole is absent
		or workflowEvent -> businessEvent -> primitives -> termsChange -> before -> contract -> partyRole -> role <> PartyRoleEnum -> ClearingOrganization)
		and (workflowEvent -> businessEvent -> primitives -> termsChange -> after -> contract -> partyRole -> role = PartyRoleEnum -> ClearingOrganization
		or workflowEvent -> businessEvent -> primitives -> termsChange -> after -> execution -> partyRole -> role = PartyRoleEnum -> ClearingOrganization)

func Compression: <"The qualification of a compression event from the fact that (i) the quantityChange primitive exists, and (ii) there are multiple contracts (or contract references) specified in the before state.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> quantityChange exists
		and workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract multiple exists

func DerivedObservation: <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> observation only multiple exists
		and workflowEvent -> functionCall exists

func Exercise: <"The qualification of an exercise event from the fact that (i) the only primitive is the exercise, and (ii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> exercise exists

func Increase: <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		(workflowEvent -> intent is absent or workflowEvent -> intent = IntentEnum -> Increase)
		and (
			workflowEvent -> businessEvent -> primitives count = 1
			and workflowEvent -> businessEvent -> primitives -> quantityChange exists
			or (workflowEvent -> businessEvent -> primitives -> quantityChange exists
				and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer exists
			))
		and QuantityIncreased(workflowEvent -> businessEvent -> primitives -> quantityChange) = True
		and workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> closedState is absent

func MultipleTransfers: <"The qualification an event that combines multiple transfers from the fact that multiple transfer primitives exist.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> transfer multiple exists

func NewTrade:
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> inception exists
		and workflowEvent -> businessEvent -> primitives -> inception -> after -> tradeWarehouseWorkflow is absent
		and workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> closedState is absent
		and workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> clearedDate is absent

func Novation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> quantityChange exists
		and workflowEvent -> businessEvent -> primitives -> inception exists
		and QuantityDecreasedToZero(workflowEvent -> businessEvent -> primitives -> quantityChange) = True
		and workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum -> Novated
		and workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> contractIdentifier <> workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractIdentifier
		and workflowEvent -> eventDate = workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> tradeDate -> date
		and workflowEvent -> effectiveDate = NovatedContractEffectiveDate(workflowEvent) -> dates only-element

//	and originalContractParties <> newContractParties
func Observation: <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> observation only single exists

func PartialNovation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> quantityChange exists
		and workflowEvent -> businessEvent -> primitives -> inception exists
		and workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> contractIdentifier <> workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractIdentifier
		and workflowEvent -> eventDate = workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> tradeDate -> date
		and workflowEvent -> effectiveDate = NovatedContractEffectiveDate(workflowEvent) -> dates		
		and QuantityDecreased(workflowEvent -> businessEvent -> primitives -> quantityChange) = True

// and originalContractParties <> newContractParties
func PartialTermination: <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		(workflowEvent -> intent is absent or workflowEvent -> intent = IntentEnum -> PartialTermination)
		and (workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> quantityChange exists
			or (workflowEvent -> businessEvent -> primitives -> quantityChange exists
				and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer exists
			))
		and QuantityDecreased(workflowEvent -> businessEvent -> primitives -> quantityChange) = True
		and workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> closedState is absent

func IsReset: <"The qualification of a reset event from the fact that the only primitive is the reset.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent (1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> reset exists

func SecurityTransfer: <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> transfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> securityTransfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer is absent
		and workflowEvent -> businessEvent -> primitives -> transfer -> commodityTransfer is absent

func SecuritySettlement: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> securityTransfer exists
		and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference -> reference = workflowEvent -> businessEvent -> primitives -> transfer -> securityTransfer -> transferorTransferee -> transfereePartyReference -> reference
		and workflowEvent -> businessEvent -> primitives -> transfer -> commodityTransfer is absent

func Termination: <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		(workflowEvent -> intent is absent or workflowEvent -> intent = IntentEnum -> Termination)
		and (workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> quantityChange exists
			or (workflowEvent -> businessEvent -> primitives -> quantityChange exists
				and workflowEvent -> businessEvent -> primitives -> transfer -> cashTransfer exists)
			)
		and QuantityDecreasedToZero(workflowEvent -> businessEvent -> primitives -> quantityChange) = True
		and workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum -> Terminated

func TradeWarehousePositionNotification:
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives -> inception exists
		and workflowEvent -> businessEvent -> primitives -> inception -> after -> tradeWarehouseWorkflow exists

func Execution: <"The qualification of an execution event from the fact that the only component is an execution.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> execution exists

func ContractFormationEvent: <"The qualification of a contractFormation event from the fact that the only component is a contractFormation.">
	[qualification event]
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		workflowEvent -> businessEvent -> primitives count = 1
		and workflowEvent -> businessEvent -> primitives -> contractFormation exists

/****************
 * Workflow rules
 */
/*
 * workflow rule ClearedContractAgency_Participant <"The cross-events validity constraints to specify that a contract has been cleared according to the agency model from the perspective of the involved clearing member or client.">
 *
 *    Event <beta> is ClearingSubmission
 * 	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 *
 *    constraint is economicTerms are the same except for payerReceiver or buyerSeller
 *    and <alpha> contract/execution is terminated  *Difference*
 *    and event date of <alpha> submission = trade date of <beta>
 *    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta>
 */
/*
 * workflow rule ClearedContractAgency_CCP <"The cross-events validity constraints to specify that a contract has been cleared according to the agency model from the perspective of the involved clearing member or client.">
 *
 *    Event <beta> is ClearingSubmission
 * 	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 * 	and relatedTo <gamma> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearedTrade *Difference*
 *
 *    constraint is economicTerms are the same except for payerReceiver or buyerSeller
 *    and event date of <alpha> submission = trade date of <beta>
 *    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta> and <gamma> *Difference*
 */
/*
 * workflow rule ClearedContractPrincipal_Participant <"The cross-events validity constraints to specify that a contract has been cleared according to the principal model from the perspective of the involved clearing member or client.">
 *
 *   Event <beta> is ClearingSubmission
 * 	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 * 	relatedTo <theta> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.NewTrade or eventQualifier.ClearedTrade???? *Difference*

 *   constraint is economicTerms are the same except for payerReceiver or buyerSeller
 *   and <alpha> contract/execution is terminated  *Difference*
 *   and event date of <alpha> submission = trade date of <beta>
 *   and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta>
 */
/*
 * workflow rule ClearedContractPrincipal_CCP <"The cross-events validity constraints to specify that a contract has been cleared according to the principal model from the perspective of the involved clearing member or client.">
 *
 *    Event <beta> is ClearingSubmission
 * 	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 * 	and relatedTo <gamma> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearedTrade *Difference*
 *
 *    constraint is economicTerms are the same except for payerReceiver or buyerSeller
 *    and event date of <alpha> submission = trade date of <beta>
 *    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta> and <gamma> *Difference*
 */

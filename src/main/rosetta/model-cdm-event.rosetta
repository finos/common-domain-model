namespace "org.isda.cdm"
version "${project.version}"

data AllocationInstructions:
	// TODO: add other allocation context
    breakdowns AllocationBreakdown (1..*) <"The set of allocation breakdowns to be applied to a block trade">
 
data AllocationBreakdown:
    partyReference Party (1..1) <"Reference to the party to specify the account.">
    [metadata reference] 
    quantity Quantity (1..1) <"The quantity to be allocated to the party.">


data AllocationOutcome: <"A class to specify the allocated outcome as the combination of the previous Trade, which is either an execution or a contract and which state is specified as 'Allocated', and a set of Trade(s) of the same execution or contract type as before allocation. The allocation to one single trade is deemed appropriate: e.g. the trade could be effectively allocated from the fund manager doing the execution to a single fund entity.">
	originalTrade Trade (1..1)
		[synonym Rosetta_Workbench value originalTrade]
	allocatedTrade Trade (1..*)
		[synonym Rosetta_Workbench value allocatedTrade]
	
	// TODO: move these data rule as a "post-condition" to the Allocation "Function Spec"
	condition AllocationOutcome_executionClosed: <"The allocation outcome must result in execution state of 'Allocated' for an execution.">
		if AllocationOutcome exists and AllocationOutcome -> originalTrade -> execution exists
		then AllocationOutcome -> originalTrade -> execution -> closedState -> state = ClosedStateEnum.Allocated
	condition AllocationOutcome_contractClosed: <"The allocation outcome must result in a contract state of 'Allocated' for a contract.">
		if AllocationOutcome exists and AllocationOutcome -> originalTrade -> contract exists
		then AllocationOutcome -> originalTrade -> contract -> closedState -> state = ClosedStateEnum.Allocated

data AllocationPrimitive: <"The primitive event to represent a split/allocation of a trade. As part of this primitive event the type of trade, either an execution or a contract, does not get altered. In the case of an execution, the further transformation of each split execution into a contract will be the purpose of the ContractFormation primitive.">
	before Trade (1..1) <"The trade before allocation, which is either an execution if allocation happens before the contract is formed, or an already formed contract.">
		[synonym Rosetta_Workbench value before]
	after AllocationOutcome (1..1) <"Outcome of the allocation as a list of Trades, which is either a split execution or a split contract, plus a pointer to the previous execution or contract marked as 'Allocated'.">
		[synonym Rosetta_Workbench value after]
	
	// TODO: move these data rule as a "post-condition" to the Allocation "Function Spec"
	condition AllocationPrimitive_executionType: <"If the trade type pre-allocation is an execution, then the trade type post-allocation must also be an execution.">
		if AllocationPrimitive exists and AllocationPrimitive -> before -> execution exists
		then AllocationPrimitive -> after -> originalTrade -> execution exists
			and AllocationPrimitive -> after -> allocatedTrade -> execution exists
			and AllocationPrimitive -> after -> allocatedTrade -> contract is absent
	condition AllocationPrimitive_contractType: <"If the trade type pre-allocation is a contract, then the trade type post-allocation must also be a contract.">
		if AllocationPrimitive exists and AllocationPrimitive -> before -> contract exists
		then AllocationPrimitive -> after -> originalTrade -> contract exists
			and AllocationPrimitive -> after -> allocatedTrade -> contract exists
			and AllocationPrimitive -> after -> allocatedTrade -> execution is absent
	
data CashTransferBreakdown extends TransferBreakdown:
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">
	amount Money (1..1) <"The currency amount of the payment.">
		[synonym Rosetta_Workbench value amount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">
		[synonym Rosetta_Workbench value cashflowType]

data CashTransferComponent extends TransferBase:
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">
	amount Money (1..1) <"The currency amount.">
		[synonym Rosetta_Workbench value amount]
		[synonym DTCC_11_0, DTCC_9_0 value paymentAmount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">
		[synonym Rosetta_Workbench value cashflowType]
		[synonym DTCC_11_0, DTCC_9_0 value cashflowType path "calculationDetails.grossCashflow" meta cashflowTypeScheme]
	breakdown CashTransferBreakdown (0..*) <"The cash transfer breakdown, when the transfer corresponds to a net amount across several components which breakdown is deemed relevant (e.g. the net cash transfer related to several contracts, or to the net proceeds across several payout components).">
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0 value breakdown]

/*
 * TODO - The commodity transfer component and its associated breakdown should be deemed as sample implementations,
 * which need to be confirmed through relevant user stories and use cases
 */
data CommodityTransferBreakdown extends TransferBreakdown:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	commodity Commodity (1..1)
	quantity number (1..1)
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">
	timeUnit TimeUnitEnum (0..1)

data CommodityTransferComponent extends TransferBase:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	commodity Commodity (1..1)
	quantity number (1..1)
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">
	timeUnit TimeUnitEnum (0..1)
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">
	breakdown CommodityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">
		[synonym Rosetta_Workbench value breakdown]

data ComputedAmount: <"A class to specify the outcome of a computed amount, for testing purposes.">
	callFunction calculation (1..1)
	amount number (1..1)
	currency string (0..1) <"The currency in which the computed amount is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[metadata scheme]
		[synonym Rosetta_Workbench value currency meta currencyScheme]

data ContractState: <"A class to specify a contract state instantiation with respect to the before and/or after state of lifecycle events.">
	contract Contract (1..1) <"Reference to the original contract, such that the contract state can be resolved by super-imposing the updated values on top of the original contract.">
		[synonym Rosetta_Workbench value trade]
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value TradeMsg path "Manifest"]
		[synonym DTCC_11_0, DTCC_9_0 value ReportingJurisdiction path "ReportingData.ReportingHeader"]
		[synonym CME_SubmissionIRS_1_0 value FpML path "Instrmt.SecXML"]
	updatedContract Contract (0..1) <"The state of the contract, represented as a replica of the original contract with updated values where applicable, e.g. in the case of resets.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0 value ignore]

//TODO: Check that the updated contract in the contract state matches the original reference contract, except for updated (reset) values.
// data rule ContractState_contract
/* NOT USED
    class CreditLimit <"A class to specify the credit limit, to be used in the context of the clearing workflow.">
	[synonym FpML_5_10 value CreditLimit]
{
	limitId string (0..1) scheme;
		[synonym FpML_5_10 value limitId meta creditLimitIdScheme]
	applicableProduct ProductIdentification (0..1) <"Further to the FpML standard, the CDM ProductIdentification provides the ability to associate a CDM qualified product.">
	currency string (0..1) scheme <"The currency in which the credit limit is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[synonym FpML_5_10 value currency meta currencyScheme]
	tenor Period (0..1) <"The maximum allowed tenor for a trade under this limit. When this structure is used as part of a suspendCredit message, this tenor imposes a temporary tenor limit on allowed trade types.">
		[synonym FpML_5_10 value tenor]
	limitApplicable LimitApplicable (0..*)
		[synonym FpML_5_10 value limitApplicable]
	expirationDateTime BusinessCenterTime (0..1) <"The CDM naming include the time suffix because the FpML element is actually of type dateTime. Also, the attribute is of type BusinessCenterTime because of the design decision to only have time that are specified by reference to a timezone, with that class being deemed the proper implementation.">
		[synonym FpML_5_10 value expirationDate]
}
*/
data CreditLimitInformation: <"A class to represent the credit limit utilisation information.">
	[synonym CME_ClearedConfirm_1_17 value CreditLimitInformation]
	limitApplicable LimitApplicableExtended (1..*)
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitApplicable]

data CreditLimitUtilisation: <"Credit limit utilisation breakdown by executed trades and pending orders.">
	[synonym FpML_5_10 value CreditLimitUtilization]
	executed CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to executed trades.">
		[synonym FpML_5_10 value executed]
	pending CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to pending unexecuted orders.">
		[synonym FpML_5_10 value pending]

data CreditLimitUtilisationPosition:
	[synonym FpML_5_10 value CreditLimitUtilizationPosition]
	shortPosition number (0..1) <"Credit limit utilisation attributable to short positions.">
		[synonym FpML_5_10 value short]
	longPosition number (0..1) <"Credit limit utilisation attributable to long positions.">
		[synonym FpML_5_10 value long]
	global number (0..1) <"Global credit limit utilisation amount, agnostic of long/short position direction.">
		[synonym FpML_5_10 value global]

data Curve : //one of
	interestRateCurve InterestRateCurve (0..1)
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1) // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
		[metadata scheme]
		[synonym Rosetta_Workbench value commodityCurve meta commodityReferencePriceScheme]
	condition Curve: one-of

data CustomisedWorkflow: <"In its initial iteration, this class is meant to support the DTCC TIW workflow information.">
	itemName string (1..1) <"In this initial iteration, this corresponds to the DTCC TIW element name.">
		[synonym DTCC_11_0, DTCC_9_0 set to "comment" when path = "PartyWorkflowFields.comment"]
		[synonym DTCC_11_0, DTCC_9_0 set to "superId" when path = "PartyWorkflowFields.superId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "deskId" when path = "PartyWorkflowFields.deskId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "eTradeId" when path = "PartyWorkflowFields.eTradeId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "designatedParty" when path = "PartyWorkflowFields.designatedParty"]
		[synonym DTCC_11_0, DTCC_9_0 set to "brokerName" when path = "PartyWorkflowFields.brokerName"]
		[synonym DTCC_11_0, DTCC_9_0 set to "branchLocation" when path = "PartyWorkflowFields.branchLocation"]
		[synonym DTCC_11_0, DTCC_9_0 set to "midMarketPriceType" when path = "PartyWorkflowFields.midMarketPrice.midMarketPriceType"]
		[synonym DTCC_11_0, DTCC_9_0 set to "amount" when path = "PartyWorkflowFields.midMarketPrice.amount"]
		[synonym CME_SubmissionIRS_1_0 set to "ClientOrderId" when path = "ClOrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "TradeOriginationSystem" when path = "InptSrc"]
		[synonym CME_SubmissionIRS_1_0 set to "OriginatingTradeId" when path = "OrigTrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "ExecutionTime" when path = "TrdRegTS.TS" and "TrdRegTS.Typ" = "1"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyType" when path = "Pty.R"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyIdentifier" when path = "Pty.Src"]
	itemValue string (1..1) <"In this initial iteration, this corresponds to the DTCC value.">
		[synonym DTCC_11_0, DTCC_9_0 value comment path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value superId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value deskId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value eTradeId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value designatedParty path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value brokerName path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value branchLocation path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value midMarketPriceType path "PartyWorkflowFields.midMarketPrice"]
		[synonym DTCC_11_0, DTCC_9_0 value amount path "PartyWorkflowFields.midMarketPrice"]
		[synonym CME_SubmissionIRS_1_0 value ClOrdID]
		[synonym CME_SubmissionIRS_1_0 value InptSrc]
		[synonym CME_SubmissionIRS_1_0 value OrigTrdID]
		[synonym CME_SubmissionIRS_1_0 value TS path "TrdRegTS"]
		[synonym CME_SubmissionIRS_1_0 set to "Customer Account" when "Pty.R" = "24"]
		[synonym CME_SubmissionIRS_1_0 set to "Custom" when "Pty.Src" = "D"]

data Event :<"A class to specify the lifecycle event. The associated rosettaKey denotes the ability to associate a hash value to the Event instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	[synonym Rosetta_Workbench meta id]
	messageInformation MessageInformation (0..1)
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Payment"]
		[synonym DTCC_11_0, DTCC_9_0 value RouteInfo path "Header.OTC_RM.Delivery"]
		[synonym DTCC_11_0, DTCC_9_0 value Manifest path "Header.OTC_RM"]
		[synonym CME_ClearedConfirm_1_17 value header path "clearingConfirmed"]
	timestamp EventTimestamp (1..*) <"The set of timestamp(s) associated with the event as a collection of [dateTime, qualifier].">
		[synonym Rosetta_Workbench value timestamp]
		[synonym DTCC_11_0, DTCC_9_0 value header path "Body.OTC_Matching.Trade.FpML"]
		[synonym DTCC_11_0, DTCC_9_0 value Route path "Header.OTC_RM.Delivery.RouteHist"]
		[synonym DTCC_11_0, DTCC_9_0 value header path "Body.OTC_Matching.Payment.FpML"]
		[synonym CME_ClearedConfirm_1_17 value timestamps path "clearingConfirmed.trade.tradeHeader"]
		[synonym CME_ClearedConfirm_1_17 value header path "clearingConfirmed"]
	eventIdentifier Identifier (1..*) <"The identifier(s) that uniquely identify a lifecycle event. The unbounded cardinality is meant to provide the ability to associate identifiers that are issued by distinct parties. As an example, each of the parties to the event may choose to associate their own identifiers to the event.">
		[synonym Rosetta_Workbench value eventIdentifier]
		[synonym DTCC_11_0, DTCC_9_0 value Submitter path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value ContraTradeId path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value YourTradeId path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value tradeIdentifyingItems path "Header.OTC_RM.Manifest.TradeMsg"]
	eventQualifier eventType (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic which qualifies the lifecycle event as a function of its features (e.g. PartialTermination, ClearingSubmission, Novation, ...).">
	eventDate date (1..1) <"The date on which the event is taking place. This is the equivalent of the trade date in the case of an execution or a contract.">
		[synonym Rosetta_Workbench value eventDate]
		[synonym CME_ClearedConfirm_1_17 value clearedDate path "clearingConfirmed.trade.tradeHeader" maps 2]
	effectiveDate date (0..1) <"The date on which the event contractually takes effect, when different from the event date.">
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">
		[synonym Rosetta_Workbench
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True,
			set to ActionEnum.Cancel when "isRetraction" = True]
		[synonym FpML_5_10
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True]
		[synonym DTCC_11_0, DTCC_9_0 value Activity path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym CME_SubmissionIRS_1_0 value TransTyp path "TrdCaptRpt"]
	intent IntentEnum (0..1) <"The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from the event features. As a result it is only associated with those primitives that can give way to such ambiguity, the quantityChange being one of those. An example of such is a reduction in the trade notional, which could be interpreted as either a trade correction (unless a maximum period of time post-event is specified as part of the qualification), a partial termination or a portfolio rebalancing in the case of an equity swap. On the other hand, an event such as the exercise is not expected to have an associated intent as there should not be ambiguity.">
		[synonym Rosetta_Workbench value intent]
	party Party (0..*) <"The specification of the event parties. This attribute is optional, as not applicable to certain events (e.g. most of the observations).">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value party]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Trade.FpML" ]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Payment.FpML" ]
	account Account (0..*) <"Optional account information that could be associated to the event.">
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0 value account]
		[synonym CME_ClearedConfirm_1_17 value account path "clearingConfirmed"]
	lineage Lineage (0..1) <"The lineage attribute provides a linkage among lifecycle events through the rosettaKey hash value. One example is when a given lifecycle event is being corrected or cancelled. In such case, each subsequent event will have lineage into the prior version of that event. The second broad use case is when an event has a dependency upon either another event (e.g. the regular payment associated with a fix/float swap will have a lineage into the reset event, which will in turn have a lineage into the observation event for the floating rate and the contract) or a contract (e.g. the exercise of an option has a lineage into that option).">
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1) <"The elemental component(s) that specify the lifecycle events. Each of the primitive/elemental components listed as part of the PrimitiveEvent class has distinctive features that allow to specify the lifecycle event, either by itself or in combination with some other of such components.">
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1) <"This is placeholder concept for a function call into a calculation that will return an outcome. This concept needs to be further firmed out.">
		[synonym Rosetta_Workbench value functionCall]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, novation events), listed products (from, say, a bond option exercise event) values and more. Those are represented through a set of rosettaKey references. This attribute is optional in order to provide implementers with the ability not to make use of this feature.">
	eventWorkflow EventWorkflow (0..1) <"The event workflow information, i.e. the workflow status, the associated comment and the partyCustomisedWorkflow which purpose is to provide the ability to associate custom workflow information to the CDM.">

	condition Event_intent: <"The intent should only be associated with the primitives which use can lead to ambiguity with respect to the qualification of the event.">
		if ( Event -> primitive -> allocation exists
			or Event -> primitive -> exercise exists
			or Event -> primitive -> inception exists
			or Event -> primitive -> observation exists
			or Event -> primitive -> reset exists)
		then Event -> intent is absent

data EventEffect: <"The set of operational and positional effects associated with a lifecycle event, alongside the reference to the contract reference(s) that is subject to the event (and is positioned in the before state of the event primitive).">
	effectedContract Contract (0..*) <"A pointer to the contract(s) to which the event effect(s) apply, i.e. in the before event state.">
		[metadata reference]
	effectedExecution Execution (0..*) <"A pointer to the execution(s) to which the event effect(s) apply, i.e. in the before event state.">
		[metadata reference]
	contract Contract (0..*) <"A pointer to the contract effect(s), an example of such being the outcome of a new trade, swaption exercise or novation event.">
		[metadata reference]
	execution Execution (0..*) <"A pointer to the execution effect(s), an example of such being a clearing submission event when taking place on the back of an execution.">
		[metadata reference]
	productIdentifier ProductIdentifier (0..*) <"A pointer to the product identifier effect(s), an example of such being the outcome of the physical exercise of a bond option.">
		[metadata reference]
	transfer TransferPrimitive (0..*) <"A pointer to the transfer effect(s), either a cash, security or other asset.">
		[metadata reference]

/* USED in downstrem */ 
data EventTestBundle: <"A class which combines several events for testing purposes.">
	event Event (2..*)
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*)
		[synonym Rosetta_Workbench value computedAmount]

data EventTimestamp: <"A class to represent the various set of timestamps that can be associated with lifecycle events, as a collection of [dateTime, qualifier].">
	dateTime zonedDateTime (1..1) <"The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value creationTimestamp]
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value expiryTimestamp]
		[synonym DTCC_11_0, DTCC_9_0 value ReceiveTime]
		[synonym CME_ClearedConfirm_1_17 value submittedForClearing]
		[synonym CME_SubmissionIRS_1_0 value TxnTm path "TrdCaptRpt"]
		[synonym CME_SubmissionIRS_1_0 value Snt path "TrdCaptRpt.Hdr"]
		[synonym CME_SubmissionIRS_1_0 value TS path "TrdCaptRpt.TrdRegTS"]
	qualification EventTimestampQualificationEnum (1..1) <"The timestamp qualifier is specified through an enumeration because the experience of integrating the DTCC and CME data representations suggests that a wide set of timestamps are currently utilized among service providers, while there is not at present an objective set of criteria that could help suggest a defined set of timestamps as part of the CDM. At some future point, one possible baseline could be developed from the review of the set of timestamps specified across regulatory regimes and regulations (incl. regulations such as high frequency trading). Also, the integration with a further set of implementations and the specification of business workflows such as clearing as part of the CDM development should help confirm the implementation approach in this respect.">
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimestampQualificationEnum.eventCreationDateTime when "creationTimestamp" exists]
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimestampQualificationEnum.eventExpirationDateTime when "expiryTimestamp" exists]
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench set to EventTimestampQualificationEnum.clearingSubmissionDateTime when "submittedForClearing" exists]
		[synonym DTCC_11_0, DTCC_9_0 set to EventTimestampQualificationEnum.eventSubmittedDateTime when "ReceiveTime" exists]
		[synonym CME_SubmissionIRS_1_0 set to EventTimestampQualificationEnum.transactionCreationDateTime when path = "TrdCaptRpt.TxnTm"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimestampQualificationEnum.eventSentDateTime when path= "TrdCaptRpt.Hdr.Snt"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimestampQualificationEnum.executionDateTime when path= "TrdCaptRpt.TrdRegTS.TS" and "TrdCaptRpt.TrdRegTS.Typ" = 1]

data EventWorkflow: <"A class to specify workflow information, which is conceptually applicable to all lifecycle events.">
	workflowStatus WorkflowStatusEnum (0..*) <"The workflow status indicator, e.g. Accepted, Rejected, ...">
		[synonym CME_SubmissionIRS_1_0 value RptTyp path "TrdCaptRpt"]
		[synonym Rosetta_Workbench value workflowStatus]
		[synonym CME_ClearedConfirm_1_17 value status path "clearingConfirmed.trade.tradeHeader"]
	comment string (0..1) <"A comment field to be associated with the workflow, e.g. to specify why a transaction event was rejected by a party.">
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Workflow data that is specific to certain market participants and is expressed as part of the CDM in a very generic manner, which can be party-specific. The initial use cases have been derived from the CME clearing and the DTCC TIW submissions.">
		[synonym CME_SubmissionIRS_1_0 value RptSide path "TrdCaptRpt"]

data ExerciseOutcome: <"The exercise outcome combines the option contract (which states would be 'Exercised' in case of a full exercise and which would have a reduced notional in case of partial exercise) and either a physical or partial exercise.">
	contract Contract (1..1)
		[synonym Rosetta_Workbench value contract]
	physicalExercise PhysicalExercise (0..1)
		[synonym Rosetta_Workbench value physicalExercise]
	cashExercise Cashflow (0..1)
		[synonym Rosetta_Workbench value cashExercise]
	condition ExerciseOutcome_choice:<"A option exercise results in either a physical or a cash exercise.">
		required choice physicalExercise , cashExercise

data ExercisePrimitive: <"This primitive leverages the FpML OptionExercise construct, except for the exerciseTiming which is deemed as associated to a request for exercise that is meant to take place, as opposed to the actual exercise event.">
	exerciseDate AdjustableOrAdjustedDate (0..1)
		[synonym Rosetta_Workbench value exerciseDate]
	exerciseTime BusinessCenterTime (0..1)
		[synonym Rosetta_Workbench value exerciseTime]
	fullExercise boolean (1..1)
		[synonym Rosetta_Workbench value fullExercise]
	before ContractState (1..1)
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1)
		[synonym Rosetta_Workbench value after]

data ExecutionState: <"A class to specify an execution instantiation with respect to the before and/or after state of lifecycle events.">
	execution Execution (1..1)
		[synonym Rosetta_Workbench value execution]

data ExecutionPrimitive: <"Specification of the primitive event for an execution, with 'after' state being an ExecutionState and the 'before' state being Null. It is expected that the 'before' state will be adjusted or deprecated once the CDM scope is extended to the pre-execution space.">
	before ExecutionState (0..0) <"The 0 cardinality reflects the fact that there is no execution in the before state of an execution primitive. As noted in the definition associated with the class, this is expected to change once the CDM scope is extended to the pre-execution space.">
		[synonym Rosetta_Workbench value before]
	after ExecutionState (1..1) <"The after state corresponds to the execution between the parties. In the case of an execution on a contractual product, some additional characteristics may need to be specified to get a fully-formed contract, for instance when the executing party acts as an agent, as is the case in an allocation scenario. This is the purpose of the 'ContractFormation' primitive event.">
		[synonym Rosetta_Workbench value after]

data ContractFormation: <"Specification of the primitive event for the formation of a contract, with 'before' state being an 'ExecutionState' and 'after' state being a 'PostInceptionState'. This primitive combined with the 'ExecutionPrimitive' supersedes the earlier 'Inception' primitive, which had both the the execution and the contract formation bundled together, and as such was only applicable to contractual products. This intends to provide for properly atomic primitives.">
	before ExecutionState (1..1) <"The before state corresponds to the output of an execution between the parties.">
		[synonym Rosetta_Workbench value before]
	after PostInceptionState (1..1) <"The after state corresponds to the new contract being formed between the parties, plus some additional trade workflow information.">
		[synonym Rosetta_Workbench value after]

// TODO: deprecate that class, now superseded by a combination of 'ExecutionPrimitive' and 'ContractFormation'
data Inception: <"The primitive event for the inception of a new contract between parties. It is expected that this primitive will be adjusted or deprecated once the CDM scope is extended to the pre-execution space.">
	before ContractState (0..0) <"The (0..0) cardinality reflects the fact that there is no contract in the before state of an inception primitive. As noted in the definition associated with the class, this is expected to change once the CDM scope is extended to the pre-execution space.">
		[synonym Rosetta_Workbench value before]
	after PostInceptionState (1..1) <"The after state corresponds to the new contract between the parties.">
		[synonym Rosetta_Workbench value after]
		[synonym DTCC_11_0 value OTC_RM path "Header", OTC_Matching path "Body" set when "Header.OTC_RM.Manifest.TradeMsg.TransType" = "Trade"]
		[synonym DTCC_9_0 value OTC_Matching path "Body" set when "Header.OTC_RM.Manifest.TradeMsg.TransType" = "Trade"]
		[synonym CME_ClearedConfirm_1_17 value clearingConfirmed]

data InterestRateCurve:
	floatingRateIndex FloatingRateIndexEnum (1..1)
		[metadata scheme]
		[synonym Rosetta_Workbench value floatingRateIndex meta floatingRateIndexScheme]
	tenor Period (1..1)
		[synonym Rosetta_Workbench value tenor]

data LimitApplicable:
	[synonym FpML_5_10 value LimitApplicable]
	limitType CreditLimitTypeEnum (0..1) <"Standard code to indicate which type of credit line is being referred to - i.e. IM, DV01, PV01, CS01, Notional, Clip Size, Notional, maximumOrderQuantity.">
		[metadata scheme]
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value limitType meta creditLimitTypeScheme]
	clipSize int (0..1) <"This element is required in FpML, optional in CDM for the purpose of accommodating the CME data representation while making reference to the FpML one.">
		[synonym FpML_5_10 value clipSize]
	amountUtilized number (0..1) <"The limit utilised by all the cleared trades for the limit level and limit type. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value amountUtilized]
	utilization CreditLimitUtilisation (0..1)
		[synonym FpML_5_10 value utilization]
	amountRemaining number (0..1) <"The limit remaining for the limit level and limit type. This does not take into account any pending trades. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value amountRemaining]
	currency string (0..1) <"The currency in which the applicable limit is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
		[metadata scheme]
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value currency meta currencyScheme]
	velocity Velocity (0..1)
		[synonym FpML_5_10 value velocity]
	condition LimitApplicable_choice:  <"Choice rule to represent an FpML choice construct.">
		optional choice amountUtilized, utilization
	

data LimitApplicableExtended extends LimitApplicable: <"A class to represent the CDM attributes that are not part of the FpML standard. Once broader usage is confirmed, it is expected that those two classes can be collapsed.">
	[synonym CME_ClearedConfirm_1_17 value CreditLimitInformation]
	limitLevel LimitLevelEnum (0..1) <"The level at which the limit is set: customer business, proprietary business or account level. This attribute is specified as a string as part of the CME clearing confirmation specification.">
		[metadata scheme]
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value level meta creditLimitLevelScheme]
	limitAmount number (0..1) <"The total limit available for the limit level and limit type. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitAmount]
	limitImpactDueToTrade number (0..1) <"The limit utilized by this specific trade. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitImpactDueToTrade]

data Lineage: <"A class to provide lineage information across lifecycle events through a pointer or set of pointers into the event(s), contract(s) and, possibly, payout components that the event is dependent on or relates to. As an example, if an inception event is corrected, the correction event will have a lineage into the initial event, which takes the form of a rosettaKey into that initial inception event. Two referencing mechanisms are provided as part of the CDM: either the rosettaKey, which corresponds to the hash value of the CDM class which is referred to, or a reference qualifier which is meant to provide support for the ingestion of xml documents with id/href mechanisms. The CDM recommends the use of the rosettaKey and provides a default implementation which is accessible in the generated code through org.isda.cdm.rosettakey.RosettaKeyValueHashFunction. If implementers want to use an alternative hashing mechanism, the API in which they need to plug it is com.rosetta.model.lib.HashFunction.">
	contractReference Contract (0..*) <"The reference to the instantiation of a Contract object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value contractReference meta href]
	eventReference Event (0..*) <"The reference to the instantiation of an Event object, either through a rosettaKey or an xml-derived id/href mechanism. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value eventReference meta href]
	executionReference Execution (0..*) <"The reference to the instantiation of a Execution object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value executionReference meta href]
	cashflowReference Cashflow (0..*) <"The reference to the instantiation of a Cashflow payout component object. An expected typical usage is to provide lineage for the payment of, say, the option premium or the swap initial fee. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value cashflowReference meta href] 
	creditDefaultPayoutReference CreditDefaultPayout (0..*) <"The reference to the instantiation of a CreditdefaultPayout component object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value creditDefaultReference meta href]
	interestRatePayoutReference InterestRatePayout (0..*) <"The reference to the instantiation of a InterestRatePayout component object. An expected typical usage is to provide lineage for the payment of, say, an interest rate swap reset, with the ability to relate the gross cashflow amounts to the respective payout components. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value interestRatePayoutReference meta href]
	optionPayoutReference OptionPayout (0..*) <"The reference to the instantiation of a OptionPayout component object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value optionPayoutReference meta href]
	equityPayoutReference EquityPayout (0..*) <"The reference to the instantiation of a EquityPayout object. An expected typical usage is to provide lineage for the payment of, say, an equity dividend. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Rosetta_Workbench value equityPayoutReference meta href]
	transferReference TransferPrimitive (0..*) <"The reference to the instantiation of a TransferPrimitive object.">
		[metadata reference]
		[synonym Rosetta_Workbench value transferReference meta href]
	legalAgreement LegalAgreement (0..*) <"The reference to the instantiation of a Legal Agreement object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
	portfolioStateReference PortfolioState (0..*) <"The refence to the previous state of a Portfolio, in a chain of Events leading up to a build of that Portfolio as the holding of Product(s) in specific Quantity(ies). As part of the PortfolioState object, a pointer to the previous PortfolioState is provided through a Lineage object, together with pointer(s) to the Event or set of Events leading up to the current (new) state.">
		[metadata reference]

data MessageInformation: <"This class corresponds to the components of the FpML MessageHeader.model.">
	messageId string (1..1) <"A unique identifier assigned to the message.">
		[metadata scheme]
		[synonym Rosetta_Workbench value messageId path "messageInformation" meta messageIdScheme]
		[synonym DTCC_11_0, DTCC_9_0 value messageId path "header" meta messageIdScheme]
		[synonym CME_ClearedConfirm_1_17 value messageId meta messageIdScheme]
	sentBy string (0..1) <"The identifier for the originator of a message instance.">
		[metadata scheme]
		[synonym Rosetta_Workbench value sentBy path "messageInformation" meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value From]
		[synonym CME_ClearedConfirm_1_17 value sentBy meta messageAddressScheme]
		[synonym CME_SubmissionIRS_1_0 value SSub path "TrdCaptRpt.Hdr"]
	sentTo string (0..*) <"The identifier(s) for the recipient(s) of a message instance.">
		[metadata scheme]
		[synonym Rosetta_Workbench value sentTo path "messageInformation" meta messageAddressScheme]
		[synonym CME_ClearedConfirm_1_17 value sendTo meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value To]
		[synonym CME_SubmissionIRS_1_0 value TID path "TrdCaptRpt.Hdr"]
	copyTo string (0..*) <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">
		[metadata scheme]

data ObservationPrimitive: <"A class to specify the primitive object to specify market observation events, which is applicable across all asset classes.">
	source ObservationSource (1..1) <"The observation source, such as an interest rate curve or an information provider.">
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observed value.">
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">
		[synonym Rosetta_Workbench value date]
		[synonym DTCC_11_0, DTCC_9_0 value observationDate]
	time TimeZone (0..1) <"The observation time.">
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">
		[synonym Rosetta_Workbench value side]

data ObservationSource: <"The observation source can be composed of an curve and/or and information source.">
	curve Curve (0..1)
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1)
		[synonym Rosetta_Workbench value informationSource]
	condition ObservationSource_content:  <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
		if ObservationSource exists
		then (ObservationSource -> curve exists and ObservationSource -> informationSource exists)
			or ObservationSource -> curve exists
			or ObservationSource -> informationSource exists

data PartyCustomisedWorkflow: <"A class to specify a party-related, non-standardized data in a generic form.">
	partyReference Party (0..1) <"Reference to the party to which the workflow pertains to.">
		[metadata reference]
		[synonym DTCC_11_0, DTCC_9_0 value partyReference meta href]
	partyName string (0..1) <"The party name to which the workflow pertains to.">
		[synonym CME_SubmissionIRS_1_0 value ID path "Pty"]
	customisedWorkflow CustomisedWorkflow (1..*) <"Non-standardized data in a generic form.">
	condition PartyCustomisedWorkflow_choice: <"The identification of the party to which the PartyCustomisedWorkflow pertains to can be done through either a party reference or the party name.">
		required choice partyName, partyReference

data PhysicalExercise: <"The physical exercise results into a financial product which is represented through the Product class, with an associated quantity and cashflow (e.g. a physical exercise of a bond option will result into a bond with a cash proceed which will be a function of the option strike price).">
	product Product (1..1)
		[synonym Rosetta_Workbench value product]
	quantity Quantity (0..1) <"The quantity associated the asset that is physically settled. This quantity should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
		[synonym Rosetta_Workbench value quantity]
	contractualQuantity ExecutionQuantity (0..1) <"Complex attribute to specify the quantity of the contractual product that is being exercised. This temporarily makes uses of the 'ExecutionQuantity' class, until such time when the latter can be renamed as, and supersede, the existing 'ContractualQuantity' class. To be later merged with the 'quantity' attribute to have consistent mechanism between contractual and non-contractual products.">
		// For Swap Stream:
		[synonym Rosetta_Workbench value swap path "product"]
	cashflow Cashflow (0..1) <"The cashflow component of the physical exercise.">
		[synonym Rosetta_Workbench value cashflow]
	condition PhysicalExercise_quantity: <"The quantity attribute should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
		if PhysicalExercise -> product -> contractualProduct exists
		then PhysicalExercise -> quantity is absent

data PostInceptionState extends ContractState:
	creditLimitInformation CreditLimitInformation (0..1) <"Credit limit utilization information.">
		[synonym CME_ClearedConfirm_1_17 value creditLimitInformation path "trade.tradeHeader"]
		[synonym Rosetta_Workbench value creditLimitInformation]
	tradeWarehouseWorkflow TradeWarehouseWorkflow (0..1) <"Information related to trade warehouse workflow.">

data PrimitiveEvent: <"A class to specify the set of elemental/primitives components that are used to specify lifecycle events. Lifecycle events make use of one or several of those elemental components specified as part of this class.">
	execution ExecutionPrimitive (0..*)
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0, FpML_5_10 value ignore]
	contractFormation ContractFormation (0..*)
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0, FpML_5_10 value ignore]
	allocation AllocationPrimitive (0..*)
		[synonym Rosetta_Workbench value allocation]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	exercise ExercisePrimitive (0..1)
		[synonym Rosetta_Workbench value exercise]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	inception Inception (0..*)
		[synonym Rosetta_Workbench value inception]
		[synonym CME_SubmissionIRS_1_0 value ignore]
	observation ObservationPrimitive (0..*)
		[synonym Rosetta_Workbench value observation]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]	
	quantityChange QuantityChangePrimitive (0..*)
		[synonym Rosetta_Workbench value quantityChange]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	reset ResetPrimitive (0..*)
		[synonym Rosetta_Workbench value reset]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]	
	termsChange TermsChangePrimitive (0..1)
		[synonym Rosetta_Workbench value termsChange]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value ignore]
	transfer TransferPrimitive (0..*)
		[synonym Rosetta_Workbench value transfer]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
		[synonym DTCC_11_0, DTCC_9_0 value Payment path "Body.OTC_Matching"]

data QuantityChangePrimitive: <"The primitive event to represent a change in quantity or notional.">
	before Trade (1..1) <"The state of the trade (either an execution or a contract, before the event.">
		[synonym Rosetta_Workbench value before]
	after Trade (1..1) <"The state of the trade (either an execution or a contract, as a follow-up from the event.">
		[synonym Rosetta_Workbench value after]

data ResetPrimitive: <"The primitive event to represent a reset.">
	before ContractState (1..1) <"Contract state before the reset, as per previous events processed on the contract.">
		[synonym Rosetta_Workbench value ignore]
	after ContractState (1..1) <"Contract state after the reset, that embeds the reset value as an updated field on the contract state.">
		[synonym Rosetta_Workbench value ignore]
	condition ResetPrimitive_contract: <"The original contract in the before/after state of a reset should match.">
		if ResetPrimitive exists
		then ResetPrimitive -> before -> contract = ResetPrimitive -> after -> contract

data SecurityTransferBreakdown:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	security Security (1..*) <"The securities that are being transfered">
		[synonym Rosetta_Workbench value security]
	quantity number (1..1)
		[synonym Rosetta_Workbench value quantity]

data SecurityTransferComponent extends TransferBase:
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	security Security (1..1) <"The security that is being transfered">
		[synonym Rosetta_Workbench value security]
	quantity number (1..1)
		[synonym Rosetta_Workbench value quantity]
	assetTransferType AssetTransferTypeEnum (0..1) // The relevance of this attribute and the associated values need to be confirmed"
		[synonym Rosetta_Workbench value assetTransferType]
	breakdown SecurityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">
		[synonym Rosetta_Workbench value breakdown]

data TermsChangePrimitive: <"The primitive event to represent change(s) to the contractual terms and the clearing submission and acceptance process.">
	before Trade (1..1)
		[synonym Rosetta_Workbench value before]
		[synonym CME_SubmissionIRS_1_0 value ignore]
	after Trade (1..1)
		[synonym Rosetta_Workbench value after]
//one of
data Trade: <"A class to represent the general trade concept, which can either be an execution or a contract. The execution consists essentially in the economic terms which are agreed between the parties. The contract will further qualify those with the legal entities (think of the allocation case, which execution state can involve the investment adviser rather not the actual funds) while not specify the master agreement or collateral terms which might be associated with the subsequent contract.">
	execution Execution (0..1) <"The execution corresponds to economic terms that are agreed between parties, but which legal terms are not yet specified. The execution attribute applies to the post-execution scenario of a product that is subject to the clearing mandate and is then routed to the CCP as an execution.">
		[synonym CME_SubmissionIRS_1_0 value TrdCaptRpt set when "TrdCaptRpt.VenuTyp" exists]
		[synonym Rosetta_Workbench value trade set when "trade.executionType" exists]
	contract Contract (0..1) <"The contract differs from the execution by the fact that its legal terms are fully specified. This includes the legal entities that are associated to it as well as any associated legal agreement, e.g. master agreement, credit and collateral terms, ... ">
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value TradeMsg path "Manifest"]
		[synonym DTCC_11_0, DTCC_9_0 value ReportingJurisdiction path "ReportingData.ReportingHeader"]
		[synonym Rosetta_Workbench value trade set when "trade.executionType" is absent]
		[synonym CME_SubmissionIRS_1_0 value TrdCaptRpt set when "TrdCaptRpt.VenuTyp" is absent]
	condition Trade: one-of

data TradeWarehouseWorkflow: <"A class to specify trade warehouse workflow information: the identity of the trade warehouse, the contract status at the warehouse and party-specific workflow information.">
	warehouseIdentity WarehouseIdentityEnum (1..1)
		[synonym DTCC_11_0, DTCC_9_0 value WarehousePositionType path "WarehouseState"]
	warehouseStatus WorkflowStatusEnum (1..1)
		[synonym DTCC_11_0, DTCC_9_0 value WarehouseStatus path "WarehouseState"]
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Non-standardized workflow data related to a party.">
		[synonym DTCC_11_0, DTCC_9_0 value WorkflowData]
		[synonym CME_SubmissionIRS_1_0 value ignore]

data TransferPrimitive: <"A class to specify the transfer of assets between parties, those assets being either cash, securities or physical assets. This class combines components that are cross-assets (settlement date, settlement type, status, ...) and some other which are specialized by asset class (e.g. the payer/receiver amount and cashflow type for a cash transfer, the transferor/transferee, security indication, quantity, and asset transfer type qualification for the case of a security). The associated rosettaKey denotes the ability to associate a hash value to the respective Execution instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	identifier string (0..1) <"The identifier which might be associated with the transfer.">
		[metadata scheme]
		[synonym DTCC_11_0, DTCC_9_0 value tradeCashflowsId path "FpML" meta tradeCashflowsIdScheme]
	settlementType TransferSettlementEnum (0..1) <"The qualification as to how the transfer will settle, e.g. a DvP settlement.">
		[synonym Rosetta_Workbench value transferType]
		[synonym DTCC_11_0, DTCC_9_0 value SettlementType path "PaymentDetails"]
	settlementDate AdjustableOrAdjustedOrRelativeDate (1..1)
		[synonym Rosetta_Workbench value settlementDate]
	cashTransfer CashTransferComponent (0..*) <"The cash transfer component of the transfer. In the case where several currencies are involved in the transfer, several components should be used, as the component supports one single currency amount.">
		[synonym Rosetta_Workbench value cashTransfer]
		[synonym DTCC_11_0, DTCC_9_0 value payment path "FpML"]
	securityTransfer SecurityTransferComponent (0..*) <"The security transfer component of the transfer. In the case where several securities are involved in the transfer, several components should be used, as the component supports one single security.">
		[synonym Rosetta_Workbench value securityTransfer]
	commodityTransfer CommodityTransferComponent (0..*)
	status TransferStatusEnum (0..1) <"The transfer status, e.g. Instructed, Settled, ...">
		[synonym Rosetta_Workbench value status]
	settlementReference string (0..1) <"The settlement reference, when applicable.">
		[synonym Rosetta_Workbench value settlementReference]

data TransferBase:
	identifier string (0..1) <"The identifier that can be associated with each of the transfer components">
		[metadata scheme]
		[synonym DTCC_11_0, DTCC_9_0 value identifier meta paymentIdScheme]
	transferCalculation TransferCalculation (0..1) <"The calculation details underlying the transfer amount, when applicable.">
		[synonym DTCC_11_0, DTCC_9_0 value calculationDetails]

data TransferCalculation:
	period CalculationPeriodBase (0..1 ) <"The period adjusted start and end dates.">
		[synonym DTCC_11_0, DTCC_9_0 value calculationPeriod path "calculationElements"]
	lineage Lineage (0..*) <"The lineage into the components used for the calculation.">
	calculationOutcome calculation (0..1) <"This is a conceptual placeholder for providing the breakdown into the cashflow calculation components, leveraging the fact that the CDM provides calculation components, starting with the FixedAmount and the FloatingAmount. Further evaluation of expected usage needs to take place to confirm and prioritize such implementation.">
		[synonym Rosetta_Workbench value transferCalculation]


data TransferBreakdown extends TransferBase:
	lineage Lineage (0..*) <"The lineage into the transfer components that might be associated with each of the transfer components.">
		[synonym Rosetta_Workbench value lineage]

data TransferorTransferee: <"A class mimicking the PayerReceiver, which is itself derived from the FpML PayerReceiver.model, to represent the transferee and transferor party information in relation to the transfer of security or commodities.">
	transferorPartyReference Party (1..1) <"A reference to the party responsible for making the payments defined by this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value payerPartyReference meta href]
	transferorAccountReference Account (0..1) <"A reference to the account responsible for making the payments defined by this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value payerAccountReference meta href]
	transfereePartyReference Party (1..1) <"A reference to the party that receives the payments corresponding to this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value receiverPartyReference meta href]
	transfereeAccountReference Account (0..1) <"A reference to the account that receives the payments corresponding to this structure.">
		[metadata reference]
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value receiverAccountReference meta href]

data Velocity:
	[synonym FpML_5_10 value Velocity]
	periodMultiplier int (0..1)
	period PeriodTimeEnum (0..1)

/*********************
 * Event Qualification
 */

isEvent Allocation <"The qualification of allocation event from the fact that (i) the intent is Allocation when specified, (ii) the only primitive is the allocation, (iii) the sum of quantities/notional before = after, and (iv) there is a single contractualProduct before (ensured through cardinality). Note: it is accepted that an allocation can result in a single contract.">
	Event -> primitive -> allocation only exists
	/*
	 * TODO - The below syntax needs to be expanded to specify a summation
	 * This could be specify as quantityBeforeAllocation = sum(quantityAfterAllocation)
	 */
//	and quantityBeforeAllocation = quantityAfterAllocation

/*
 * Temporary event qualification until such time that we firm out the proper qualification and the way to infer it
 */
isEvent CashflowCalculationNotification
	Event -> primitive -> transfer only exists
	and Event -> messageInformation -> sentBy = "DTCC"

isEvent CashTransfer <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent
	and Event -> messageInformation -> sentBy <> "DTCC" // This is a kludge related to the CashflowCalculationNotification qualification

isEvent CashAndSecurityTransfer <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference -> reference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transferorPartyReference -> reference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent ClearedTrade <"The cleared trade at the CCP.">
	Event -> primitive -> inception only exists
	and Event -> eventWorkflow -> workflowStatus = WorkflowStatusEnum.Cleared
/*
 * It is proposed to remove the below qualification for 2 reasons
 *  - Limit the scope of event qualification to evaluating what is available within the event, while the workflow rule evaluated across events
 *  - Not introduce the distinction between agency and principal model (with this latter having contracts between clearing members and clients)
 */	
//	and Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
//	and Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearedTrade

isEvent ClearingRejection <"The rejection of an alpha trade submission by a CCP, which is qualified by the fact that (i) termsChange is the only primitive, the workflow status is `rejected`, and (iii) the CCP is positioned as a partyRole to the execution or contract in the after state, while it didn't exist in the before state.">
	Event -> primitive -> termsChange only exists
	and Event -> eventWorkflow -> workflowStatus = WorkflowStatusEnum.Rejected
	and ( Event -> primitive -> termsChange -> before -> execution -> partyRole is absent
		or Event -> primitive -> termsChange -> before -> execution -> partyRole -> role <> PartyRoleEnum.ClearingOrganization
		or Event -> primitive -> termsChange -> before -> contract -> partyRole is absent
		or Event -> primitive -> termsChange -> before -> contract -> partyRole -> role <> PartyRoleEnum.ClearingOrganization )
	and ( Event -> primitive -> termsChange -> after -> execution -> partyRole -> role = PartyRoleEnum.ClearingOrganization 
		or Event -> primitive -> termsChange -> after -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization )
	and quantityAfterQuantityChange = quantityBeforeQuantityChange

isEvent ClearingSubmission <"The submission of a contract to a CCP, which is qualified by the fact that (i) the termsChange is the only primitive, and (ii) the CCP is positioned as a partyRole to the execution or contract in the after state, while it didn't exist in the before state.">
	Event -> primitive -> termsChange only exists
	and Event -> eventWorkflow -> workflowStatus = WorkflowStatusEnum.Submitted
	and ( Event -> primitive -> termsChange -> before -> execution -> partyRole is absent
		or Event -> primitive -> termsChange -> before -> execution -> partyRole -> role <> PartyRoleEnum.ClearingOrganization
		or Event -> primitive -> termsChange -> before -> contract -> partyRole is absent
		or Event -> primitive -> termsChange -> before -> contract -> partyRole -> role <> PartyRoleEnum.ClearingOrganization )
	and ( Event -> primitive -> termsChange -> after -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization
		or Event -> primitive -> termsChange -> after -> execution -> partyRole -> role = PartyRoleEnum.ClearingOrganization )
	
isEvent Compression <"The qualification of a compression event from the fact that (i) the quantityChange primitive exists, and (ii) there are multiple contracts (or contract references) specified in the before state.">
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> quantityChange -> before -> contract multiple exists

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists

isEvent Exercise <"The qualification of an exercise event from the fact that (i) the only primitive is the exercise, and (ii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	Event -> primitive -> exercise only exists

isEvent Increase <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
	Event -> intent when present = IntentEnum.Increase
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityBeforeQuantityChange < quantityAfterQuantityChange
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

isEvent MultipleTransfers <"The qualification an event that combines multiple transfers from the fact that multiple transfer primitives exist.">
	Event -> primitive -> transfer multiple exists

isEvent NewTrade
	Event -> primitive -> inception only exists
	and Event -> primitive -> inception -> after -> tradeWarehouseWorkflow is absent
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent
	and Event -> primitive -> inception -> after -> contract -> clearedDate is absent

isEvent Novation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum.Novated
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
//	and originalContractParties <> newContractParties

isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists

isEvent PartialNovation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
//	and originalContractParties <> newContractParties

isEvent PartialTermination <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	Event -> intent when present = IntentEnum.PartialTermination
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists

isEvent SecurityTransfer <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent SecuritySettlement <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference -> reference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transfereePartyReference -> reference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent Termination <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
	Event -> intent when present = IntentEnum.Termination
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum.Terminated

isEvent TradeWarehousePositionNotification
	Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> tradeWarehouseWorkflow exists

/****************
 * Workflow rules
 */
	

 /*
workflow rule ClearedContractAgency_Participant <"The cross-events validity constraints to specify that a contract has been cleared according to the agency model from the perspective of the involved clearing member or client.">
    
    Event <beta> is ClearingSubmission
	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 
    constraint is economicTerms are the same except for payerReceiver or buyerSeller
    and <alpha> contract/execution is terminated  *Difference*
    and event date of <alpha> submission = trade date of <beta>
    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta>
 */
  
 /*
workflow rule ClearedContractAgency_CCP <"The cross-events validity constraints to specify that a contract has been cleared according to the agency model from the perspective of the involved clearing member or client.">
    
    Event <beta> is ClearingSubmission
	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 	and relatedTo <gamma> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearedTrade *Difference*
 	
    constraint is economicTerms are the same except for payerReceiver or buyerSeller
    and event date of <alpha> submission = trade date of <beta>
    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta> and <gamma> *Difference*
 */
 
  /*
workflow rule ClearedContractPrincipal_Participant <"The cross-events validity constraints to specify that a contract has been cleared according to the principal model from the perspective of the involved clearing member or client.">
    
    Event <beta> is ClearingSubmission
	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
	relatedTo <theta> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.NewTrade or eventQualifier.ClearedTrade???? *Difference*

    constraint is economicTerms are the same except for payerReceiver or buyerSeller
    and <alpha> contract/execution is terminated  *Difference*
    and event date of <alpha> submission = trade date of <beta>
    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta>
 */
  
 /*
workflow rule ClearedContractPrincipal_CCP <"The cross-events validity constraints to specify that a contract has been cleared according to the principal model from the perspective of the involved clearing member or client.">
    
    Event <beta> is ClearingSubmission
	relatedTo <alpha> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearingSubmission
 	and relatedTo <gamma> where Event -> lineage -> @rosettaKey -> Event -> eventQualifier = eventQualifier.ClearedTrade *Difference*
 	
    constraint is economicTerms are the same except for payerReceiver or buyerSeller
    and event date of <alpha> submission = trade date of <beta>
    and CCP which is in the party role in after state of <alpha> submission is the same as the CCP which is counterparty to <beta> and <gamma> *Difference*
 */
 
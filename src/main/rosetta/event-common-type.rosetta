namespace cdm.event.common : <"Business event concepts: primitives, contract state and associated state transition function specifications.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.asset.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.identifier.*

import cdm.observable.asset.*
import cdm.observable.event.*

import cdm.product.common.*
import cdm.product.asset.*
import cdm.product.template.*
import cdm.product.common.settlement.*
import cdm.product.common.schedule.*

import cdm.legalagreement.csa.*
import cdm.legalagreement.contract.*
import cdm.legalagreement.common.*

import cdm.event.workflow.*
import cdm.event.position.*

import cdm.security.lending.*

import cdm.synonyms.config.*

type Confirmation: <"A class to specify a trade confirmation.">

	identifier Identifier (1..*) <"The identifier(s) associated with the trade and resulting confirmation.">
	party Party (1..*) <"The parties associated with the trade.">
	partyRole PartyRole (1..*) <"The role(s) that party(ies) may have in relation to the trade">
	lineage Lineage (0..1) <"The lineage attribute provides a linkage to previous lifecycle events and associated data.">
	status ConfirmationStatusEnum (1..1)

	condition BothBuyerAndSellerPartyRolesMustExist: <"For an security confirmation, both buyer and seller party roles must exist.">
		if lineage -> tradeReference -> tradableProduct -> product -> security exists
		then partyRole -> role contains PartyRoleEnum -> Buyer or partyRole -> role contains PartyRoleEnum -> Seller

type Affirmation: <"A class to specify a trade affirmation.">

	identifier Identifier (1..*) <"The identifier(s) associated with the trade and resulting confirmation.">
	party Party (1..*) <"The parties associated with the trade.">
	partyRole PartyRole (1..*) <"The role(s) that party(ies) may have in relation to the trade">
	lineage Lineage (0..1) <"The lineage attribute provides a linkage to previous lifecycle events and associated data.">
	status AffirmationStatusEnum (1..1)

	condition BothBuyerAndSellerPartyRolesMustExist: <"For an security affirmation, both buyer and seller party roles must exist.">
		if lineage -> tradeReference -> tradableProduct -> product -> security exists
		then partyRole -> role contains PartyRoleEnum -> Buyer or partyRole -> role contains PartyRoleEnum -> Seller

type AllocationInstruction:
	breakdowns AllocationBreakdown (1..*) <"The set of allocation breakdowns to be applied to a block trade">

type ReallocationInstruction: <"Specifies the information required for the reallocation of a transaction.">
    decrease DecreasedTrade (1..*) <"Specifies the trades to be decreased as part of the reallocation event.">
    increase IncreasedTrade (0..*) <"Specifies the trades to be increased as part of the reallocation event.  Note this attribute cannot be used until the Increase model has been developed in the ISDA CDM.">
    breakdowns AllocationBreakdown (0..*) <"Specifies the breakdowns of any new trades created as part of the reallocation event.">
    effectiveDate date (0..1) <"Specifies the effective date of the reallocation.">

    condition Choice:
        required choice increase, breakdowns

type DecreasedTrade: <"Specifies details for a trade to be decreased as part of a reallocation event.">
    tradeState TradeState (1..1) <"Specifies the trade to be decreased.">
    quantity Quantity (1..*) <"Specifies the quantity(ies) to be decreased on the trade.">

type IncreasedTrade: <"Specifies details for a trade to be increased as part of a reallocation event.">
    tradeState TradeState (1..1) <"Specifies the trade to be increased.">
    quantity Quantity (1..*) <"Specifies the quantity(ies) to be increased on the trade.">

type AllocationBreakdown:
	counterparty Counterparty (1..1) <"Specifies the counterparty to add.">
	ancillaryParty PartyRole (1..1) <"Specifies an additional counterparty to add as part of the allocation process.">
	quantity Quantity (1..*) <"The quantity to be allocated to the party.">
	allocationTradeId Identifier (1..*)<"The identifier to be assigned to the new trade post allocation">
	account Account (0..1)<"The account to allocate the trade into">
	collateral Collateral (0..1)<"The sum that must be posted upfront to collateralize against counterparty credit risk.">

type CashTransferBreakdown extends TransferBreakdown:

	payerReceiver PartyReferencePayerReceiver (1..1) <"The payer and receiver party information.">
	amount Money (1..1) <"The currency amount of the payment.">
		[synonym Workflow_Event value "amount"]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">
		[synonym Workflow_Event value "cashflowType"]

type CashTransferComponent extends TransferBase:

	payerReceiver PartyReferencePayerReceiver (1..1) <"The payer and receiver party information.">
	amount Money (1..1) <"The currency amount.">
		[synonym Workflow_Event value "amount"]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">
		[synonym Workflow_Event value "cashflowType"]
	breakdown CashTransferBreakdown (0..*) <"The cash transfer breakdown, when the transfer corresponds to a net amount across several components which breakdown is deemed relevant (e.g. the net cash transfer related to several contracts, or to the net proceeds across several payout components).">
		[synonym Workflow_Event value "breakdown"]

type CommodityTransferBreakdown extends TransferBreakdown:

	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	commodity Commodity (1..1)
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]
	unit CapacityUnitEnum (1..1) <"The unit of measure, applicable to physical assets.">
	timeUnit TimeUnitEnum (0..1)

type CommodityTransferComponent extends TransferBase:

	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	commodity Commodity (1..1)
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]
	unit CapacityUnitEnum (1..1) <"The unit of measure, applicable to physical assets.">
	timeUnit TimeUnitEnum (0..1)
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">
	breakdown CommodityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">
		[synonym Workflow_Event value "breakdown"]

type ContractFormationInstruction: <"Specifies instructions for transition from execution to a fully formed contract, consisting of an execution and an optional legal agreement.">
	execution TradeState (1..1) <"Execution consisting of the economic terms which are agreed between the parties.">
	legalAgreement LegalAgreement (0..*) <"Optional legal agreements associated to the contract being formed, for instance a master agreement.">

type ContractState: <"A class to specify a contract state instantiation with respect to the before and/or after state of lifecycle events.">
	[metadata key]

	trade Trade (1..1) <"Reference to the original contract, such that the contract state can be resolved by super-imposing the updated values on top of the original contract.">
		[synonym Workflow_Event value "trade" path "fpmlTrade" mapper "Party"]
	updatedTrade Trade (0..1) <"The state of the contract, represented as a replica of the original contract with updated values where applicable, e.g. in the case of resets.">

type Instruction: <"Instruction to a function that will be used to perform a business event">
  	instructionFunction string (1..1) <"Specifies the function that will be called">
  	allocation AllocationInstruction (0..1) <"Instruction to allocate">
  	clearing ClearingInstruction (0..1) <"Instruction to clear">
	contractFormation ContractFormationInstruction (0..1) <"Specifies instructions for transition from execution to a fully formed contract, consisting of an execution and an optional legal agreement.">
  	execution ExecutionInstruction (0..1) <"Specifies instructions for execution of a transaction, consisting of a product, price, quantity, parties, trade identifier, and a trade date.">
  	exercise ExerciseInstruction (0..1) <"Specifies the information required to communicate the choices made by the exercising party, in a financial product endowing the party with at least one option.">
  	reset ResetInstruction (0..1) <"Specifies inputs needed to process a Reset business event.">
    transfer TransferInstruction (0..1) <"Specifies inputs needed to process a Transfer business event.">
	increase IncreaseInstruction (0..1) <"Specifies the inputs needed to process a trade increase, containing the price and quantity of the new trade lot to add.">
	decrease DecreaseInstruction (0..1) <"Specifies the inputs needed to process a trade decrease / unwind, containing the quantity of the trade lot(s) to be decreased and at what price.">
    indexTransition IndexTransitionInstruction (0..1) <"Specifies inputs needed to process a Index Transition business event.">

	condition OneOfInstruction: required choice allocation, clearing, contractFormation, execution, exercise, reset, transfer, indexTransition, increase, decrease

type BusinessEvent: <"A business event represents a life cycle event of a trade and consists of a series of primitive events. The combination of the state changes results in a qualifiable life cycle event. An example of a Business Event is a PartialTermination which is a defined by a quantity change primitive event.">
	[metadata key]
	[rootType]

	primitives PrimitiveEvent (1..*) <"The elemental component(s) that specify the lifecycle events. Each of the primitive/elemental components listed as part of the PrimitiveEvent class has distinctive features that allow to specify the lifecycle event, either by itself or in combination with some other of such components.">
	intent IntentEnum (0..1) <"The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from the event features. As a result it is only associated with those primitives that can give way to such ambiguity, the quantityChange being one of those. An example of such is a reduction in the trade notional, which could be interpreted as either a trade correction (unless a maximum period of time post-event is specified as part of the qualification), a partial termination or a portfolio rebalancing in the case of an equity swap. On the other hand, an event such as the exercise is not expected to have an associated intent as there should not be ambiguity.">
		[synonym Workflow_Event value "intent"]
	functionCall string (0..1) <"This is placeholder concept for a function call into a calculation that will return an outcome. This concept needs to be further firmed out.">
		[synonym Workflow_Event value "functionCall"]
	eventQualifier eventType (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic which qualifies the lifecycle event as a function of its features (e.g. PartialTermination, ClearingSubmission, Novation, ...).">
	eventDate date (1..1) <"Specifies the date on which the event is taking place. This date is equal to the trade date in the case of a simple execution.  However it can be different from the trade date, for example in the case of a partial termination.">
		[synonym Workflow_Event value "eventDate"]
	effectiveDate date (0..1) <"The date on which the event contractually takes effect, when different from the event date.">
		[synonym Workflow_Event value "effectiveDate"]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, novation events), listed products (from, say, a bond option exercise event) values and more. Those are represented through a set of globalKey references. This attribute is optional in order to provide implementers with the ability not to make use of this feature.">
	workflowEventState WorkflowStepState (0..1) <"The event workflow information, i.e. the workflow status, the associated comment and the partyCustomisedWorkflow which purpose is to provide the ability to associate custom workflow information to the CDM.">
		[deprecated]
	tradeWarehouseWorkflow TradeWarehouseWorkflow (0..1)

	condition Intent: <"The intent should only be associated with the primitives which use can lead to ambiguity with respect to the qualification of the event.">
		if (primitives -> split exists
			or primitives -> execution exists
			or primitives -> contractFormation exists
			or primitives -> reset exists)
		then intent is absent

type EventEffect: <"The set of operational and positional effects associated with a lifecycle event, alongside the reference to the contract reference(s) that is subject to the event (and is positioned in the before state of the event primitive).">

	effectedTrade TradeState (0..*) <"A pointer to the trade(s) to which the event effect(s) apply, i.e. in the before event state.">
		[metadata reference]
	trade TradeState (0..*) <"A pointer to the trade effect(s), an example of such being the outcome of a new trade, swaption exercise or novation event.">
	    [metadata reference]
	productIdentifier ProductIdentifier (0..*) <"A pointer to the product identifier effect(s), an example of such being the outcome of the physical exercise of a bond option.">
		[metadata reference]
	transfer TransferPrimitive (0..*) <"A pointer to the transfer effect(s), either a cash, security or other asset.">
		[metadata reference]

type EventTestBundle: <"Combines several events for testing purposes, intended to be used in downstream processes.">

	event WorkflowStep (2..*)
		[synonym Workflow_Event value "event"]
	computedAmount ComputedAmount (0..*)
		[synonym Workflow_Event value "computedAmount"]

type ExecutionInstruction: <"Specifies instructions for execution of a transaction, consisting of a product, price, quantity, parties, trade identifier, execution details, and settlement terms.">
	product Product (1..1) <"Defines the financial product to be executed and contract formed.">
	priceQuantity PriceQuantity (1..*) <"Defines the prices (e.g. spread, equity price, FX rate) and quantities (e.g. currency amount, no. shares) associated with the constituents of the transacted product.">
	counterparty  Counterparty (2..2) <"Maps two defined parties to counterparty enums for the transacted product.">
	ancillaryParty AncillaryParty (0..*) <"Maps any ancillary parties, e.g. parties involved in the transaction that are not one of the two principal parties.">
	parties Party (2..*) <"Defines all parties to that execution, including agents and brokers.">
	partyRoles PartyRole (0..*) <"Defines the role(s) that party(ies) may have in relation to the execution.">
	settlementInstructions SettlementInstructions (0..*) <"Specifies the settlement terms for the execution e.g. initial fee, broker fee, up-front cds payment or option premium settlement">
	executionDetails ExecutionDetails (1..1) <"Specifies the type and venue of execution, e.g. via voice, or electronically.">
	tradeDate date (1..1) <"Denotes the trade/execution date.">
	tradeIdentifier Identifier (1..*) <"Denotes one or more identifiers associated with the transaction.">

type ExerciseInstruction: <"Specifies the information required to communicate the choices made by the exercising party, in a financial product endowing the party with at least one option.">

	exerciseDate AdjustableOrAdjustedDate (0..1) <"Specifies the date on which an option contained within the financial product would be exercised. The date may be omitted if the contractual product allows for only a single date of exercise (European exercise).">
	exerciseTime BusinessCenterTime (0..1) <"Specifies the time at which an option contained within the financial product woulld be exercised. The time may be omitted if the contractual product allows for only a single time of exercise (European exercise). ">

type ResetInstruction: <"Defines the information needed to create a Reset Business Event. ">
 	payout Payout (1..1)
 		[metadata reference]
	rateRecordDate date (0..1) <"Specifies the 'Rate Record Day' for a Fallback rate.  Fallback rate fixing processes typically set the fixing rate in arrears, i.e., the Fallback Rate corresponding to a Rate Record Date is set at the end of the interest accural period.  When this applies, Reset->resetDate occurs at the end of the interest period, and the Reset->rateRecordDate occurs near the start of the interest period.  The Reset->rateRecordDate and Reset->observations->observationIdentifier->observationDate will differ if a Fallback rate is unavailable on the Rate Record Date, and the latest previous available rate is used as the observation.">

type TransferInstruction: <"Defines the payout on which to create a Transfer along with all necessary resets.">
 	payout Payout (1..1)
 		[metadata reference]
 	resets Reset (0..*)
	payerReceiver PayerReceiver (0..1)
	quantity Quantity (0..1) <"Specifies quantity amount returned if not the full amount from the TradeState, e.g. partial return">

type IncreaseInstruction: <"Instructions required to create an Increase Business Event. An increase effectively adds a new trade lot to the original trade.">
	tradeState TradeState (1..1) <"Reference to the trade that is being increased.">
		[metadata reference]
	tradeLot TradeLot (1..1) <"Trade lot containing the quantity by which the trade is being increased, and the price and effective date of that increase.">
	fee SettlementTerms (0..1) <"Fee agreed to be exchanged as part of the trade increase (optional).">

type DecreaseInstruction: <"Instructions required to create a Decrease Business Event (i.e. Partial or Full Termination). A decrease effectively decreases one or more trade lots contained in the original trade.">
	tradeState TradeState (1..1) <"Reference to the trade that is being decreased.">
		[metadata reference]
	tradeLot TradeLot (1..*) <"Trade lots containing the quantity being decreased, and the price and effective date of each decrease. Attribute is of multiple cardinality, to be used to specify exactly which lots / IDs are being decreased. A client could opt not to specify this and indicate just 1 lot and no ID, and implementations should then enrich these details based on unwind method (e.g. FIFO, LIFO, etc).">
	fee SettlementTerms (0..1) <"Fee agreed to be exchanged as part of the trade decrease (optional).">

type IndexTransitionInstruction: <"Defines the information needed to create a Index Transition Business Event.">
	priceQuantity PriceQuantity (1..*) <"Specifies both new floating rate index and spread adjustment for each leg to be updated.  The spread adjustment accounts for the difference between the old floating rate index relative to the new one. This spread amount is added to the existing spread to determine the new spread, which is applied from the specified effective date forward. In the case of the IBOR Fallback Rate Adjustments, the adjustment spread (also known as the Fallback Adjustment) accounts for two distinctions: i) the fact that the replacement Risk-Free Rate is an overnight rate while IBORs have term structures (e.g., 1, 3, 6-month LIBOR); and (ii) the historical spread differential between IBORs and their term equivalent Overnight Risk-Free Rate compounded rates.">
	effectiveDate date (1..1) <"Specifies the effective date of the index transition event. This is first date on which the floating rate calculation will use the new floating rate index and adjusted spread in the floating rate calculation.">
	cashTransfer Transfer (0..1) <"Specifies the cash transfer that can optionally be tied to an index transition event.">

	condition:
		priceQuantity -> price -> priceType contains PriceTypeEnum -> Spread
		and priceQuantity -> observable -> rateOption exists
		and priceQuantity -> quantity is absent

type TradeState: <"Defines the fundamental financial information that can be changed by a Primitive Event and by extension any business or life-cycle event. Each TradeState specifies where a Trade is in its life-cycle. TradeState is a root type and as such, can be created independently to any other CDM data type, but can also be used as part of the CDM Event Model.">
	[metadata key]
	[rootType]
	trade Trade (1..1) <"Represents the Trade that has been effected by a business or life-cycle event.">
	    [synonym Workflow_Event hint "trade"]
	state State (0..1) <"Represents the State of the Trade through its life-cycle.">
	    [synonym Workflow_Event value "state"]
	resetHistory Reset (0..*) <"Represents the updated Trade attributes which can change as the result of a reset event. Only the changed values are captured, leaving the remaining data attributes empty. See Create_Reset function for further details on how TradeState is used in the Reset event. The TradeState data type is used to maintain backwards compatibility with the current Reset mechanism.">
	    [synonym Workflow_Event value "resetHistory"]
	transferHistory Transfer (0..*)
	    [synonym Workflow_Event value "transferHistory"]

type Reset: <"Defines the reset value or fixing value produced in cashflow calculations, during the life-cycle of a financial instrument. The reset process defined in Create_Reset function joins product definition details with observations to compute the reset value.">
	resetValue Price (1..1) <"Specifies the reset or fixing value. The fixing value could be a cash price, interest rate, or other value.">
	    [synonym Workflow_Event value "resetValue"]
	resetDate date (1..1) <"Specifies the date on which the reset occurred.">
	    [synonym Workflow_Event value "resetDate"]
	rateRecordDate date (0..1) <"Specifies the 'Rate Record Day' for a Fallback rate.  Fallback rate fixing processes typically set the fixing rate in arrears, i.e., the Fallback Rate corresponding to a Rate Record Date is set at the end of the interest accural period.  When this applies, Reset->resetDate occurs at the end of the interest period, and the Reset->rateRecordDate occurs near the start of the interest period.  The Reset->rateRecordDate and Reset->observations->observationIdentifier->observationDate will differ if a Fallback rate is unavailable on the Rate Record Date, and the latest previous available rate is used as the observation.">
	    [synonym Workflow_Event value "rateRecordDate"]
	observations Observation (1..*) <"Represents an audit of the observations used to produce the reset value. If multiple observations were necessary to produce the reset value, the aggregation method should be defined on the payout.">
		[metadata reference]
	aggregationMethodology AggregationMethod (0..1) <"Identifies the aggregation method to use in the case where multiple observations are used to compute the reset value and the method is not defined in a payout.">

	condition: <"Ensures an averaging method is defined when more than one observation is used to compute the reset.">
		if observations count > 1 then aggregationMethodology exists

type AggregationMethod: <"Defines the ways in which multiple values can be aggregated into a single value.">
	averagingMethod AveragingMethodEnum (0..1) <"Identifies whether the average values will be weighted.">
	averagingCalculationMethod AveragingCalculationMethodEnum (0..1) <"Identifies which of the Pythagorean means is being used to compute an average value.">
	condition: one-of

type State: <"Defines the state of a trade at a point in the Trade's life cycle. Trades have many state dimensions, all of which are represented here. For example, states useful for position keeping are represented alongside those needed for regulatory reporting.">
	closedState ClosedState (0..1) <"Represents the qualification of what led to the trade's closure alongside the dates on which this closure took effect.">
	    [synonym Workflow_Event value "closedState"]
	positionState PositionStatusEnum (0..1) <"Identifies the state of the position, to distinguish if just executed, formed, already settled, closed, etc.">
	    [synonym Workflow_Event value "positionStatus"]

	condition: <"When the position state is identified as closed, the closed state must also be specified.">
	    if positionState = PositionStatusEnum -> Closed then
		    closedState exists

type Transfer: <"Defines the movement of cash, securities or commodities between two parties on a date.">
	identifier Identifier (0..*) <"Represents a unique reference to the transfer.">
		[metadata scheme]
	    [synonym Workflow_Event value "transferIdentifier"]
	quantity Quantity (1..1) <"Represents the amount of the asset to tbe transferred.">
	    [synonym Workflow_Event value "quantity"]
	observable Observable (0..1) <"Represents the object that is subject to the transfer, it could be an asset or a reference.">
		[synonym Workflow_Event value "observable"]
	payerReceiver PartyReferencePayerReceiver (1..1) <"Represents the parties to the transfer and their role.">
	settlementDate AdjustableOrAdjustedOrRelativeDate (1..1) <"Represents the date on which the transfer to due.">
	settlementOrigin SettlementOrigin (0..1) <"Represents the origin to the transfer, whether it originated from trade level settlement terms or from payment terms on an economic payout.">

	condition:
		if observable exists
		then quantity -> unitOfAmount -> financialUnit exists

type SettlementOrigin: <"Defines the various model elements where transfers can arrise.">
	interestRatePayout InterestRatePayout (0..1) <"Represents a reference to an Interest Rate Payout.">
		[metadata reference]
	equityPayout EquityPayout (0..1) <"Represents a reference to an Equity Payout.">
	    [metadata reference]
	securityPayout SecurityPayout (0..1) <"Represents a reference to a Security Payout.">
		[metadata reference]
	cashflow Cashflow (0..1) <"Represents a reference to an Cashflow Payout.">
		[metadata reference]
	settlementTerms SettlementTerms (0..1) <"Represents a reference to settlement terms, which may have been specified at execution.">
		[metadata reference]
	physicalSettlementTerms PhysicalSettlementTerms (0..1) <"Represents a reference to physical settlement terms.">
		[metadata reference]
	cashSettlementTerms CashSettlementTerms (0..1) <"Represents a reference to cash settlement terms.">
		[metadata reference]
	securityFinancePayout SecurityFinancePayout (0..1) <"Represents a reference to a Security Lending Payout.">
    		[metadata reference]
	condition: one-of

type Trade: <"Defines the output of a financial transaction between parties - a Business Event. A Trade impacts the financial position (i.e. the balance sheet) of involved parties.">
	[metadata key]
	tradeIdentifier Identifier (1..*) <"Represents the identifier(s) that uniquely identify a trade for an identity issuer. A trade can include multiple identifiers, for example a trade that is reportable to both the CFTC and ESMA, and then has an associated USI (Unique Swap Identifier) UTI (Unique Trade Identifier).">
	tradeDate date (1..1) <"Specifies the date which the trade was agreed.">
        [metadata id]
	tradableProduct TradableProduct (1..1) <"Represents the financial instrument The corresponding FpML construct is the product abstract element and the associated substitution group.">
	party Party (0..*) <"Represents the parties to the trade. The cardinality is optional to address the case where the trade is defined within a BusinessEvent data type, in which case the party is specified in BusinessEvent.">
	partyRole PartyRole (0..*) <"Represents the role each specified party takes in the trade. further to the principal roles, payer and receiver.">
	executionDetails ExecutionDetails (0..1) <"Represents information specific to trades that arose from executions.">
	contractDetails ContractDetails (0..1) <"Represents information specific to trades involving contractual products.">
	    [synonym Workflow_Event value "trade" set when "trade->executionVenue" is absent]
    clearedDate date (0..1) <"Specifies the date on which a trade is cleared (novated) through a central counterparty clearing service.">
        [deprecated]
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">
	account Account (0..*) <"Represents a party's granular account information, which may be used in subsequent internal processing.">
	    [deprecated]

	condition SecurityPartyRole: <"When the executed product is a security, both ExecutingEntity and Counterparty party roles must exist.">
		if tradableProduct -> product -> security exists
		then partyRole -> role contains PartyRoleEnum -> ExecutingEntity and partyRole -> role contains PartyRoleEnum -> Counterparty

	condition SecurityPartyRoleBuyerSeller: <"When the executed product is a security, both buyer and seller party roles must exist.">
		if tradableProduct -> product -> security exists
		then partyRole -> role contains PartyRoleEnum -> Buyer and partyRole -> role contains PartyRoleEnum -> Seller

	condition SecurityPrice: <"When the executed product is a security, the price must be specified.">
		if tradableProduct -> product -> security exists
		then tradableProduct -> tradeLot -> priceQuantity -> price exists

	condition SettlementTerms: <"When the executed product is a security, the settlement terms must be specified.">
		if tradableProduct -> product -> security exists
		then tradableProduct -> settlementInstructions exists

	condition DeliverableObligationsPhysicalSettlementMatrix: <"The below set of credit deliverable obligation provisions are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions cannot be omitted if the Credit Derivatives Physical Settlement Matrix doesn't governs the terms of the contract.">
		if (contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notSubordinated
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> specifiedCurrency
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notSovereignLender
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notDomesticCurrency
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notDomesticLaw
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notContingent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notDomesticIssuance
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> assignableLoan
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> consentRequiredLoan
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> transferable
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> maximumMaturity
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notBearer
			) exists
			and (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> fullFaithAndCreditObLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> generalFundObligationLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> revenueObligationLiability
			) exists

	condition ObligationsPhysicalSettlementMatrix: <"The below set of obligation of the reference entity are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions cannot be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in case the case where an auction could not take place because of, say, liquidity considerations.">
		if (contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notSubordinated
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notSovereignLender
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notDomesticLaw
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notDomesticIssuance
			) exists
			and (
			tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> fullFaithAndCreditObLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> generalFundObligationLiability
			or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> revenueObligationLiability
			) exists

	condition CreditEventsPhysicalSettlementMatrix: <"The below set of credit events are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions can only be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in the case where an auction could not take place because of, say, liquidity considerations.">
		if (contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> bankruptcy
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> obligationDefault
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> obligationAcceleration
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> repudiationMoratorium
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> governmentalIntervention
			) exists

	condition RestructuringPhysicalSettlementMatrix: <"The below multiple holder obligation restructuring provisions is specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that this provision can only be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in the case where an auction could not take place because of, say, liquidity considerations.">
		if (contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
			or contractDetails -> documentation -> documentationIdentification -> contractualMatrix -> matrixType is absent)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation exists

	condition AdditionalFixedPaymentsMortgages: <"The below set of additional fixed payment provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
		if ( (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> securityType any = SecurityTypeEnum -> Debt
				and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> debtType -> debtClass any = DebtClassEnum -> AssetBacked)
			or contractDetails -> documentation -> documentationIdentification -> contractualTermsSupplement -> contractualTermsSupplementType contains ContractualSupplementEnum -> CDSonMBS)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> interestShortfallReimbursement
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> principalShortfallReimbursement
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> writedownReimbursement
			) exists

	condition FloatingAmountEventsMortgages: <"The below set of floating amount events provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
		if ((tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> securityType any = SecurityTypeEnum -> Debt
				and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> debtType -> debtClass any = DebtClassEnum -> AssetBacked)
			or contractDetails -> documentation -> documentationIdentification -> contractualTermsSupplement -> contractualTermsSupplementType contains ContractualSupplementEnum -> CDSonMBS)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> failureToPayPrincipal
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> writedown
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> floatingAmountEvents -> impliedWritedown
			) exists

	condition CreditEventsMortgages: <"The below set of credit events provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
		if ((tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> securityType any = SecurityTypeEnum -> Debt
				and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> debtType -> debtClass any = DebtClassEnum -> AssetBacked)
			or contractDetails -> documentation -> documentationIdentification -> contractualTermsSupplement -> contractualTermsSupplementType contains ContractualSupplementEnum -> CDSonMBS)
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> failureToPayPrincipal
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> failureToPayInterest
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> distressedRatingsDowngrade
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> maturityExtension
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> writedown
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> impliedWritedown
			) exists

	condition HedgingParty: <"FpML specifies that there cannot be more than 2 hedging parties.">
		if partyRole -> role contains PartyRoleEnum -> HedgingParty
		then FilterPartyRole( partyRole, PartyRoleEnum -> HedgingParty ) count <= 2

	condition DeterminingParty: <"FpML specifies that there cannot be more than 2 determining parties.">
		if partyRole -> role contains PartyRoleEnum -> DeterminingParty
		then FilterPartyRole( partyRole, PartyRoleEnum -> DeterminingParty ) count <= 2

	condition BarrierDerterminationAgent: <"FpML specifies that there cannot be more than 1 barrier determination agent.">
		if partyRole -> role contains PartyRoleEnum -> BarrierDeterminationAgent
		then FilterPartyRole( partyRole, PartyRoleEnum -> BarrierDeterminationAgent ) count <= 1

	condition ClearedDate: <"If the cleared date exists, it needs to be on or after the trade date.">
		if clearedDate exists
		then clearedDate >= tradeDate

	condition ContractualProductExists:
		tradableProduct -> product -> contractualProduct only exists

	condition FpML_cd_1: <"FpML validation rule cd-1 - If referenceInformation exists, tradeDate must be before effectiveDate/unadjustedDate.">
		if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then tradeDate < tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
			or tradeDate < tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> adjustedDate

	condition FpML_cd_7: <"FpML validation rule cd-7 - If condition LongForm is true, then effectiveDate/dateAdjustments exists.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> dateAdjustments exists
			or tradeDate < tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> adjustedDate

	condition FpML_cd_8: <"FpML validation rule cd-8 - If condition LongForm is true, and if scheduledTerminationDate exists then scheduledTerminationDate/dateAdjustments exists.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> terminationDate -> adjustableDate -> dateAdjustments exists

	condition FpML_cd_11: <"FpML validation rule cd-11 - If condition LongForm is true, and if condition ISDA2003 is true, then allGuarantees must exist.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
			and contractDetails -> documentation -> documentationIdentification -> contractualDefinitions any = ContractualDefinitionsEnum -> ISDA2003Credit
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees exists

	condition FpML_cd_19: <"FpML validation rule cd-19 - If the condition ISDA1999Credit is true, then the following elements must not exist: protectionTerms/creditEvents/creditEventNotice/businessCenter, protectionTerms/creditEvents/restructuring/multipleHolderObligation, protectionTerms/creditEvents/restructuring/multipleCreditEventNotices, generalTerms/referenceInformation/allGuarantees, generalTerms/indexReferenceInformation, generalTerms/substitution, generalTerms/modifiedEquityDelivery.">
		if contractDetails -> documentation -> documentationIdentification -> contractualDefinitions any = ContractualDefinitionsEnum -> ISDA1999Credit
		then ( tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> businessCenter
            and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation
            and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleCreditEventNotices
            and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees
            and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation
            and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> substitution
            and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> modifiedEquityDelivery )
            is absent

	condition FpML_cd_20: <"FpML validation rule cd-20 - If the condition ISDA2003 is true, then protectionTerms/obligations/notContingent must not exist.">
		if contractDetails -> documentation -> documentationIdentification -> contractualDefinitions any = ContractualDefinitionsEnum -> ISDA2003Credit
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notContingent is absent

	condition FpML_cd_23: <"FpML validation rule cd-23 - If the condition LongForm is true, then cashSettlementTerms or physicalSettlementTerms must exist.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> cashSettlementTerms or tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms) exists

	condition FpML_cd_24: <"FpML validation rule cd-24 - If the condition LongForm is true, then the following elements must exist: protectionTerms/creditEvents/creditEventNotice, protectionTerms/obligations, generalTerms/referenceInformation/referencePrice.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout ->generalTerms -> referenceInformation -> referencePrice
			) exists

	condition FpML_cd_25: <"FpML validation rule cd-25 - If the condition LongForm is true, and if physicalSettlementTerms exists, then physicalSettlementTerms must contain settlementCurrency, physicalSettlementPeriod, escrow and deliverableObligations/accruedInterest.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms exists
		then (tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> settlementCurrency
		and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> physicalSettlementPeriod
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> escrow
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> accruedInterest
			) exists

	condition FpML_cd_32: <"FpML validation rule cd-32 - If condition LongForm is true, and if fixedAmountCalculation/calculationAmount exists, then fixedAmountCalculation/dayCountFraction must exist.">
		if ( contractDetails -> documentation -> documentationIdentification -> masterConfirmation and contractDetails -> documentation -> documentationIdentification -> contractualMatrix ) is absent
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
			and tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payoutQuantity exists
			and tradableProduct -> tradeLot -> priceQuantity -> quantity -> amount exists
		then tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> dayCountFraction exists

	condition FpML_ird_8: <"FpML validation rule ird-8 - If the same party is specified as the payer and receiver, then different accounts must be specified.">
        if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
        then FpmlIrd8( tradableProduct, account ) = True

type ExecutionDetails: <"Defines specific attributes that relate to trade executions.">
	[metadata key]

	executionType ExecutionTypeEnum (1..1) <"Identifies the type of execution, e.g. via voice, electronically...">
		[synonym Workflow_Event value "executionType"]
	executionVenue LegalEntity (0..1) <"Represents the venue on which a trade was executed.">

	condition ExecutionVenue: <"When the execution type is set to 'Electronically', the execution venue must be specified.">
		if executionType = ExecutionTypeEnum -> Electronic
		then executionVenue exists

type ContractDetails: <"Defines specific attributes that relate to contractual details of trades.">
	[metadata key]
	documentation RelatedAgreement (0..*) <"Represents the legal document(s) that governs a trade and associated contractual product terms, either as a reference to such documents when specified as part of the CDM, or through identification of some of the key terms of those documents, such as the type of document, the document identifier, the publisher, the document vintage and the agreement date.">
	governingLaw GoverningLawEnum (0..1) <"Represents the law governing the trade and associated contractual product terms.">
		[metadata scheme]
	partyContractInformation PartyContractInformation (0..*) <"Represents additional contractual information provided by each involved party.">

type Lineage: <"A class to provide lineage information across lifecycle events through a pointer or set of pointers into the event(s), contract(s) and, possibly, payout components that the event is dependent on or relates to. As an example, if an contractFormation event is corrected, the correction event will have a lineage into the initial event, which takes the form of a globalKey into that initial contract formation event. Two referencing mechanisms are provided as part of the CDM: either the globalKey, which corresponds to the hash value of the CDM class which is referred to, or a reference qualifier which is meant to provide support for the ingestion of xml documents with id/href mechanisms. The CDM recommends the use of the globalKey and provides a default implementation which is accessible in the generated code through org.isda.cdm.globalKey.GlobalKeyHashCalculator. If implementers want to use an alternative hashing mechanism, the API in which they need to plug it is com.rosetta.model.lib.HashFunction.">
    tradeReference Trade (0..*)
        [metadata reference]
        [synonym Workflow_Event value "contractReference" meta "href"]
        [synonym Workflow_Event value "executionReference" meta "href"]
	eventReference WorkflowStep (0..*) <"The reference to the instantiation of an Event object, either through a globalKey or an xml-derived id/href mechanism. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "eventReference" meta "href"]
	cashflowReference Cashflow (0..*) <"The reference to the instantiation of a Cashflow payout component object. An expected typical usage is to provide lineage for the payment of, say, the option premium or the swap initial fee. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "cashflowReference" meta "href"]
	creditDefaultPayoutReference CreditDefaultPayout (0..*) <"The reference to the instantiation of a CreditdefaultPayout component object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "creditDefaultReference" meta "href"]
	interestRatePayoutReference InterestRatePayout (0..*) <"The reference to the instantiation of a InterestRatePayout component object. An expected typical usage is to provide lineage for the payment of, say, an interest rate swap reset, with the ability to relate the gross cashflow amounts to the respective payout components. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "interestRatePayoutReference" meta "href"]
	optionPayoutReference OptionPayout (0..*) <"The reference to the instantiation of a OptionPayout component object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "optionPayoutReference" meta "href"]
	equityPayoutReference EquityPayout (0..*) <"The reference to the instantiation of a EquityPayout object. An expected typical usage is to provide lineage for the payment of, say, an equity dividend. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
		[synonym Workflow_Event value "equityPayoutReference" meta "href"]
	transferReference TransferPrimitive (0..*) <"The reference to the instantiation of a TransferPrimitive object.">
		[metadata reference]
		[synonym Workflow_Event value "transferReference" meta "href"]
	legalAgreement LegalAgreement (0..*) <"The reference to the instantiation of a Legal Agreement object. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
		[metadata reference]
	portfolioStateReference PortfolioState (0..*) <"The refence to the previous state of a Portfolio, in a chain of Events leading up to a build of that Portfolio as the holding of Product(s) in specific Quantity(ies). As part of the PortfolioState object, a pointer to the previous PortfolioState is provided through a Lineage object, together with pointer(s) to the Event or set of Events leading up to the current (new) state.">
		[metadata reference]

type PostContractFormationState extends ContractState:

	creditLimitInformation CreditLimitInformation (0..1) <"Credit limit utilization information.">
	tradeWarehouseWorkflow TradeWarehouseWorkflow (0..1) <"Information related to trade warehouse workflow.">

type SecurityTransferBreakdown:

	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	security Security (1..*) <"The securities that are being transfered">
		[synonym Workflow_Event value "security"]
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]

type SecurityTransferComponent extends TransferBase:

	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">
	security Security (1..1) <"The security that is being transfered">
		[synonym Workflow_Event value "security"]
	quantity number (1..1)
		[synonym Workflow_Event value "quantity"]
	assetTransferType AssetTransferTypeEnum (0..1)
		[synonym Workflow_Event value "assetTransferType"]
	breakdown SecurityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">
		[synonym Workflow_Event value "breakdown"]

type StockSplitInstruction: <"Data required to perform a stock split business event.">

	tradeState TradeState (1..1) <"Contract to be split.">
	adjustmentRatio number (1..1) <"The number that denotes the cumulative quantity of post-split shares issued to shareholders versus the quantity of pre-split shares previously issued to shareholders.  This number will be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.  With regard to any reference to price, the pre-split reference price will be divided by this number to determine the post-split reference price.">
	date date (1..1) <"The effective date of the stock split, also known as the ex-date. This is the date on which the additional shares are paid to the shareholders, or in the case of a reverse stock split, the number shares held by each shareholder is proportionally reduced.  Equity derivative transactions can be amended in firms' internal systems on such date.   In most markets, the listed stock price is reduced (or increased for a reverse stock split) to account for the split on the same date, but in some markets the price adjustment occurs on a later date.  In either case, equity derivative transactions should be amended on the date that the stocks are paid to the shareholders (or consolidated).">

type TransferBase:

	identifier string (0..1) <"The identifier that can be associated with each of the transfer components">
		[metadata scheme]
	transferCalculation TransferCalculation (0..1) <"The calculation details underlying the transfer amount, when applicable.">

type TransferCalculation:

	period CalculationPeriodBase (0..1 ) <"The period adjusted start and end dates.">
	lineage Lineage (0..*) <"The lineage into the components used for the calculation.">
	calculationOutcome calculation (0..1) <"This is a conceptual placeholder for providing the breakdown into the cashflow calculation components, leveraging the fact that the CDM provides calculation components, starting with the FixedAmount and the FloatingAmount. Further evaluation of expected usage needs to take place to confirm and prioritize such implementation.">
		[synonym Workflow_Event value "transferCalculation"]

type TransferBreakdown extends TransferBase:

	lineage Lineage (0..*) <"The lineage into the transfer components that might be associated with each of the transfer components.">
		[synonym Workflow_Event value "lineage"]

type TransferorTransferee: <"A class mimicking the PartyReferencePayerReceiver, which is itself derived from the FpML PayerReceiver.model, to represent the transferee and transferor party information in relation to the transfer of security or commodities.">

	transferorPartyReference Party (1..1) <"A reference to the party responsible for making the payments defined by this structure.">
		[metadata reference]
	transferorAccountReference Account (0..1) <"A reference to the account responsible for making the payments defined by this structure.">
		[metadata reference]
		[synonym Workflow_Event value "payerAccountReference" meta "href"]
	transfereePartyReference Party (1..1) <"A reference to the party that receives the payments corresponding to this structure.">
		[metadata reference]
	transfereeAccountReference Account (0..1) <"A reference to the account that receives the payments corresponding to this structure.">
		[metadata reference]
		[synonym Workflow_Event value "receiverAccountReference" meta "href"]

type ClearingInstruction: <"All information required to perform the clear life cycle event; the clearing party (CCP), the two parties facing each other on the alpha contract, and optionally the parties acting as clearing members.">
	alphaContract TradeState (1..1) <"The contract that will be submitted to the clearing house for clearing. The contract should indicate that it should be cleared by assigning a clearing organisation as a party role.">

	clearingParty Party(1..1) <"The Central Counter party (CCP) that the contract will be submitted to for clearing.">
	party1 Party(1..1) <"First party facing the CCP if it is clearing for its own account.">
	party2 Party(1..1) <"Second party facing the CCP if it is clearing for its own account.">

	clearerParty1 Party(0..1) <"Optional party facing the CCP, acting as clearing member for party1.">
	clearerParty2 Party(0..1) <"Optional party facing the CCP, acting as clearing member for party2.">

type PrimitiveEvent: <"A primitive event is defined by one and only one atomic change in state of a trade. An example of this is a contract formation where the legal terms of the contact are added to the trade. A Primitive event contains a before and after state where the before is a reference to another after state of a primitive event in order to preserve lineage.">

	execution ExecutionPrimitive (0..1)
		[synonym Workflow_Event value "executionPrimitive" path "primitive"]
	contractFormation ContractFormationPrimitive (0..1)
		[synonym Workflow_Event value "contractFormation" path "primitive"]
	split SplitPrimitive (0..1)
		[synonym Workflow_Event value "split" path "primitive"]
	quantityChange QuantityChangePrimitive (0..1)
		[synonym Workflow_Event value "quantityChange" path "primitive"]
	reset ResetPrimitive (0..1)
		[synonym Workflow_Event value "reset" path "primitive"]
	termsChange TermsChangePrimitive (0..1)
		[synonym Workflow_Event value "termsChange" path "primitive"]
	transfer TransferPrimitive (0..1)
		[synonym Workflow_Event value "transfer" path "primitive"]
	condition PrimitiveEvent: one-of

type ExecutionPrimitive: <"Defines the primitive event for an execution, with 'after' attribute being a TradeState and the 'before' attribute being Null. It is expected that the 'before' attribute will be adjusted or deprecated once the CDM scope is extended to include pre-trade.">

	before TradeState (0..0) <"Represents the connection point between pre and post trade life-cycle events. The TradeState associated to the 'before' attribute represents the final step of any pre-trade workflow. CDM scope does not include pre-trade and so cardinality of this attribute is specified as exactly 0, which enforces the absence of the 'before' attribute.">
		[metadata reference]
		[synonym Workflow_Event value "before"]
	after TradeState (1..1) <"Represents an execution between parties. In the case of an execution on a contractual product, some additional characteristics may need to be specified to get a fully-formed contract, for instance when the executing party acts as an agent, as is the case in an allocation scenario. This is the purpose of the 'ContractFormation' primitive event.">
		[synonym Workflow_Event value "after"]

	condition:
		after -> trade -> executionDetails exists

type ContractFormationPrimitive: <"Defines the primitive event that represents an executed trade that has been affirmed (or confirmed) by the two parties. If both 'after' and 'before' attributes exist, then both must have identical TradableProduct values.">

	before TradeState (0..1) <"Represents the output of an execution between the parties.">
		[metadata reference]
		[synonym Workflow_Event value "fpmlTrade" path "before"]
		[synonym Workflow_Event value "fpmlExecution" path "before"]
	after TradeState (1..1) <"Represents the new contract being formed between the parties.">
		[synonym Workflow_Event value "fpmlTrade" path "after"]

	condition: <"The quantity should be unchanged.">
		if before exists then
		before -> trade -> tradableProduct = after -> trade -> tradableProduct

	condition: <"The price, quantity, and observable should be unchanged.">
        if before exists
        then before -> trade -> tradableProduct -> tradeLot -> priceQuantity = after -> trade -> tradableProduct -> tradeLot -> priceQuantity

type SplitPrimitive: <"Defines splitting of a single trade into one or more trades, where the quantity of the split trade(s) totals that of the single trade.">

	before TradeState (1..1) <"Represents the single trade to be split.">
		[metadata reference]
		[synonym Workflow_Event value "fpmlTrade" path "before"]
	after TradeState (2..*) <"Represents the outcome of the split. Includes the single trade (referenced in the 'before' attribute) with its Position State updated to closed, along with a reason.">
		[synonym Workflow_Event value "fpmlTrade" path "after"]

	condition: <"Ensure Execution Details are not lost in the split process.">
		if before -> trade -> executionDetails exists
		then after -> trade -> executionDetails exists
			and after -> trade -> executionDetails exists
			and after-> trade -> contractDetails is absent

	condition: <"Ensure Contract Details are not list in the split process.">
		if before -> trade -> contractDetails exists
		then after -> trade -> contractDetails exists
			and after -> trade -> contractDetails exists
			and after-> trade -> executionDetails is absent

	condition: <"Ensure the product remains unchanged.">
		after -> trade -> tradableProduct -> product all = before -> trade -> tradableProduct -> product

	condition: <"Ensure the quantities of each split trade totals that of the single trade.">
		Sum( FilterOpenTradeStates(after) -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity -> amount ) =Sum( before -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity -> amount )

func FilterOpenTradeStates: <"Outlines inputs and outputs required to filter only 'open' Trade States.">
	inputs:
		tradeStates TradeState (2..*)
	output:
		filteredTradeStates TradeState (0..*)

type QuantityChangePrimitive: <"Defines the primitive event to represent a change in quantity, which includes notional. For details of how the TradeState is changed between the `before` and `after` TradeStates, see the corresponding Create_QuantityChangePrimitive function.">

	before TradeState (1..1) <"Represents the state of the trade before the event.">
		[metadata reference]
		[synonym Workflow_Event value "fpmlTrade" path "before"]
	after TradeState (1..1) <"Represents the state of the trade as a follow-up from the event.">
		[synonym Workflow_Event value "fpmlTrade" path "after"]

type ResetPrimitive: <"Defines the primitive event to represent a reset. For details of how the TradeState is changed between the `before` and `after` TradeStates, see the corresponding Create_ResetPrimitive function.">

	before TradeState (1..1) <"Represents the TradeState prior applying the Reset primitive.">
		[metadata reference]
		[synonym Workflow_Event value "fpmlTrade" path "before"]
	after TradeState (1..1) <"Represents the TradeState after to applying the Reset primitive.">
		[synonym Workflow_Event value "fpmlTrade" path "after"]
	condition Trade: <"The original trade in the before/after state of a reset should match.">
		before -> trade = after -> trade

type TermsChangePrimitive: <"Defines the primitive event to represent changes to terms of the trade.">

	before TradeState (1..1) <"Represents the TradeState prior to applying the TermsChange primitive.">
		[metadata reference]
		[synonym Workflow_Event value "fpmlTrade" path "before"]
	after TradeState (1..1) <"Represents the TradeState after to applying the TermsChange primitive. ">
		[synonym Workflow_Event value "fpmlTrade" path "after"]

type TransferPrimitive: <"A class to specify the transfer of assets between parties, those assets being either cash, securities or physical assets. This class combines components that are cross-assets (settlement date, settlement type, status, ...) and some other which are specialized by asset class (e.g. the payer/receiver amount and cashflow type for a cash transfer, the transferor/transferee, security indication, quantity, and asset transfer type qualification for the case of a security). The associated globalKey denotes the ability to associate a hash value to the respective Execution instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
	[metadata key]
	before TradeState (1..1)
	    [metadata reference]
	    [synonym Workflow_Event value "fpmlTrade" path "before"]
	after TradeState (1..1)
	    [synonym Workflow_Event value "fpmlTrade" path "after"]

type PackageInformation: <"A class defining additional information that may be recorded alongside a transaction package.">
	[deprecated]
	relatedParty RelatedParty (0..*) <"This may be used to identify one or more parties that perform a role as part of the transaction.">
	category CategoryEnum (0..*)

	intentToAllocate boolean (0..1) <"specifies whether the transaction package is anticipated to be allocated.">

type ExerciseEvent: <"A data defining:  the adjusted dates associated with a particular exercise event.">
	[deprecated]
	[metadata key]

	adjustedExerciseDate date (1..1) <"The date on which the option exercise takes place. This date should already be adjusted for any applicable business day convention.">
	adjustedRelevantSwapEffectiveDate date (1..1) <"The effective date of the underlying swap associated with a given exercise date. This date should already be adjusted for any applicable business day convention.">
	adjustedCashSettlementValuationDate date (0..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
	adjustedCashSettlementPaymentDate date (0..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business day convention.">
	adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

type ReturnInstruction: <"Specifies the information required to create the return of a Security Finance Transaction.">
    quantity Quantity (1..*) <"Specifies the quantity of shares and cash to be returned in a partial return event.">

type SecurityLendingInvoice: <"Specifies the information required for inclusion in a securities lending billing invoice.">
    [rootType]
    [metadata key]
    sendingParty Party (1..1) <"The party issuing the invoice">
    receivingParty Party (1..1) <"The party receiving the invoice">
    billingStartDate date (1..1) <"The starting date of the period described by this invoice">
    billingEndDate date (1..1) <"The ending date of the period described by this invoice">
    billingRecord BillingRecord (1..*) <"The billing records contained within the invoice">
    billingSummary BillingSummary (1..*) <"The billing summaries contained within the invoice">

type BillingInstruction: <"Specifies the instructions for creation of a Security Lending billing invoice.">
    sendingParty Party (1..1) <"The party issuing the invoice">
    receivingParty Party (1..1) <"The party receiving the invoice">
	billingStartDate date (1..1) <"The starting date of the period described by this invoice">
   	billingEndDate date (1..1) <"The ending date of the period described by this invoice">
   	billingRecordInstruction BillingRecordInstruction (1..*) <"Instructions for creating the billing records contained within the invoice">
   	billingSummary BillingSummaryInstruction (0..*) <"The billing summaries contained within the invoice">

type BillingRecordInstruction: <"Specifies the instructions for creation of a billing record.">
    tradeState TradeState (1..1) <"The trade for the individual billing record.">
        [metadata reference]
    observation Observation (1..*) <"The observations used to calculate the billing amount.">
    recordStartDate date (1..1) <"The starting date of the period described by this record">
    recordEndDate date (1..1) <"The ending date of the period described by this record">
    settlementDate date (1..1) <"The date for settlement of the transfer.">

type BillingSummaryInstruction: <"Specifies the instructions for creation of a billing summary.">
    summaryAmountType RecordAmountTypeEnum (1..1) <"The account level for the billing summary.">

type BillingRecord: <"Specifies individual records within a billing invoice.">
    tradeState TradeState (1..1) <"The trade for the individual billing record.">
        [metadata reference]
    recordTransfer Transfer (1..1) <"The settlement terms for the billing record">
    recordStartDate date (1..1) <"The starting date of the period described by this record">
    recordEndDate date (1..1) <"The ending date of the period described by this record">
    minimumFee Money (0..1) <"Indicates the minimum fee amount applied to the billing record, if any.">

type BillingSummary: <"Specifies individual summaries within a billing invoice.">
    summaryTransfer Transfer (0..1) <"The settlement terms for the billing summary">
    summaryAmountType RecordAmountTypeEnum (1..1) <"The account level for the billing summary.">

    condition GrandTotal:
        if summaryAmountType = RecordAmountTypeEnum -> GrandTotal
            then summaryTransfer exists
            and summaryTransfer -> payerReceiver is absent

    condition ParentTotal:
        if summaryAmountType = RecordAmountTypeEnum -> ParentTotal
            then summaryTransfer -> payerReceiver exists
            and summaryTransfer->payerReceiver->payerAccountReference is absent
            and summaryTransfer->payerReceiver->receiverAccountReference is absent

    condition AccountTotal:
        if summaryAmountType = RecordAmountTypeEnum -> AccountTotal
            then summaryTransfer->payerReceiver->payerAccountReference exists
            and summaryTransfer->payerReceiver->receiverAccountReference exists


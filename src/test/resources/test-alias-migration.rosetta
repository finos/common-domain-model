namespace org.isda.cdm.test
version "${project.version}"

import org.isda.cdm.*
import cdm.base.maths.*
import cdm.base.datetime.*

//isEvent TestPartialNovation <"">
//	WorkflowEvent -> effectiveDate = novatedContractEffectiveDate
//
//

type ListOfNumbers:
	numbers number(0..*)

func TestPartialNovationFunc: <"">
	inputs: workflowStep WorkflowStep (0..1)
	output: result boolean (0..1)
	assign-output result: NovatedContractEffectiveDate(workflowStep -> businessEvent) -> dates only-element = workflowStep -> businessEvent -> effectiveDate

func NovatedContractEffectiveDate2:

	inputs: workflowEvent WorkflowStep(1..1)
	output: result DateGroup(0..1)

	alias eTerms: workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> tradableProduct -> product -> contractualProduct -> economicTerms

	assign-output result -> dates: [ 
			eTerms -> effectiveDate -> adjustableDate -> adjustedDate,
			eTerms -> effectiveDate -> adjustableDate -> unadjustedDate,
			eTerms -> effectiveDate -> relativeDate -> adjustedDate,
			eTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			eTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			eTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate,
			eTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			eTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			eTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate
	]

func TestGroupBy: 
	inputs:
		input1 TypeToGroup (0..1)
	output: out ListOfNumbers (1..1)
	assign-output out -> numbers: [
		(input1 -> manyAttr group by currency) -> amount 
	]
 
func TestBinaryOpGroupBy:
	inputs:
		op CompareOp (1..1)
		input1 TypeToGroup (0..1)
		input2 TypeToGroup (0..1)
	output: out boolean (1..1)
	assign-output out :  ListsCompare (op, TestGroupBy(input1) -> numbers, TestGroupBy(input2) -> numbers, empty)
	 
	
func TestBinaryOpWithNumberGroupBy:
	inputs:
		op CompareOp (1..1)
		input1 TypeToGroup (0..1)
		numberIn number (0..1)
	output: out boolean (1..1)
	assign-output out : ListsCompare (op, TestGroupBy(input1) -> numbers, empty, numberIn)
	

type TypeToGroup:
	boolAttr boolean (0..1)
	amount number (0..1)
	currency string (0..1)
	manyAttr TypeToGroup (1..*)

type Foo:
	bar Bar (0..*)
	bar2 Bar (0..*)
	baz Baz (0..1)

type Bar:
	before number (0..1)
	after number (0..1)

type Baz:
	bazValue number (0..1)
	other number (0..1)
	
func FeatureCallEqualToLiteral:
	[qualification event]
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = 5

func FeatureCallEqualToFeatureCall:
	[qualification event]
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = foo -> bar -> after

func FeatureCallsEqualToLiteralOr:
	[qualification event]
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = 5 or foo -> baz -> other = 5

func FeatureCallListEqualToFeatureCall:
	[qualification event]
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = foo -> baz -> other

func FeatureCallListNotEqualToFeatureCall:
	[qualification event]
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before <> foo -> baz -> other
		
		
func MultipleOrFeatureCallsEqualToMultipleOrFeatureCalls:
	[qualification event]
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	alias values: [foo -> bar -> before, foo -> baz -> other]
	assign-output is_event:
		values contains foo -> bar -> after
		or values contains foo -> baz -> bazValue